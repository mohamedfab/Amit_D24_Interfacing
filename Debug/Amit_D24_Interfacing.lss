
Amit_D24_Interfacing.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000332a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000178  00800060  0000332a  000033be  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000031b  008001d8  008001d8  00003536  2**0
                  ALLOC
  3 .stab         000071e8  00000000  00000000  00003538  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000045bf  00000000  00000000  0000a720  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000ecdf  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000197  00000000  00000000  0000ee1f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001b11  00000000  00000000  0000efb6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000ebc  00000000  00000000  00010ac7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000e5b  00000000  00000000  00011983  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000127e0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002b1  00000000  00000000  00012940  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000836  00000000  00000000  00012bf1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00013427  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 0f 09 	jmp	0x121e	; 0x121e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 19 16 	jmp	0x2c32	; 0x2c32 <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e2       	ldi	r30, 0x2A	; 42
      68:	f3 e3       	ldi	r31, 0x33	; 51
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 3d       	cpi	r26, 0xD8	; 216
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a8 ed       	ldi	r26, 0xD8	; 216
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 3f       	cpi	r26, 0xF3	; 243
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 0d 12 	call	0x241a	; 0x241a <main>
      8a:	0c 94 93 19 	jmp	0x3326	; 0x3326 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 19 03 	call	0x632	; 0x632 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 49 03 	call	0x692	; 0x692 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 49 03 	call	0x692	; 0x692 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 3d 19 	jmp	0x327a	; 0x327a <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ac e7       	ldi	r26, 0x7C	; 124
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 59 19 	jmp	0x32b2	; 0x32b2 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 49 19 	jmp	0x3292	; 0x3292 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 65 04 	call	0x8ca	; 0x8ca <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 65 19 	jmp	0x32ca	; 0x32ca <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 49 19 	jmp	0x3292	; 0x3292 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 65 04 	call	0x8ca	; 0x8ca <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 65 19 	jmp	0x32ca	; 0x32ca <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 3d 19 	jmp	0x327a	; 0x327a <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8c e7       	ldi	r24, 0x7C	; 124
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 65 04 	call	0x8ca	; 0x8ca <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 59 19 	jmp	0x32b2	; 0x32b2 <__epilogue_restores__>

00000632 <__gesf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 49 19 	jmp	0x3292	; 0x3292 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gesf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gesf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 b2 05 	call	0xb64	; 0xb64 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gesf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 65 19 	jmp	0x32ca	; 0x32ca <__epilogue_restores__+0x18>

00000692 <__fixsfsi>:
     692:	ac e0       	ldi	r26, 0x0C	; 12
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 4d 19 	jmp	0x329a	; 0x329a <__prologue_saves__+0x20>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	ce 01       	movw	r24, r28
     6a8:	01 96       	adiw	r24, 0x01	; 1
     6aa:	be 01       	movw	r22, r28
     6ac:	6b 5f       	subi	r22, 0xFB	; 251
     6ae:	7f 4f       	sbci	r23, 0xFF	; 255
     6b0:	0e 94 3a 05 	call	0xa74	; 0xa74 <__unpack_f>
     6b4:	8d 81       	ldd	r24, Y+5	; 0x05
     6b6:	82 30       	cpi	r24, 0x02	; 2
     6b8:	61 f1       	breq	.+88     	; 0x712 <__fixsfsi+0x80>
     6ba:	82 30       	cpi	r24, 0x02	; 2
     6bc:	50 f1       	brcs	.+84     	; 0x712 <__fixsfsi+0x80>
     6be:	84 30       	cpi	r24, 0x04	; 4
     6c0:	21 f4       	brne	.+8      	; 0x6ca <__fixsfsi+0x38>
     6c2:	8e 81       	ldd	r24, Y+6	; 0x06
     6c4:	88 23       	and	r24, r24
     6c6:	51 f1       	breq	.+84     	; 0x71c <__fixsfsi+0x8a>
     6c8:	2e c0       	rjmp	.+92     	; 0x726 <__fixsfsi+0x94>
     6ca:	2f 81       	ldd	r18, Y+7	; 0x07
     6cc:	38 85       	ldd	r19, Y+8	; 0x08
     6ce:	37 fd       	sbrc	r19, 7
     6d0:	20 c0       	rjmp	.+64     	; 0x712 <__fixsfsi+0x80>
     6d2:	6e 81       	ldd	r22, Y+6	; 0x06
     6d4:	2f 31       	cpi	r18, 0x1F	; 31
     6d6:	31 05       	cpc	r19, r1
     6d8:	1c f0       	brlt	.+6      	; 0x6e0 <__fixsfsi+0x4e>
     6da:	66 23       	and	r22, r22
     6dc:	f9 f0       	breq	.+62     	; 0x71c <__fixsfsi+0x8a>
     6de:	23 c0       	rjmp	.+70     	; 0x726 <__fixsfsi+0x94>
     6e0:	8e e1       	ldi	r24, 0x1E	; 30
     6e2:	90 e0       	ldi	r25, 0x00	; 0
     6e4:	82 1b       	sub	r24, r18
     6e6:	93 0b       	sbc	r25, r19
     6e8:	29 85       	ldd	r18, Y+9	; 0x09
     6ea:	3a 85       	ldd	r19, Y+10	; 0x0a
     6ec:	4b 85       	ldd	r20, Y+11	; 0x0b
     6ee:	5c 85       	ldd	r21, Y+12	; 0x0c
     6f0:	04 c0       	rjmp	.+8      	; 0x6fa <__fixsfsi+0x68>
     6f2:	56 95       	lsr	r21
     6f4:	47 95       	ror	r20
     6f6:	37 95       	ror	r19
     6f8:	27 95       	ror	r18
     6fa:	8a 95       	dec	r24
     6fc:	d2 f7       	brpl	.-12     	; 0x6f2 <__fixsfsi+0x60>
     6fe:	66 23       	and	r22, r22
     700:	b1 f0       	breq	.+44     	; 0x72e <__fixsfsi+0x9c>
     702:	50 95       	com	r21
     704:	40 95       	com	r20
     706:	30 95       	com	r19
     708:	21 95       	neg	r18
     70a:	3f 4f       	sbci	r19, 0xFF	; 255
     70c:	4f 4f       	sbci	r20, 0xFF	; 255
     70e:	5f 4f       	sbci	r21, 0xFF	; 255
     710:	0e c0       	rjmp	.+28     	; 0x72e <__fixsfsi+0x9c>
     712:	20 e0       	ldi	r18, 0x00	; 0
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	40 e0       	ldi	r20, 0x00	; 0
     718:	50 e0       	ldi	r21, 0x00	; 0
     71a:	09 c0       	rjmp	.+18     	; 0x72e <__fixsfsi+0x9c>
     71c:	2f ef       	ldi	r18, 0xFF	; 255
     71e:	3f ef       	ldi	r19, 0xFF	; 255
     720:	4f ef       	ldi	r20, 0xFF	; 255
     722:	5f e7       	ldi	r21, 0x7F	; 127
     724:	04 c0       	rjmp	.+8      	; 0x72e <__fixsfsi+0x9c>
     726:	20 e0       	ldi	r18, 0x00	; 0
     728:	30 e0       	ldi	r19, 0x00	; 0
     72a:	40 e0       	ldi	r20, 0x00	; 0
     72c:	50 e8       	ldi	r21, 0x80	; 128
     72e:	b9 01       	movw	r22, r18
     730:	ca 01       	movw	r24, r20
     732:	2c 96       	adiw	r28, 0x0c	; 12
     734:	e2 e0       	ldi	r30, 0x02	; 2
     736:	0c 94 69 19 	jmp	0x32d2	; 0x32d2 <__epilogue_restores__+0x20>

0000073a <__floatunsisf>:
     73a:	a8 e0       	ldi	r26, 0x08	; 8
     73c:	b0 e0       	ldi	r27, 0x00	; 0
     73e:	e3 ea       	ldi	r30, 0xA3	; 163
     740:	f3 e0       	ldi	r31, 0x03	; 3
     742:	0c 94 45 19 	jmp	0x328a	; 0x328a <__prologue_saves__+0x10>
     746:	7b 01       	movw	r14, r22
     748:	8c 01       	movw	r16, r24
     74a:	61 15       	cp	r22, r1
     74c:	71 05       	cpc	r23, r1
     74e:	81 05       	cpc	r24, r1
     750:	91 05       	cpc	r25, r1
     752:	19 f4       	brne	.+6      	; 0x75a <__floatunsisf+0x20>
     754:	82 e0       	ldi	r24, 0x02	; 2
     756:	89 83       	std	Y+1, r24	; 0x01
     758:	60 c0       	rjmp	.+192    	; 0x81a <__floatunsisf+0xe0>
     75a:	83 e0       	ldi	r24, 0x03	; 3
     75c:	89 83       	std	Y+1, r24	; 0x01
     75e:	8e e1       	ldi	r24, 0x1E	; 30
     760:	c8 2e       	mov	r12, r24
     762:	d1 2c       	mov	r13, r1
     764:	dc 82       	std	Y+4, r13	; 0x04
     766:	cb 82       	std	Y+3, r12	; 0x03
     768:	ed 82       	std	Y+5, r14	; 0x05
     76a:	fe 82       	std	Y+6, r15	; 0x06
     76c:	0f 83       	std	Y+7, r16	; 0x07
     76e:	18 87       	std	Y+8, r17	; 0x08
     770:	c8 01       	movw	r24, r16
     772:	b7 01       	movw	r22, r14
     774:	0e 94 16 04 	call	0x82c	; 0x82c <__clzsi2>
     778:	fc 01       	movw	r30, r24
     77a:	31 97       	sbiw	r30, 0x01	; 1
     77c:	f7 ff       	sbrs	r31, 7
     77e:	3b c0       	rjmp	.+118    	; 0x7f6 <__floatunsisf+0xbc>
     780:	22 27       	eor	r18, r18
     782:	33 27       	eor	r19, r19
     784:	2e 1b       	sub	r18, r30
     786:	3f 0b       	sbc	r19, r31
     788:	57 01       	movw	r10, r14
     78a:	68 01       	movw	r12, r16
     78c:	02 2e       	mov	r0, r18
     78e:	04 c0       	rjmp	.+8      	; 0x798 <__floatunsisf+0x5e>
     790:	d6 94       	lsr	r13
     792:	c7 94       	ror	r12
     794:	b7 94       	ror	r11
     796:	a7 94       	ror	r10
     798:	0a 94       	dec	r0
     79a:	d2 f7       	brpl	.-12     	; 0x790 <__floatunsisf+0x56>
     79c:	40 e0       	ldi	r20, 0x00	; 0
     79e:	50 e0       	ldi	r21, 0x00	; 0
     7a0:	60 e0       	ldi	r22, 0x00	; 0
     7a2:	70 e0       	ldi	r23, 0x00	; 0
     7a4:	81 e0       	ldi	r24, 0x01	; 1
     7a6:	90 e0       	ldi	r25, 0x00	; 0
     7a8:	a0 e0       	ldi	r26, 0x00	; 0
     7aa:	b0 e0       	ldi	r27, 0x00	; 0
     7ac:	04 c0       	rjmp	.+8      	; 0x7b6 <__floatunsisf+0x7c>
     7ae:	88 0f       	add	r24, r24
     7b0:	99 1f       	adc	r25, r25
     7b2:	aa 1f       	adc	r26, r26
     7b4:	bb 1f       	adc	r27, r27
     7b6:	2a 95       	dec	r18
     7b8:	d2 f7       	brpl	.-12     	; 0x7ae <__floatunsisf+0x74>
     7ba:	01 97       	sbiw	r24, 0x01	; 1
     7bc:	a1 09       	sbc	r26, r1
     7be:	b1 09       	sbc	r27, r1
     7c0:	8e 21       	and	r24, r14
     7c2:	9f 21       	and	r25, r15
     7c4:	a0 23       	and	r26, r16
     7c6:	b1 23       	and	r27, r17
     7c8:	00 97       	sbiw	r24, 0x00	; 0
     7ca:	a1 05       	cpc	r26, r1
     7cc:	b1 05       	cpc	r27, r1
     7ce:	21 f0       	breq	.+8      	; 0x7d8 <__floatunsisf+0x9e>
     7d0:	41 e0       	ldi	r20, 0x01	; 1
     7d2:	50 e0       	ldi	r21, 0x00	; 0
     7d4:	60 e0       	ldi	r22, 0x00	; 0
     7d6:	70 e0       	ldi	r23, 0x00	; 0
     7d8:	4a 29       	or	r20, r10
     7da:	5b 29       	or	r21, r11
     7dc:	6c 29       	or	r22, r12
     7de:	7d 29       	or	r23, r13
     7e0:	4d 83       	std	Y+5, r20	; 0x05
     7e2:	5e 83       	std	Y+6, r21	; 0x06
     7e4:	6f 83       	std	Y+7, r22	; 0x07
     7e6:	78 87       	std	Y+8, r23	; 0x08
     7e8:	8e e1       	ldi	r24, 0x1E	; 30
     7ea:	90 e0       	ldi	r25, 0x00	; 0
     7ec:	8e 1b       	sub	r24, r30
     7ee:	9f 0b       	sbc	r25, r31
     7f0:	9c 83       	std	Y+4, r25	; 0x04
     7f2:	8b 83       	std	Y+3, r24	; 0x03
     7f4:	12 c0       	rjmp	.+36     	; 0x81a <__floatunsisf+0xe0>
     7f6:	30 97       	sbiw	r30, 0x00	; 0
     7f8:	81 f0       	breq	.+32     	; 0x81a <__floatunsisf+0xe0>
     7fa:	0e 2e       	mov	r0, r30
     7fc:	04 c0       	rjmp	.+8      	; 0x806 <__floatunsisf+0xcc>
     7fe:	ee 0c       	add	r14, r14
     800:	ff 1c       	adc	r15, r15
     802:	00 1f       	adc	r16, r16
     804:	11 1f       	adc	r17, r17
     806:	0a 94       	dec	r0
     808:	d2 f7       	brpl	.-12     	; 0x7fe <__floatunsisf+0xc4>
     80a:	ed 82       	std	Y+5, r14	; 0x05
     80c:	fe 82       	std	Y+6, r15	; 0x06
     80e:	0f 83       	std	Y+7, r16	; 0x07
     810:	18 87       	std	Y+8, r17	; 0x08
     812:	ce 1a       	sub	r12, r30
     814:	df 0a       	sbc	r13, r31
     816:	dc 82       	std	Y+4, r13	; 0x04
     818:	cb 82       	std	Y+3, r12	; 0x03
     81a:	1a 82       	std	Y+2, r1	; 0x02
     81c:	ce 01       	movw	r24, r28
     81e:	01 96       	adiw	r24, 0x01	; 1
     820:	0e 94 65 04 	call	0x8ca	; 0x8ca <__pack_f>
     824:	28 96       	adiw	r28, 0x08	; 8
     826:	ea e0       	ldi	r30, 0x0A	; 10
     828:	0c 94 61 19 	jmp	0x32c2	; 0x32c2 <__epilogue_restores__+0x10>

0000082c <__clzsi2>:
     82c:	ef 92       	push	r14
     82e:	ff 92       	push	r15
     830:	0f 93       	push	r16
     832:	1f 93       	push	r17
     834:	7b 01       	movw	r14, r22
     836:	8c 01       	movw	r16, r24
     838:	80 e0       	ldi	r24, 0x00	; 0
     83a:	e8 16       	cp	r14, r24
     83c:	80 e0       	ldi	r24, 0x00	; 0
     83e:	f8 06       	cpc	r15, r24
     840:	81 e0       	ldi	r24, 0x01	; 1
     842:	08 07       	cpc	r16, r24
     844:	80 e0       	ldi	r24, 0x00	; 0
     846:	18 07       	cpc	r17, r24
     848:	88 f4       	brcc	.+34     	; 0x86c <__stack+0xd>
     84a:	8f ef       	ldi	r24, 0xFF	; 255
     84c:	e8 16       	cp	r14, r24
     84e:	f1 04       	cpc	r15, r1
     850:	01 05       	cpc	r16, r1
     852:	11 05       	cpc	r17, r1
     854:	31 f0       	breq	.+12     	; 0x862 <__stack+0x3>
     856:	28 f0       	brcs	.+10     	; 0x862 <__stack+0x3>
     858:	88 e0       	ldi	r24, 0x08	; 8
     85a:	90 e0       	ldi	r25, 0x00	; 0
     85c:	a0 e0       	ldi	r26, 0x00	; 0
     85e:	b0 e0       	ldi	r27, 0x00	; 0
     860:	17 c0       	rjmp	.+46     	; 0x890 <__stack+0x31>
     862:	80 e0       	ldi	r24, 0x00	; 0
     864:	90 e0       	ldi	r25, 0x00	; 0
     866:	a0 e0       	ldi	r26, 0x00	; 0
     868:	b0 e0       	ldi	r27, 0x00	; 0
     86a:	12 c0       	rjmp	.+36     	; 0x890 <__stack+0x31>
     86c:	80 e0       	ldi	r24, 0x00	; 0
     86e:	e8 16       	cp	r14, r24
     870:	80 e0       	ldi	r24, 0x00	; 0
     872:	f8 06       	cpc	r15, r24
     874:	80 e0       	ldi	r24, 0x00	; 0
     876:	08 07       	cpc	r16, r24
     878:	81 e0       	ldi	r24, 0x01	; 1
     87a:	18 07       	cpc	r17, r24
     87c:	28 f0       	brcs	.+10     	; 0x888 <__stack+0x29>
     87e:	88 e1       	ldi	r24, 0x18	; 24
     880:	90 e0       	ldi	r25, 0x00	; 0
     882:	a0 e0       	ldi	r26, 0x00	; 0
     884:	b0 e0       	ldi	r27, 0x00	; 0
     886:	04 c0       	rjmp	.+8      	; 0x890 <__stack+0x31>
     888:	80 e1       	ldi	r24, 0x10	; 16
     88a:	90 e0       	ldi	r25, 0x00	; 0
     88c:	a0 e0       	ldi	r26, 0x00	; 0
     88e:	b0 e0       	ldi	r27, 0x00	; 0
     890:	20 e2       	ldi	r18, 0x20	; 32
     892:	30 e0       	ldi	r19, 0x00	; 0
     894:	40 e0       	ldi	r20, 0x00	; 0
     896:	50 e0       	ldi	r21, 0x00	; 0
     898:	28 1b       	sub	r18, r24
     89a:	39 0b       	sbc	r19, r25
     89c:	4a 0b       	sbc	r20, r26
     89e:	5b 0b       	sbc	r21, r27
     8a0:	04 c0       	rjmp	.+8      	; 0x8aa <__stack+0x4b>
     8a2:	16 95       	lsr	r17
     8a4:	07 95       	ror	r16
     8a6:	f7 94       	ror	r15
     8a8:	e7 94       	ror	r14
     8aa:	8a 95       	dec	r24
     8ac:	d2 f7       	brpl	.-12     	; 0x8a2 <__stack+0x43>
     8ae:	f7 01       	movw	r30, r14
     8b0:	ec 57       	subi	r30, 0x7C	; 124
     8b2:	ff 4f       	sbci	r31, 0xFF	; 255
     8b4:	80 81       	ld	r24, Z
     8b6:	28 1b       	sub	r18, r24
     8b8:	31 09       	sbc	r19, r1
     8ba:	41 09       	sbc	r20, r1
     8bc:	51 09       	sbc	r21, r1
     8be:	c9 01       	movw	r24, r18
     8c0:	1f 91       	pop	r17
     8c2:	0f 91       	pop	r16
     8c4:	ff 90       	pop	r15
     8c6:	ef 90       	pop	r14
     8c8:	08 95       	ret

000008ca <__pack_f>:
     8ca:	df 92       	push	r13
     8cc:	ef 92       	push	r14
     8ce:	ff 92       	push	r15
     8d0:	0f 93       	push	r16
     8d2:	1f 93       	push	r17
     8d4:	fc 01       	movw	r30, r24
     8d6:	e4 80       	ldd	r14, Z+4	; 0x04
     8d8:	f5 80       	ldd	r15, Z+5	; 0x05
     8da:	06 81       	ldd	r16, Z+6	; 0x06
     8dc:	17 81       	ldd	r17, Z+7	; 0x07
     8de:	d1 80       	ldd	r13, Z+1	; 0x01
     8e0:	80 81       	ld	r24, Z
     8e2:	82 30       	cpi	r24, 0x02	; 2
     8e4:	48 f4       	brcc	.+18     	; 0x8f8 <__pack_f+0x2e>
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	90 e0       	ldi	r25, 0x00	; 0
     8ea:	a0 e1       	ldi	r26, 0x10	; 16
     8ec:	b0 e0       	ldi	r27, 0x00	; 0
     8ee:	e8 2a       	or	r14, r24
     8f0:	f9 2a       	or	r15, r25
     8f2:	0a 2b       	or	r16, r26
     8f4:	1b 2b       	or	r17, r27
     8f6:	a5 c0       	rjmp	.+330    	; 0xa42 <__pack_f+0x178>
     8f8:	84 30       	cpi	r24, 0x04	; 4
     8fa:	09 f4       	brne	.+2      	; 0x8fe <__pack_f+0x34>
     8fc:	9f c0       	rjmp	.+318    	; 0xa3c <__pack_f+0x172>
     8fe:	82 30       	cpi	r24, 0x02	; 2
     900:	21 f4       	brne	.+8      	; 0x90a <__pack_f+0x40>
     902:	ee 24       	eor	r14, r14
     904:	ff 24       	eor	r15, r15
     906:	87 01       	movw	r16, r14
     908:	05 c0       	rjmp	.+10     	; 0x914 <__pack_f+0x4a>
     90a:	e1 14       	cp	r14, r1
     90c:	f1 04       	cpc	r15, r1
     90e:	01 05       	cpc	r16, r1
     910:	11 05       	cpc	r17, r1
     912:	19 f4       	brne	.+6      	; 0x91a <__pack_f+0x50>
     914:	e0 e0       	ldi	r30, 0x00	; 0
     916:	f0 e0       	ldi	r31, 0x00	; 0
     918:	96 c0       	rjmp	.+300    	; 0xa46 <__pack_f+0x17c>
     91a:	62 81       	ldd	r22, Z+2	; 0x02
     91c:	73 81       	ldd	r23, Z+3	; 0x03
     91e:	9f ef       	ldi	r25, 0xFF	; 255
     920:	62 38       	cpi	r22, 0x82	; 130
     922:	79 07       	cpc	r23, r25
     924:	0c f0       	brlt	.+2      	; 0x928 <__pack_f+0x5e>
     926:	5b c0       	rjmp	.+182    	; 0x9de <__pack_f+0x114>
     928:	22 e8       	ldi	r18, 0x82	; 130
     92a:	3f ef       	ldi	r19, 0xFF	; 255
     92c:	26 1b       	sub	r18, r22
     92e:	37 0b       	sbc	r19, r23
     930:	2a 31       	cpi	r18, 0x1A	; 26
     932:	31 05       	cpc	r19, r1
     934:	2c f0       	brlt	.+10     	; 0x940 <__pack_f+0x76>
     936:	20 e0       	ldi	r18, 0x00	; 0
     938:	30 e0       	ldi	r19, 0x00	; 0
     93a:	40 e0       	ldi	r20, 0x00	; 0
     93c:	50 e0       	ldi	r21, 0x00	; 0
     93e:	2a c0       	rjmp	.+84     	; 0x994 <__pack_f+0xca>
     940:	b8 01       	movw	r22, r16
     942:	a7 01       	movw	r20, r14
     944:	02 2e       	mov	r0, r18
     946:	04 c0       	rjmp	.+8      	; 0x950 <__pack_f+0x86>
     948:	76 95       	lsr	r23
     94a:	67 95       	ror	r22
     94c:	57 95       	ror	r21
     94e:	47 95       	ror	r20
     950:	0a 94       	dec	r0
     952:	d2 f7       	brpl	.-12     	; 0x948 <__pack_f+0x7e>
     954:	81 e0       	ldi	r24, 0x01	; 1
     956:	90 e0       	ldi	r25, 0x00	; 0
     958:	a0 e0       	ldi	r26, 0x00	; 0
     95a:	b0 e0       	ldi	r27, 0x00	; 0
     95c:	04 c0       	rjmp	.+8      	; 0x966 <__pack_f+0x9c>
     95e:	88 0f       	add	r24, r24
     960:	99 1f       	adc	r25, r25
     962:	aa 1f       	adc	r26, r26
     964:	bb 1f       	adc	r27, r27
     966:	2a 95       	dec	r18
     968:	d2 f7       	brpl	.-12     	; 0x95e <__pack_f+0x94>
     96a:	01 97       	sbiw	r24, 0x01	; 1
     96c:	a1 09       	sbc	r26, r1
     96e:	b1 09       	sbc	r27, r1
     970:	8e 21       	and	r24, r14
     972:	9f 21       	and	r25, r15
     974:	a0 23       	and	r26, r16
     976:	b1 23       	and	r27, r17
     978:	00 97       	sbiw	r24, 0x00	; 0
     97a:	a1 05       	cpc	r26, r1
     97c:	b1 05       	cpc	r27, r1
     97e:	21 f0       	breq	.+8      	; 0x988 <__pack_f+0xbe>
     980:	81 e0       	ldi	r24, 0x01	; 1
     982:	90 e0       	ldi	r25, 0x00	; 0
     984:	a0 e0       	ldi	r26, 0x00	; 0
     986:	b0 e0       	ldi	r27, 0x00	; 0
     988:	9a 01       	movw	r18, r20
     98a:	ab 01       	movw	r20, r22
     98c:	28 2b       	or	r18, r24
     98e:	39 2b       	or	r19, r25
     990:	4a 2b       	or	r20, r26
     992:	5b 2b       	or	r21, r27
     994:	da 01       	movw	r26, r20
     996:	c9 01       	movw	r24, r18
     998:	8f 77       	andi	r24, 0x7F	; 127
     99a:	90 70       	andi	r25, 0x00	; 0
     99c:	a0 70       	andi	r26, 0x00	; 0
     99e:	b0 70       	andi	r27, 0x00	; 0
     9a0:	80 34       	cpi	r24, 0x40	; 64
     9a2:	91 05       	cpc	r25, r1
     9a4:	a1 05       	cpc	r26, r1
     9a6:	b1 05       	cpc	r27, r1
     9a8:	39 f4       	brne	.+14     	; 0x9b8 <__pack_f+0xee>
     9aa:	27 ff       	sbrs	r18, 7
     9ac:	09 c0       	rjmp	.+18     	; 0x9c0 <__pack_f+0xf6>
     9ae:	20 5c       	subi	r18, 0xC0	; 192
     9b0:	3f 4f       	sbci	r19, 0xFF	; 255
     9b2:	4f 4f       	sbci	r20, 0xFF	; 255
     9b4:	5f 4f       	sbci	r21, 0xFF	; 255
     9b6:	04 c0       	rjmp	.+8      	; 0x9c0 <__pack_f+0xf6>
     9b8:	21 5c       	subi	r18, 0xC1	; 193
     9ba:	3f 4f       	sbci	r19, 0xFF	; 255
     9bc:	4f 4f       	sbci	r20, 0xFF	; 255
     9be:	5f 4f       	sbci	r21, 0xFF	; 255
     9c0:	e0 e0       	ldi	r30, 0x00	; 0
     9c2:	f0 e0       	ldi	r31, 0x00	; 0
     9c4:	20 30       	cpi	r18, 0x00	; 0
     9c6:	a0 e0       	ldi	r26, 0x00	; 0
     9c8:	3a 07       	cpc	r19, r26
     9ca:	a0 e0       	ldi	r26, 0x00	; 0
     9cc:	4a 07       	cpc	r20, r26
     9ce:	a0 e4       	ldi	r26, 0x40	; 64
     9d0:	5a 07       	cpc	r21, r26
     9d2:	10 f0       	brcs	.+4      	; 0x9d8 <__pack_f+0x10e>
     9d4:	e1 e0       	ldi	r30, 0x01	; 1
     9d6:	f0 e0       	ldi	r31, 0x00	; 0
     9d8:	79 01       	movw	r14, r18
     9da:	8a 01       	movw	r16, r20
     9dc:	27 c0       	rjmp	.+78     	; 0xa2c <__pack_f+0x162>
     9de:	60 38       	cpi	r22, 0x80	; 128
     9e0:	71 05       	cpc	r23, r1
     9e2:	64 f5       	brge	.+88     	; 0xa3c <__pack_f+0x172>
     9e4:	fb 01       	movw	r30, r22
     9e6:	e1 58       	subi	r30, 0x81	; 129
     9e8:	ff 4f       	sbci	r31, 0xFF	; 255
     9ea:	d8 01       	movw	r26, r16
     9ec:	c7 01       	movw	r24, r14
     9ee:	8f 77       	andi	r24, 0x7F	; 127
     9f0:	90 70       	andi	r25, 0x00	; 0
     9f2:	a0 70       	andi	r26, 0x00	; 0
     9f4:	b0 70       	andi	r27, 0x00	; 0
     9f6:	80 34       	cpi	r24, 0x40	; 64
     9f8:	91 05       	cpc	r25, r1
     9fa:	a1 05       	cpc	r26, r1
     9fc:	b1 05       	cpc	r27, r1
     9fe:	39 f4       	brne	.+14     	; 0xa0e <__pack_f+0x144>
     a00:	e7 fe       	sbrs	r14, 7
     a02:	0d c0       	rjmp	.+26     	; 0xa1e <__pack_f+0x154>
     a04:	80 e4       	ldi	r24, 0x40	; 64
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	a0 e0       	ldi	r26, 0x00	; 0
     a0a:	b0 e0       	ldi	r27, 0x00	; 0
     a0c:	04 c0       	rjmp	.+8      	; 0xa16 <__pack_f+0x14c>
     a0e:	8f e3       	ldi	r24, 0x3F	; 63
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	a0 e0       	ldi	r26, 0x00	; 0
     a14:	b0 e0       	ldi	r27, 0x00	; 0
     a16:	e8 0e       	add	r14, r24
     a18:	f9 1e       	adc	r15, r25
     a1a:	0a 1f       	adc	r16, r26
     a1c:	1b 1f       	adc	r17, r27
     a1e:	17 ff       	sbrs	r17, 7
     a20:	05 c0       	rjmp	.+10     	; 0xa2c <__pack_f+0x162>
     a22:	16 95       	lsr	r17
     a24:	07 95       	ror	r16
     a26:	f7 94       	ror	r15
     a28:	e7 94       	ror	r14
     a2a:	31 96       	adiw	r30, 0x01	; 1
     a2c:	87 e0       	ldi	r24, 0x07	; 7
     a2e:	16 95       	lsr	r17
     a30:	07 95       	ror	r16
     a32:	f7 94       	ror	r15
     a34:	e7 94       	ror	r14
     a36:	8a 95       	dec	r24
     a38:	d1 f7       	brne	.-12     	; 0xa2e <__pack_f+0x164>
     a3a:	05 c0       	rjmp	.+10     	; 0xa46 <__pack_f+0x17c>
     a3c:	ee 24       	eor	r14, r14
     a3e:	ff 24       	eor	r15, r15
     a40:	87 01       	movw	r16, r14
     a42:	ef ef       	ldi	r30, 0xFF	; 255
     a44:	f0 e0       	ldi	r31, 0x00	; 0
     a46:	6e 2f       	mov	r22, r30
     a48:	67 95       	ror	r22
     a4a:	66 27       	eor	r22, r22
     a4c:	67 95       	ror	r22
     a4e:	90 2f       	mov	r25, r16
     a50:	9f 77       	andi	r25, 0x7F	; 127
     a52:	d7 94       	ror	r13
     a54:	dd 24       	eor	r13, r13
     a56:	d7 94       	ror	r13
     a58:	8e 2f       	mov	r24, r30
     a5a:	86 95       	lsr	r24
     a5c:	49 2f       	mov	r20, r25
     a5e:	46 2b       	or	r20, r22
     a60:	58 2f       	mov	r21, r24
     a62:	5d 29       	or	r21, r13
     a64:	b7 01       	movw	r22, r14
     a66:	ca 01       	movw	r24, r20
     a68:	1f 91       	pop	r17
     a6a:	0f 91       	pop	r16
     a6c:	ff 90       	pop	r15
     a6e:	ef 90       	pop	r14
     a70:	df 90       	pop	r13
     a72:	08 95       	ret

00000a74 <__unpack_f>:
     a74:	fc 01       	movw	r30, r24
     a76:	db 01       	movw	r26, r22
     a78:	40 81       	ld	r20, Z
     a7a:	51 81       	ldd	r21, Z+1	; 0x01
     a7c:	22 81       	ldd	r18, Z+2	; 0x02
     a7e:	62 2f       	mov	r22, r18
     a80:	6f 77       	andi	r22, 0x7F	; 127
     a82:	70 e0       	ldi	r23, 0x00	; 0
     a84:	22 1f       	adc	r18, r18
     a86:	22 27       	eor	r18, r18
     a88:	22 1f       	adc	r18, r18
     a8a:	93 81       	ldd	r25, Z+3	; 0x03
     a8c:	89 2f       	mov	r24, r25
     a8e:	88 0f       	add	r24, r24
     a90:	82 2b       	or	r24, r18
     a92:	28 2f       	mov	r18, r24
     a94:	30 e0       	ldi	r19, 0x00	; 0
     a96:	99 1f       	adc	r25, r25
     a98:	99 27       	eor	r25, r25
     a9a:	99 1f       	adc	r25, r25
     a9c:	11 96       	adiw	r26, 0x01	; 1
     a9e:	9c 93       	st	X, r25
     aa0:	11 97       	sbiw	r26, 0x01	; 1
     aa2:	21 15       	cp	r18, r1
     aa4:	31 05       	cpc	r19, r1
     aa6:	a9 f5       	brne	.+106    	; 0xb12 <__unpack_f+0x9e>
     aa8:	41 15       	cp	r20, r1
     aaa:	51 05       	cpc	r21, r1
     aac:	61 05       	cpc	r22, r1
     aae:	71 05       	cpc	r23, r1
     ab0:	11 f4       	brne	.+4      	; 0xab6 <__unpack_f+0x42>
     ab2:	82 e0       	ldi	r24, 0x02	; 2
     ab4:	37 c0       	rjmp	.+110    	; 0xb24 <__unpack_f+0xb0>
     ab6:	82 e8       	ldi	r24, 0x82	; 130
     ab8:	9f ef       	ldi	r25, 0xFF	; 255
     aba:	13 96       	adiw	r26, 0x03	; 3
     abc:	9c 93       	st	X, r25
     abe:	8e 93       	st	-X, r24
     ac0:	12 97       	sbiw	r26, 0x02	; 2
     ac2:	9a 01       	movw	r18, r20
     ac4:	ab 01       	movw	r20, r22
     ac6:	67 e0       	ldi	r22, 0x07	; 7
     ac8:	22 0f       	add	r18, r18
     aca:	33 1f       	adc	r19, r19
     acc:	44 1f       	adc	r20, r20
     ace:	55 1f       	adc	r21, r21
     ad0:	6a 95       	dec	r22
     ad2:	d1 f7       	brne	.-12     	; 0xac8 <__unpack_f+0x54>
     ad4:	83 e0       	ldi	r24, 0x03	; 3
     ad6:	8c 93       	st	X, r24
     ad8:	0d c0       	rjmp	.+26     	; 0xaf4 <__unpack_f+0x80>
     ada:	22 0f       	add	r18, r18
     adc:	33 1f       	adc	r19, r19
     ade:	44 1f       	adc	r20, r20
     ae0:	55 1f       	adc	r21, r21
     ae2:	12 96       	adiw	r26, 0x02	; 2
     ae4:	8d 91       	ld	r24, X+
     ae6:	9c 91       	ld	r25, X
     ae8:	13 97       	sbiw	r26, 0x03	; 3
     aea:	01 97       	sbiw	r24, 0x01	; 1
     aec:	13 96       	adiw	r26, 0x03	; 3
     aee:	9c 93       	st	X, r25
     af0:	8e 93       	st	-X, r24
     af2:	12 97       	sbiw	r26, 0x02	; 2
     af4:	20 30       	cpi	r18, 0x00	; 0
     af6:	80 e0       	ldi	r24, 0x00	; 0
     af8:	38 07       	cpc	r19, r24
     afa:	80 e0       	ldi	r24, 0x00	; 0
     afc:	48 07       	cpc	r20, r24
     afe:	80 e4       	ldi	r24, 0x40	; 64
     b00:	58 07       	cpc	r21, r24
     b02:	58 f3       	brcs	.-42     	; 0xada <__unpack_f+0x66>
     b04:	14 96       	adiw	r26, 0x04	; 4
     b06:	2d 93       	st	X+, r18
     b08:	3d 93       	st	X+, r19
     b0a:	4d 93       	st	X+, r20
     b0c:	5c 93       	st	X, r21
     b0e:	17 97       	sbiw	r26, 0x07	; 7
     b10:	08 95       	ret
     b12:	2f 3f       	cpi	r18, 0xFF	; 255
     b14:	31 05       	cpc	r19, r1
     b16:	79 f4       	brne	.+30     	; 0xb36 <__unpack_f+0xc2>
     b18:	41 15       	cp	r20, r1
     b1a:	51 05       	cpc	r21, r1
     b1c:	61 05       	cpc	r22, r1
     b1e:	71 05       	cpc	r23, r1
     b20:	19 f4       	brne	.+6      	; 0xb28 <__unpack_f+0xb4>
     b22:	84 e0       	ldi	r24, 0x04	; 4
     b24:	8c 93       	st	X, r24
     b26:	08 95       	ret
     b28:	64 ff       	sbrs	r22, 4
     b2a:	03 c0       	rjmp	.+6      	; 0xb32 <__unpack_f+0xbe>
     b2c:	81 e0       	ldi	r24, 0x01	; 1
     b2e:	8c 93       	st	X, r24
     b30:	12 c0       	rjmp	.+36     	; 0xb56 <__unpack_f+0xe2>
     b32:	1c 92       	st	X, r1
     b34:	10 c0       	rjmp	.+32     	; 0xb56 <__unpack_f+0xe2>
     b36:	2f 57       	subi	r18, 0x7F	; 127
     b38:	30 40       	sbci	r19, 0x00	; 0
     b3a:	13 96       	adiw	r26, 0x03	; 3
     b3c:	3c 93       	st	X, r19
     b3e:	2e 93       	st	-X, r18
     b40:	12 97       	sbiw	r26, 0x02	; 2
     b42:	83 e0       	ldi	r24, 0x03	; 3
     b44:	8c 93       	st	X, r24
     b46:	87 e0       	ldi	r24, 0x07	; 7
     b48:	44 0f       	add	r20, r20
     b4a:	55 1f       	adc	r21, r21
     b4c:	66 1f       	adc	r22, r22
     b4e:	77 1f       	adc	r23, r23
     b50:	8a 95       	dec	r24
     b52:	d1 f7       	brne	.-12     	; 0xb48 <__unpack_f+0xd4>
     b54:	70 64       	ori	r23, 0x40	; 64
     b56:	14 96       	adiw	r26, 0x04	; 4
     b58:	4d 93       	st	X+, r20
     b5a:	5d 93       	st	X+, r21
     b5c:	6d 93       	st	X+, r22
     b5e:	7c 93       	st	X, r23
     b60:	17 97       	sbiw	r26, 0x07	; 7
     b62:	08 95       	ret

00000b64 <__fpcmp_parts_f>:
     b64:	1f 93       	push	r17
     b66:	dc 01       	movw	r26, r24
     b68:	fb 01       	movw	r30, r22
     b6a:	9c 91       	ld	r25, X
     b6c:	92 30       	cpi	r25, 0x02	; 2
     b6e:	08 f4       	brcc	.+2      	; 0xb72 <__fpcmp_parts_f+0xe>
     b70:	47 c0       	rjmp	.+142    	; 0xc00 <__fpcmp_parts_f+0x9c>
     b72:	80 81       	ld	r24, Z
     b74:	82 30       	cpi	r24, 0x02	; 2
     b76:	08 f4       	brcc	.+2      	; 0xb7a <__fpcmp_parts_f+0x16>
     b78:	43 c0       	rjmp	.+134    	; 0xc00 <__fpcmp_parts_f+0x9c>
     b7a:	94 30       	cpi	r25, 0x04	; 4
     b7c:	51 f4       	brne	.+20     	; 0xb92 <__fpcmp_parts_f+0x2e>
     b7e:	11 96       	adiw	r26, 0x01	; 1
     b80:	1c 91       	ld	r17, X
     b82:	84 30       	cpi	r24, 0x04	; 4
     b84:	99 f5       	brne	.+102    	; 0xbec <__fpcmp_parts_f+0x88>
     b86:	81 81       	ldd	r24, Z+1	; 0x01
     b88:	68 2f       	mov	r22, r24
     b8a:	70 e0       	ldi	r23, 0x00	; 0
     b8c:	61 1b       	sub	r22, r17
     b8e:	71 09       	sbc	r23, r1
     b90:	3f c0       	rjmp	.+126    	; 0xc10 <__fpcmp_parts_f+0xac>
     b92:	84 30       	cpi	r24, 0x04	; 4
     b94:	21 f0       	breq	.+8      	; 0xb9e <__fpcmp_parts_f+0x3a>
     b96:	92 30       	cpi	r25, 0x02	; 2
     b98:	31 f4       	brne	.+12     	; 0xba6 <__fpcmp_parts_f+0x42>
     b9a:	82 30       	cpi	r24, 0x02	; 2
     b9c:	b9 f1       	breq	.+110    	; 0xc0c <__fpcmp_parts_f+0xa8>
     b9e:	81 81       	ldd	r24, Z+1	; 0x01
     ba0:	88 23       	and	r24, r24
     ba2:	89 f1       	breq	.+98     	; 0xc06 <__fpcmp_parts_f+0xa2>
     ba4:	2d c0       	rjmp	.+90     	; 0xc00 <__fpcmp_parts_f+0x9c>
     ba6:	11 96       	adiw	r26, 0x01	; 1
     ba8:	1c 91       	ld	r17, X
     baa:	11 97       	sbiw	r26, 0x01	; 1
     bac:	82 30       	cpi	r24, 0x02	; 2
     bae:	f1 f0       	breq	.+60     	; 0xbec <__fpcmp_parts_f+0x88>
     bb0:	81 81       	ldd	r24, Z+1	; 0x01
     bb2:	18 17       	cp	r17, r24
     bb4:	d9 f4       	brne	.+54     	; 0xbec <__fpcmp_parts_f+0x88>
     bb6:	12 96       	adiw	r26, 0x02	; 2
     bb8:	2d 91       	ld	r18, X+
     bba:	3c 91       	ld	r19, X
     bbc:	13 97       	sbiw	r26, 0x03	; 3
     bbe:	82 81       	ldd	r24, Z+2	; 0x02
     bc0:	93 81       	ldd	r25, Z+3	; 0x03
     bc2:	82 17       	cp	r24, r18
     bc4:	93 07       	cpc	r25, r19
     bc6:	94 f0       	brlt	.+36     	; 0xbec <__fpcmp_parts_f+0x88>
     bc8:	28 17       	cp	r18, r24
     bca:	39 07       	cpc	r19, r25
     bcc:	bc f0       	brlt	.+46     	; 0xbfc <__fpcmp_parts_f+0x98>
     bce:	14 96       	adiw	r26, 0x04	; 4
     bd0:	8d 91       	ld	r24, X+
     bd2:	9d 91       	ld	r25, X+
     bd4:	0d 90       	ld	r0, X+
     bd6:	bc 91       	ld	r27, X
     bd8:	a0 2d       	mov	r26, r0
     bda:	24 81       	ldd	r18, Z+4	; 0x04
     bdc:	35 81       	ldd	r19, Z+5	; 0x05
     bde:	46 81       	ldd	r20, Z+6	; 0x06
     be0:	57 81       	ldd	r21, Z+7	; 0x07
     be2:	28 17       	cp	r18, r24
     be4:	39 07       	cpc	r19, r25
     be6:	4a 07       	cpc	r20, r26
     be8:	5b 07       	cpc	r21, r27
     bea:	18 f4       	brcc	.+6      	; 0xbf2 <__fpcmp_parts_f+0x8e>
     bec:	11 23       	and	r17, r17
     bee:	41 f0       	breq	.+16     	; 0xc00 <__fpcmp_parts_f+0x9c>
     bf0:	0a c0       	rjmp	.+20     	; 0xc06 <__fpcmp_parts_f+0xa2>
     bf2:	82 17       	cp	r24, r18
     bf4:	93 07       	cpc	r25, r19
     bf6:	a4 07       	cpc	r26, r20
     bf8:	b5 07       	cpc	r27, r21
     bfa:	40 f4       	brcc	.+16     	; 0xc0c <__fpcmp_parts_f+0xa8>
     bfc:	11 23       	and	r17, r17
     bfe:	19 f0       	breq	.+6      	; 0xc06 <__fpcmp_parts_f+0xa2>
     c00:	61 e0       	ldi	r22, 0x01	; 1
     c02:	70 e0       	ldi	r23, 0x00	; 0
     c04:	05 c0       	rjmp	.+10     	; 0xc10 <__fpcmp_parts_f+0xac>
     c06:	6f ef       	ldi	r22, 0xFF	; 255
     c08:	7f ef       	ldi	r23, 0xFF	; 255
     c0a:	02 c0       	rjmp	.+4      	; 0xc10 <__fpcmp_parts_f+0xac>
     c0c:	60 e0       	ldi	r22, 0x00	; 0
     c0e:	70 e0       	ldi	r23, 0x00	; 0
     c10:	cb 01       	movw	r24, r22
     c12:	1f 91       	pop	r17
     c14:	08 95       	ret

00000c16 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     c16:	ef 92       	push	r14
     c18:	ff 92       	push	r15
     c1a:	0f 93       	push	r16
     c1c:	1f 93       	push	r17
     c1e:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     c20:	05 80       	ldd	r0, Z+5	; 0x05
     c22:	f6 81       	ldd	r31, Z+6	; 0x06
     c24:	e0 2d       	mov	r30, r0
     c26:	e6 80       	ldd	r14, Z+6	; 0x06
     c28:	f7 80       	ldd	r15, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     c2a:	87 01       	movw	r16, r14
     c2c:	04 5f       	subi	r16, 0xF4	; 244
     c2e:	1f 4f       	sbci	r17, 0xFF	; 255
     c30:	c8 01       	movw	r24, r16
     c32:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     c36:	89 e0       	ldi	r24, 0x09	; 9
     c38:	92 e0       	ldi	r25, 0x02	; 2
     c3a:	b8 01       	movw	r22, r16
     c3c:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vListInsertEnd>
     c40:	20 e0       	ldi	r18, 0x00	; 0
     c42:	e0 91 d8 01 	lds	r30, 0x01D8
     c46:	f0 91 d9 01 	lds	r31, 0x01D9
     c4a:	d7 01       	movw	r26, r14
     c4c:	56 96       	adiw	r26, 0x16	; 22
     c4e:	9c 91       	ld	r25, X
     c50:	86 89       	ldd	r24, Z+22	; 0x16
     c52:	98 17       	cp	r25, r24
     c54:	08 f0       	brcs	.+2      	; 0xc58 <xCoRoutineRemoveFromEventList+0x42>
     c56:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     c58:	82 2f       	mov	r24, r18
     c5a:	1f 91       	pop	r17
     c5c:	0f 91       	pop	r16
     c5e:	ff 90       	pop	r15
     c60:	ef 90       	pop	r14
     c62:	08 95       	ret

00000c64 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     c64:	ff 92       	push	r15
     c66:	0f 93       	push	r16
     c68:	1f 93       	push	r17
     c6a:	cf 93       	push	r28
     c6c:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     c6e:	80 91 09 02 	lds	r24, 0x0209
     c72:	88 23       	and	r24, r24
     c74:	39 f1       	breq	.+78     	; 0xcc4 <vCoRoutineSchedule+0x60>
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     c76:	99 e0       	ldi	r25, 0x09	; 9
     c78:	f9 2e       	mov	r15, r25
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     c7a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     c7c:	e0 91 0e 02 	lds	r30, 0x020E
     c80:	f0 91 0f 02 	lds	r31, 0x020F
     c84:	06 81       	ldd	r16, Z+6	; 0x06
     c86:	17 81       	ldd	r17, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     c88:	c8 01       	movw	r24, r16
     c8a:	0c 96       	adiw	r24, 0x0c	; 12
     c8c:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     c90:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     c92:	e8 01       	movw	r28, r16
     c94:	22 96       	adiw	r28, 0x02	; 2
     c96:	ce 01       	movw	r24, r28
     c98:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     c9c:	f8 01       	movw	r30, r16
     c9e:	96 89       	ldd	r25, Z+22	; 0x16
     ca0:	80 91 da 01 	lds	r24, 0x01DA
     ca4:	89 17       	cp	r24, r25
     ca6:	10 f4       	brcc	.+4      	; 0xcac <vCoRoutineSchedule+0x48>
     ca8:	90 93 da 01 	sts	0x01DA, r25
     cac:	9f 9d       	mul	r25, r15
     cae:	c0 01       	movw	r24, r0
     cb0:	11 24       	eor	r1, r1
     cb2:	8f 51       	subi	r24, 0x1F	; 31
     cb4:	9e 4f       	sbci	r25, 0xFE	; 254
     cb6:	be 01       	movw	r22, r28
     cb8:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     cbc:	80 91 09 02 	lds	r24, 0x0209
     cc0:	88 23       	and	r24, r24
     cc2:	d9 f6       	brne	.-74     	; 0xc7a <vCoRoutineSchedule+0x16>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     cc4:	0e 94 8b 0c 	call	0x1916	; 0x1916 <xTaskGetTickCount>
     cc8:	20 91 db 01 	lds	r18, 0x01DB
     ccc:	30 91 dc 01 	lds	r19, 0x01DC
     cd0:	82 1b       	sub	r24, r18
     cd2:	93 0b       	sbc	r25, r19
     cd4:	90 93 de 01 	sts	0x01DE, r25
     cd8:	80 93 dd 01 	sts	0x01DD, r24
     cdc:	20 91 df 01 	lds	r18, 0x01DF
     ce0:	30 91 e0 01 	lds	r19, 0x01E0
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     ce4:	89 e0       	ldi	r24, 0x09	; 9
     ce6:	f8 2e       	mov	r15, r24
     ce8:	07 c0       	rjmp	.+14     	; 0xcf8 <vCoRoutineSchedule+0x94>
     cea:	e0 91 05 02 	lds	r30, 0x0205
     cee:	f0 91 06 02 	lds	r31, 0x0206
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     cf2:	80 81       	ld	r24, Z
     cf4:	88 23       	and	r24, r24
     cf6:	41 f5       	brne	.+80     	; 0xd48 <vCoRoutineSchedule+0xe4>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     cf8:	80 91 dd 01 	lds	r24, 0x01DD
     cfc:	90 91 de 01 	lds	r25, 0x01DE
     d00:	00 97       	sbiw	r24, 0x00	; 0
     d02:	09 f4       	brne	.+2      	; 0xd06 <vCoRoutineSchedule+0xa2>
     d04:	5d c0       	rjmp	.+186    	; 0xdc0 <vCoRoutineSchedule+0x15c>
	{
		xCoRoutineTickCount++;
     d06:	2f 5f       	subi	r18, 0xFF	; 255
     d08:	3f 4f       	sbci	r19, 0xFF	; 255
     d0a:	30 93 e0 01 	sts	0x01E0, r19
     d0e:	20 93 df 01 	sts	0x01DF, r18
		xPassedTicks--;
     d12:	01 97       	sbiw	r24, 0x01	; 1
     d14:	90 93 de 01 	sts	0x01DE, r25
     d18:	80 93 dd 01 	sts	0x01DD, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     d1c:	21 15       	cp	r18, r1
     d1e:	31 05       	cpc	r19, r1
     d20:	21 f7       	brne	.-56     	; 0xcea <vCoRoutineSchedule+0x86>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     d22:	80 91 05 02 	lds	r24, 0x0205
     d26:	90 91 06 02 	lds	r25, 0x0206
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     d2a:	e0 91 07 02 	lds	r30, 0x0207
     d2e:	f0 91 08 02 	lds	r31, 0x0208
     d32:	f0 93 06 02 	sts	0x0206, r31
     d36:	e0 93 05 02 	sts	0x0205, r30
			pxOverflowDelayedCoRoutineList = pxTemp;
     d3a:	90 93 08 02 	sts	0x0208, r25
     d3e:	80 93 07 02 	sts	0x0207, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     d42:	80 81       	ld	r24, Z
     d44:	88 23       	and	r24, r24
     d46:	c1 f2       	breq	.-80     	; 0xcf8 <vCoRoutineSchedule+0x94>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     d48:	05 80       	ldd	r0, Z+5	; 0x05
     d4a:	f6 81       	ldd	r31, Z+6	; 0x06
     d4c:	e0 2d       	mov	r30, r0
     d4e:	c6 81       	ldd	r28, Z+6	; 0x06
     d50:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     d52:	8a 81       	ldd	r24, Y+2	; 0x02
     d54:	9b 81       	ldd	r25, Y+3	; 0x03
     d56:	28 17       	cp	r18, r24
     d58:	39 07       	cpc	r19, r25
     d5a:	70 f2       	brcs	.-100    	; 0xcf8 <vCoRoutineSchedule+0x94>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     d5c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     d5e:	8e 01       	movw	r16, r28
     d60:	0e 5f       	subi	r16, 0xFE	; 254
     d62:	1f 4f       	sbci	r17, 0xFF	; 255
     d64:	c8 01       	movw	r24, r16
     d66:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     d6a:	8c 89       	ldd	r24, Y+20	; 0x14
     d6c:	9d 89       	ldd	r25, Y+21	; 0x15
     d6e:	89 2b       	or	r24, r25
     d70:	21 f0       	breq	.+8      	; 0xd7a <vCoRoutineSchedule+0x116>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     d72:	ce 01       	movw	r24, r28
     d74:	0c 96       	adiw	r24, 0x0c	; 12
     d76:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     d7a:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     d7c:	9e 89       	ldd	r25, Y+22	; 0x16
     d7e:	80 91 da 01 	lds	r24, 0x01DA
     d82:	89 17       	cp	r24, r25
     d84:	10 f4       	brcc	.+4      	; 0xd8a <vCoRoutineSchedule+0x126>
     d86:	90 93 da 01 	sts	0x01DA, r25
     d8a:	9f 9d       	mul	r25, r15
     d8c:	c0 01       	movw	r24, r0
     d8e:	11 24       	eor	r1, r1
     d90:	8f 51       	subi	r24, 0x1F	; 31
     d92:	9e 4f       	sbci	r25, 0xFE	; 254
     d94:	b8 01       	movw	r22, r16
     d96:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     d9a:	e0 91 05 02 	lds	r30, 0x0205
     d9e:	f0 91 06 02 	lds	r31, 0x0206
     da2:	80 81       	ld	r24, Z
     da4:	88 23       	and	r24, r24
     da6:	09 f0       	breq	.+2      	; 0xdaa <vCoRoutineSchedule+0x146>
     da8:	5c c0       	rjmp	.+184    	; 0xe62 <vCoRoutineSchedule+0x1fe>
     daa:	20 91 df 01 	lds	r18, 0x01DF
     dae:	30 91 e0 01 	lds	r19, 0x01E0
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     db2:	80 91 dd 01 	lds	r24, 0x01DD
     db6:	90 91 de 01 	lds	r25, 0x01DE
     dba:	00 97       	sbiw	r24, 0x00	; 0
     dbc:	09 f0       	breq	.+2      	; 0xdc0 <vCoRoutineSchedule+0x15c>
     dbe:	a3 cf       	rjmp	.-186    	; 0xd06 <vCoRoutineSchedule+0xa2>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     dc0:	30 93 dc 01 	sts	0x01DC, r19
     dc4:	20 93 db 01 	sts	0x01DB, r18

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     dc8:	20 91 da 01 	lds	r18, 0x01DA
     dcc:	89 e0       	ldi	r24, 0x09	; 9
     dce:	28 9f       	mul	r18, r24
     dd0:	f0 01       	movw	r30, r0
     dd2:	11 24       	eor	r1, r1
     dd4:	ef 51       	subi	r30, 0x1F	; 31
     dd6:	fe 4f       	sbci	r31, 0xFE	; 254
     dd8:	80 81       	ld	r24, Z
     dda:	88 23       	and	r24, r24
     ddc:	89 f4       	brne	.+34     	; 0xe00 <vCoRoutineSchedule+0x19c>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     dde:	22 23       	and	r18, r18
     de0:	51 f1       	breq	.+84     	; 0xe36 <vCoRoutineSchedule+0x1d2>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     de2:	99 e0       	ldi	r25, 0x09	; 9
     de4:	02 c0       	rjmp	.+4      	; 0xdea <vCoRoutineSchedule+0x186>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     de6:	22 23       	and	r18, r18
     de8:	61 f1       	breq	.+88     	; 0xe42 <vCoRoutineSchedule+0x1de>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     dea:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     dec:	29 9f       	mul	r18, r25
     dee:	f0 01       	movw	r30, r0
     df0:	11 24       	eor	r1, r1
     df2:	ef 51       	subi	r30, 0x1F	; 31
     df4:	fe 4f       	sbci	r31, 0xFE	; 254
     df6:	80 81       	ld	r24, Z
     df8:	88 23       	and	r24, r24
     dfa:	a9 f3       	breq	.-22     	; 0xde6 <vCoRoutineSchedule+0x182>
     dfc:	20 93 da 01 	sts	0x01DA, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     e00:	a1 81       	ldd	r26, Z+1	; 0x01
     e02:	b2 81       	ldd	r27, Z+2	; 0x02
     e04:	12 96       	adiw	r26, 0x02	; 2
     e06:	0d 90       	ld	r0, X+
     e08:	bc 91       	ld	r27, X
     e0a:	a0 2d       	mov	r26, r0
     e0c:	b2 83       	std	Z+2, r27	; 0x02
     e0e:	a1 83       	std	Z+1, r26	; 0x01
     e10:	cf 01       	movw	r24, r30
     e12:	03 96       	adiw	r24, 0x03	; 3
     e14:	a8 17       	cp	r26, r24
     e16:	b9 07       	cpc	r27, r25
     e18:	e1 f0       	breq	.+56     	; 0xe52 <vCoRoutineSchedule+0x1ee>
     e1a:	16 96       	adiw	r26, 0x06	; 6
     e1c:	ed 91       	ld	r30, X+
     e1e:	fc 91       	ld	r31, X
     e20:	17 97       	sbiw	r26, 0x07	; 7
     e22:	f0 93 d9 01 	sts	0x01D9, r31
     e26:	e0 93 d8 01 	sts	0x01D8, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     e2a:	20 81       	ld	r18, Z
     e2c:	31 81       	ldd	r19, Z+1	; 0x01
     e2e:	cf 01       	movw	r24, r30
     e30:	67 89       	ldd	r22, Z+23	; 0x17
     e32:	f9 01       	movw	r30, r18
     e34:	09 95       	icall

	return;
}
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	1f 91       	pop	r17
     e3c:	0f 91       	pop	r16
     e3e:	ff 90       	pop	r15
     e40:	08 95       	ret
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     e42:	10 92 da 01 	sts	0x01DA, r1

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
     e46:	df 91       	pop	r29
     e48:	cf 91       	pop	r28
     e4a:	1f 91       	pop	r17
     e4c:	0f 91       	pop	r16
     e4e:	ff 90       	pop	r15
     e50:	08 95       	ret
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     e52:	12 96       	adiw	r26, 0x02	; 2
     e54:	8d 91       	ld	r24, X+
     e56:	9c 91       	ld	r25, X
     e58:	13 97       	sbiw	r26, 0x03	; 3
     e5a:	92 83       	std	Z+2, r25	; 0x02
     e5c:	81 83       	std	Z+1, r24	; 0x01
     e5e:	dc 01       	movw	r26, r24
     e60:	dc cf       	rjmp	.-72     	; 0xe1a <vCoRoutineSchedule+0x1b6>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     e62:	05 80       	ldd	r0, Z+5	; 0x05
     e64:	f6 81       	ldd	r31, Z+6	; 0x06
     e66:	e0 2d       	mov	r30, r0
     e68:	c6 81       	ldd	r28, Z+6	; 0x06
     e6a:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     e6c:	8a 81       	ldd	r24, Y+2	; 0x02
     e6e:	9b 81       	ldd	r25, Y+3	; 0x03
     e70:	20 91 df 01 	lds	r18, 0x01DF
     e74:	30 91 e0 01 	lds	r19, 0x01E0
     e78:	28 17       	cp	r18, r24
     e7a:	39 07       	cpc	r19, r25
     e7c:	08 f4       	brcc	.+2      	; 0xe80 <vCoRoutineSchedule+0x21c>
     e7e:	3c cf       	rjmp	.-392    	; 0xcf8 <vCoRoutineSchedule+0x94>
     e80:	6d cf       	rjmp	.-294    	; 0xd5c <vCoRoutineSchedule+0xf8>

00000e82 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     e82:	0f 93       	push	r16
     e84:	1f 93       	push	r17
     e86:	cf 93       	push	r28
     e88:	df 93       	push	r29
     e8a:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     e8c:	00 91 df 01 	lds	r16, 0x01DF
     e90:	10 91 e0 01 	lds	r17, 0x01E0
     e94:	08 0f       	add	r16, r24
     e96:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     e98:	80 91 d8 01 	lds	r24, 0x01D8
     e9c:	90 91 d9 01 	lds	r25, 0x01D9
     ea0:	02 96       	adiw	r24, 0x02	; 2
     ea2:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     ea6:	e0 91 d8 01 	lds	r30, 0x01D8
     eaa:	f0 91 d9 01 	lds	r31, 0x01D9
     eae:	13 83       	std	Z+3, r17	; 0x03
     eb0:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     eb2:	80 91 df 01 	lds	r24, 0x01DF
     eb6:	90 91 e0 01 	lds	r25, 0x01E0
     eba:	08 17       	cp	r16, r24
     ebc:	19 07       	cpc	r17, r25
     ebe:	c0 f4       	brcc	.+48     	; 0xef0 <vCoRoutineAddToDelayedList+0x6e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ec0:	32 96       	adiw	r30, 0x02	; 2
     ec2:	80 91 07 02 	lds	r24, 0x0207
     ec6:	90 91 08 02 	lds	r25, 0x0208
     eca:	bf 01       	movw	r22, r30
     ecc:	0e 94 a7 11 	call	0x234e	; 0x234e <vListInsert>
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
	}

	if( pxEventList )
     ed0:	20 97       	sbiw	r28, 0x00	; 0
     ed2:	49 f0       	breq	.+18     	; 0xee6 <vCoRoutineAddToDelayedList+0x64>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     ed4:	60 91 d8 01 	lds	r22, 0x01D8
     ed8:	70 91 d9 01 	lds	r23, 0x01D9
     edc:	64 5f       	subi	r22, 0xF4	; 244
     ede:	7f 4f       	sbci	r23, 0xFF	; 255
     ee0:	ce 01       	movw	r24, r28
     ee2:	0e 94 a7 11 	call	0x234e	; 0x234e <vListInsert>
	}
}
     ee6:	df 91       	pop	r29
     ee8:	cf 91       	pop	r28
     eea:	1f 91       	pop	r17
     eec:	0f 91       	pop	r16
     eee:	08 95       	ret
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ef0:	32 96       	adiw	r30, 0x02	; 2
     ef2:	80 91 05 02 	lds	r24, 0x0205
     ef6:	90 91 06 02 	lds	r25, 0x0206
     efa:	bf 01       	movw	r22, r30
     efc:	0e 94 a7 11 	call	0x234e	; 0x234e <vListInsert>
     f00:	e7 cf       	rjmp	.-50     	; 0xed0 <vCoRoutineAddToDelayedList+0x4e>

00000f02 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     f02:	af 92       	push	r10
     f04:	bf 92       	push	r11
     f06:	cf 92       	push	r12
     f08:	df 92       	push	r13
     f0a:	ef 92       	push	r14
     f0c:	ff 92       	push	r15
     f0e:	0f 93       	push	r16
     f10:	1f 93       	push	r17
     f12:	cf 93       	push	r28
     f14:	df 93       	push	r29
     f16:	6c 01       	movw	r12, r24
     f18:	b6 2e       	mov	r11, r22
     f1a:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     f1c:	8a e1       	ldi	r24, 0x1A	; 26
     f1e:	90 e0       	ldi	r25, 0x00	; 0
     f20:	0e 94 0f 08 	call	0x101e	; 0x101e <pvPortMalloc>
     f24:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     f26:	00 97       	sbiw	r24, 0x00	; 0
     f28:	09 f4       	brne	.+2      	; 0xf2c <xCoRoutineCreate+0x2a>
     f2a:	42 c0       	rjmp	.+132    	; 0xfb0 <xCoRoutineCreate+0xae>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     f2c:	80 91 d8 01 	lds	r24, 0x01D8
     f30:	90 91 d9 01 	lds	r25, 0x01D9
     f34:	89 2b       	or	r24, r25
     f36:	f1 f1       	breq	.+124    	; 0xfb4 <xCoRoutineCreate+0xb2>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     f38:	eb 2c       	mov	r14, r11
     f3a:	bb 20       	and	r11, r11
     f3c:	99 f5       	brne	.+102    	; 0xfa4 <xCoRoutineCreate+0xa2>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     f3e:	19 8e       	std	Y+25, r1	; 0x19
     f40:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     f42:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     f44:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     f46:	fe 01       	movw	r30, r28
     f48:	c1 92       	st	Z+, r12
     f4a:	d1 92       	st	Z+, r13
     f4c:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     f4e:	cf 01       	movw	r24, r30
     f50:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     f54:	ce 01       	movw	r24, r28
     f56:	0c 96       	adiw	r24, 0x0c	; 12
     f58:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     f5c:	d9 87       	std	Y+9, r29	; 0x09
     f5e:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     f60:	db 8b       	std	Y+19, r29	; 0x13
     f62:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     f64:	85 e0       	ldi	r24, 0x05	; 5
     f66:	90 e0       	ldi	r25, 0x00	; 0
     f68:	8e 19       	sub	r24, r14
     f6a:	91 09       	sbc	r25, r1
     f6c:	9d 87       	std	Y+13, r25	; 0x0d
     f6e:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     f70:	9e 89       	ldd	r25, Y+22	; 0x16
     f72:	80 91 da 01 	lds	r24, 0x01DA
     f76:	89 17       	cp	r24, r25
     f78:	c0 f0       	brcs	.+48     	; 0xfaa <xCoRoutineCreate+0xa8>
     f7a:	89 e0       	ldi	r24, 0x09	; 9
     f7c:	98 9f       	mul	r25, r24
     f7e:	c0 01       	movw	r24, r0
     f80:	11 24       	eor	r1, r1
     f82:	8f 51       	subi	r24, 0x1F	; 31
     f84:	9e 4f       	sbci	r25, 0xFE	; 254
     f86:	b8 01       	movw	r22, r16
     f88:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vListInsertEnd>
     f8c:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
     f8e:	df 91       	pop	r29
     f90:	cf 91       	pop	r28
     f92:	1f 91       	pop	r17
     f94:	0f 91       	pop	r16
     f96:	ff 90       	pop	r15
     f98:	ef 90       	pop	r14
     f9a:	df 90       	pop	r13
     f9c:	cf 90       	pop	r12
     f9e:	bf 90       	pop	r11
     fa0:	af 90       	pop	r10
     fa2:	08 95       	ret
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     fa4:	ee 24       	eor	r14, r14
     fa6:	e3 94       	inc	r14
     fa8:	ca cf       	rjmp	.-108    	; 0xf3e <xCoRoutineCreate+0x3c>
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     faa:	90 93 da 01 	sts	0x01DA, r25
     fae:	e5 cf       	rjmp	.-54     	; 0xf7a <xCoRoutineCreate+0x78>
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
	if( pxCoRoutine )
     fb0:	8f ef       	ldi	r24, 0xFF	; 255
     fb2:	ed cf       	rjmp	.-38     	; 0xf8e <xCoRoutineCreate+0x8c>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
		{
			pxCurrentCoRoutine = pxCoRoutine;
     fb4:	d0 93 d9 01 	sts	0x01D9, r29
     fb8:	c0 93 d8 01 	sts	0x01D8, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     fbc:	81 ee       	ldi	r24, 0xE1	; 225
     fbe:	91 e0       	ldi	r25, 0x01	; 1
     fc0:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>
     fc4:	8a ee       	ldi	r24, 0xEA	; 234
     fc6:	91 e0       	ldi	r25, 0x01	; 1
     fc8:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     fcc:	23 ef       	ldi	r18, 0xF3	; 243
     fce:	e2 2e       	mov	r14, r18
     fd0:	21 e0       	ldi	r18, 0x01	; 1
     fd2:	f2 2e       	mov	r15, r18
     fd4:	c7 01       	movw	r24, r14
     fd6:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     fda:	0c ef       	ldi	r16, 0xFC	; 252
     fdc:	11 e0       	ldi	r17, 0x01	; 1
     fde:	c8 01       	movw	r24, r16
     fe0:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     fe4:	89 e0       	ldi	r24, 0x09	; 9
     fe6:	92 e0       	ldi	r25, 0x02	; 2
     fe8:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     fec:	f0 92 06 02 	sts	0x0206, r15
     ff0:	e0 92 05 02 	sts	0x0205, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     ff4:	10 93 08 02 	sts	0x0208, r17
     ff8:	00 93 07 02 	sts	0x0207, r16
     ffc:	9d cf       	rjmp	.-198    	; 0xf38 <xCoRoutineCreate+0x36>

00000ffe <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     ffe:	08 95       	ret

00001000 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1000:	10 92 13 02 	sts	0x0213, r1
    1004:	10 92 12 02 	sts	0x0212, r1
}
    1008:	08 95       	ret

0000100a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    100a:	28 e5       	ldi	r18, 0x58	; 88
    100c:	32 e0       	ldi	r19, 0x02	; 2
    100e:	80 91 12 02 	lds	r24, 0x0212
    1012:	90 91 13 02 	lds	r25, 0x0213
    1016:	28 1b       	sub	r18, r24
    1018:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    101a:	c9 01       	movw	r24, r18
    101c:	08 95       	ret

0000101e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    101e:	0f 93       	push	r16
    1020:	1f 93       	push	r17
    1022:	cf 93       	push	r28
    1024:	df 93       	push	r29
    1026:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1028:	0e 94 85 0c 	call	0x190a	; 0x190a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    102c:	80 91 12 02 	lds	r24, 0x0212
    1030:	90 91 13 02 	lds	r25, 0x0213
    1034:	98 01       	movw	r18, r16
    1036:	28 0f       	add	r18, r24
    1038:	39 1f       	adc	r19, r25
    103a:	42 e0       	ldi	r20, 0x02	; 2
    103c:	28 35       	cpi	r18, 0x58	; 88
    103e:	34 07       	cpc	r19, r20
    1040:	50 f0       	brcs	.+20     	; 0x1056 <pvPortMalloc+0x38>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
    1042:	c0 e0       	ldi	r28, 0x00	; 0
    1044:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    1046:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    104a:	ce 01       	movw	r24, r28
    104c:	df 91       	pop	r29
    104e:	cf 91       	pop	r28
    1050:	1f 91       	pop	r17
    1052:	0f 91       	pop	r16
    1054:	08 95       	ret
	#endif

	vTaskSuspendAll();
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1056:	82 17       	cp	r24, r18
    1058:	93 07       	cpc	r25, r19
    105a:	98 f7       	brcc	.-26     	; 0x1042 <pvPortMalloc+0x24>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    105c:	ec 01       	movw	r28, r24
    105e:	cc 5e       	subi	r28, 0xEC	; 236
    1060:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    1062:	30 93 13 02 	sts	0x0213, r19
    1066:	20 93 12 02 	sts	0x0212, r18
    106a:	ed cf       	rjmp	.-38     	; 0x1046 <pvPortMalloc+0x28>

0000106c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    106c:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    106e:	91 e1       	ldi	r25, 0x11	; 17
    1070:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1072:	22 e2       	ldi	r18, 0x22	; 34
    1074:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1076:	83 e3       	ldi	r24, 0x33	; 51
    1078:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    107a:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    107c:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    107e:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1080:	80 e8       	ldi	r24, 0x80	; 128
    1082:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1084:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1086:	82 e0       	ldi	r24, 0x02	; 2
    1088:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    108a:	83 e0       	ldi	r24, 0x03	; 3
    108c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    108e:	84 e0       	ldi	r24, 0x04	; 4
    1090:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1092:	85 e0       	ldi	r24, 0x05	; 5
    1094:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1096:	86 e0       	ldi	r24, 0x06	; 6
    1098:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    109a:	87 e0       	ldi	r24, 0x07	; 7
    109c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    109e:	88 e0       	ldi	r24, 0x08	; 8
    10a0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    10a2:	89 e0       	ldi	r24, 0x09	; 9
    10a4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    10a6:	80 e1       	ldi	r24, 0x10	; 16
    10a8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    10aa:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    10ac:	82 e1       	ldi	r24, 0x12	; 18
    10ae:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    10b0:	83 e1       	ldi	r24, 0x13	; 19
    10b2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    10b4:	84 e1       	ldi	r24, 0x14	; 20
    10b6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    10b8:	85 e1       	ldi	r24, 0x15	; 21
    10ba:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    10bc:	86 e1       	ldi	r24, 0x16	; 22
    10be:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    10c0:	87 e1       	ldi	r24, 0x17	; 23
    10c2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    10c4:	88 e1       	ldi	r24, 0x18	; 24
    10c6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    10c8:	89 e1       	ldi	r24, 0x19	; 25
    10ca:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    10cc:	80 e2       	ldi	r24, 0x20	; 32
    10ce:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    10d0:	81 e2       	ldi	r24, 0x21	; 33
    10d2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    10d4:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    10d6:	83 e2       	ldi	r24, 0x23	; 35
    10d8:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    10da:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    10dc:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    10de:	86 e2       	ldi	r24, 0x26	; 38
    10e0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    10e2:	87 e2       	ldi	r24, 0x27	; 39
    10e4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    10e6:	88 e2       	ldi	r24, 0x28	; 40
    10e8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    10ea:	89 e2       	ldi	r24, 0x29	; 41
    10ec:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    10ee:	80 e3       	ldi	r24, 0x30	; 48
    10f0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    10f2:	81 e3       	ldi	r24, 0x31	; 49
    10f4:	82 93       	st	-Z, r24
    10f6:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    10f8:	cf 01       	movw	r24, r30
    10fa:	08 95       	ret

000010fc <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    10fc:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    10fe:	89 ef       	ldi	r24, 0xF9	; 249
    1100:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1102:	8b e0       	ldi	r24, 0x0B	; 11
    1104:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1106:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1108:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    110a:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    110c:	a0 91 6c 04 	lds	r26, 0x046C
    1110:	b0 91 6d 04 	lds	r27, 0x046D
    1114:	cd 91       	ld	r28, X+
    1116:	cd bf       	out	0x3d, r28	; 61
    1118:	dd 91       	ld	r29, X+
    111a:	de bf       	out	0x3e, r29	; 62
    111c:	ff 91       	pop	r31
    111e:	ef 91       	pop	r30
    1120:	df 91       	pop	r29
    1122:	cf 91       	pop	r28
    1124:	bf 91       	pop	r27
    1126:	af 91       	pop	r26
    1128:	9f 91       	pop	r25
    112a:	8f 91       	pop	r24
    112c:	7f 91       	pop	r23
    112e:	6f 91       	pop	r22
    1130:	5f 91       	pop	r21
    1132:	4f 91       	pop	r20
    1134:	3f 91       	pop	r19
    1136:	2f 91       	pop	r18
    1138:	1f 91       	pop	r17
    113a:	0f 91       	pop	r16
    113c:	ff 90       	pop	r15
    113e:	ef 90       	pop	r14
    1140:	df 90       	pop	r13
    1142:	cf 90       	pop	r12
    1144:	bf 90       	pop	r11
    1146:	af 90       	pop	r10
    1148:	9f 90       	pop	r9
    114a:	8f 90       	pop	r8
    114c:	7f 90       	pop	r7
    114e:	6f 90       	pop	r6
    1150:	5f 90       	pop	r5
    1152:	4f 90       	pop	r4
    1154:	3f 90       	pop	r3
    1156:	2f 90       	pop	r2
    1158:	1f 90       	pop	r1
    115a:	0f 90       	pop	r0
    115c:	0f be       	out	0x3f, r0	; 63
    115e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1160:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1162:	81 e0       	ldi	r24, 0x01	; 1
    1164:	08 95       	ret

00001166 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1166:	08 95       	ret

00001168 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1168:	0f 92       	push	r0
    116a:	0f b6       	in	r0, 0x3f	; 63
    116c:	f8 94       	cli
    116e:	0f 92       	push	r0
    1170:	1f 92       	push	r1
    1172:	11 24       	eor	r1, r1
    1174:	2f 92       	push	r2
    1176:	3f 92       	push	r3
    1178:	4f 92       	push	r4
    117a:	5f 92       	push	r5
    117c:	6f 92       	push	r6
    117e:	7f 92       	push	r7
    1180:	8f 92       	push	r8
    1182:	9f 92       	push	r9
    1184:	af 92       	push	r10
    1186:	bf 92       	push	r11
    1188:	cf 92       	push	r12
    118a:	df 92       	push	r13
    118c:	ef 92       	push	r14
    118e:	ff 92       	push	r15
    1190:	0f 93       	push	r16
    1192:	1f 93       	push	r17
    1194:	2f 93       	push	r18
    1196:	3f 93       	push	r19
    1198:	4f 93       	push	r20
    119a:	5f 93       	push	r21
    119c:	6f 93       	push	r22
    119e:	7f 93       	push	r23
    11a0:	8f 93       	push	r24
    11a2:	9f 93       	push	r25
    11a4:	af 93       	push	r26
    11a6:	bf 93       	push	r27
    11a8:	cf 93       	push	r28
    11aa:	df 93       	push	r29
    11ac:	ef 93       	push	r30
    11ae:	ff 93       	push	r31
    11b0:	a0 91 6c 04 	lds	r26, 0x046C
    11b4:	b0 91 6d 04 	lds	r27, 0x046D
    11b8:	0d b6       	in	r0, 0x3d	; 61
    11ba:	0d 92       	st	X+, r0
    11bc:	0e b6       	in	r0, 0x3e	; 62
    11be:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    11c0:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <vTaskIncrementTick>
	vTaskSwitchContext();
    11c4:	0e 94 9f 0c 	call	0x193e	; 0x193e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    11c8:	a0 91 6c 04 	lds	r26, 0x046C
    11cc:	b0 91 6d 04 	lds	r27, 0x046D
    11d0:	cd 91       	ld	r28, X+
    11d2:	cd bf       	out	0x3d, r28	; 61
    11d4:	dd 91       	ld	r29, X+
    11d6:	de bf       	out	0x3e, r29	; 62
    11d8:	ff 91       	pop	r31
    11da:	ef 91       	pop	r30
    11dc:	df 91       	pop	r29
    11de:	cf 91       	pop	r28
    11e0:	bf 91       	pop	r27
    11e2:	af 91       	pop	r26
    11e4:	9f 91       	pop	r25
    11e6:	8f 91       	pop	r24
    11e8:	7f 91       	pop	r23
    11ea:	6f 91       	pop	r22
    11ec:	5f 91       	pop	r21
    11ee:	4f 91       	pop	r20
    11f0:	3f 91       	pop	r19
    11f2:	2f 91       	pop	r18
    11f4:	1f 91       	pop	r17
    11f6:	0f 91       	pop	r16
    11f8:	ff 90       	pop	r15
    11fa:	ef 90       	pop	r14
    11fc:	df 90       	pop	r13
    11fe:	cf 90       	pop	r12
    1200:	bf 90       	pop	r11
    1202:	af 90       	pop	r10
    1204:	9f 90       	pop	r9
    1206:	8f 90       	pop	r8
    1208:	7f 90       	pop	r7
    120a:	6f 90       	pop	r6
    120c:	5f 90       	pop	r5
    120e:	4f 90       	pop	r4
    1210:	3f 90       	pop	r3
    1212:	2f 90       	pop	r2
    1214:	1f 90       	pop	r1
    1216:	0f 90       	pop	r0
    1218:	0f be       	out	0x3f, r0	; 63
    121a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    121c:	08 95       	ret

0000121e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    121e:	0e 94 b4 08 	call	0x1168	; 0x1168 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1222:	18 95       	reti

00001224 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1224:	0f 92       	push	r0
    1226:	0f b6       	in	r0, 0x3f	; 63
    1228:	f8 94       	cli
    122a:	0f 92       	push	r0
    122c:	1f 92       	push	r1
    122e:	11 24       	eor	r1, r1
    1230:	2f 92       	push	r2
    1232:	3f 92       	push	r3
    1234:	4f 92       	push	r4
    1236:	5f 92       	push	r5
    1238:	6f 92       	push	r6
    123a:	7f 92       	push	r7
    123c:	8f 92       	push	r8
    123e:	9f 92       	push	r9
    1240:	af 92       	push	r10
    1242:	bf 92       	push	r11
    1244:	cf 92       	push	r12
    1246:	df 92       	push	r13
    1248:	ef 92       	push	r14
    124a:	ff 92       	push	r15
    124c:	0f 93       	push	r16
    124e:	1f 93       	push	r17
    1250:	2f 93       	push	r18
    1252:	3f 93       	push	r19
    1254:	4f 93       	push	r20
    1256:	5f 93       	push	r21
    1258:	6f 93       	push	r22
    125a:	7f 93       	push	r23
    125c:	8f 93       	push	r24
    125e:	9f 93       	push	r25
    1260:	af 93       	push	r26
    1262:	bf 93       	push	r27
    1264:	cf 93       	push	r28
    1266:	df 93       	push	r29
    1268:	ef 93       	push	r30
    126a:	ff 93       	push	r31
    126c:	a0 91 6c 04 	lds	r26, 0x046C
    1270:	b0 91 6d 04 	lds	r27, 0x046D
    1274:	0d b6       	in	r0, 0x3d	; 61
    1276:	0d 92       	st	X+, r0
    1278:	0e b6       	in	r0, 0x3e	; 62
    127a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    127c:	0e 94 9f 0c 	call	0x193e	; 0x193e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1280:	a0 91 6c 04 	lds	r26, 0x046C
    1284:	b0 91 6d 04 	lds	r27, 0x046D
    1288:	cd 91       	ld	r28, X+
    128a:	cd bf       	out	0x3d, r28	; 61
    128c:	dd 91       	ld	r29, X+
    128e:	de bf       	out	0x3e, r29	; 62
    1290:	ff 91       	pop	r31
    1292:	ef 91       	pop	r30
    1294:	df 91       	pop	r29
    1296:	cf 91       	pop	r28
    1298:	bf 91       	pop	r27
    129a:	af 91       	pop	r26
    129c:	9f 91       	pop	r25
    129e:	8f 91       	pop	r24
    12a0:	7f 91       	pop	r23
    12a2:	6f 91       	pop	r22
    12a4:	5f 91       	pop	r21
    12a6:	4f 91       	pop	r20
    12a8:	3f 91       	pop	r19
    12aa:	2f 91       	pop	r18
    12ac:	1f 91       	pop	r17
    12ae:	0f 91       	pop	r16
    12b0:	ff 90       	pop	r15
    12b2:	ef 90       	pop	r14
    12b4:	df 90       	pop	r13
    12b6:	cf 90       	pop	r12
    12b8:	bf 90       	pop	r11
    12ba:	af 90       	pop	r10
    12bc:	9f 90       	pop	r9
    12be:	8f 90       	pop	r8
    12c0:	7f 90       	pop	r7
    12c2:	6f 90       	pop	r6
    12c4:	5f 90       	pop	r5
    12c6:	4f 90       	pop	r4
    12c8:	3f 90       	pop	r3
    12ca:	2f 90       	pop	r2
    12cc:	1f 90       	pop	r1
    12ce:	0f 90       	pop	r0
    12d0:	0f be       	out	0x3f, r0	; 63
    12d2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12d4:	08 95       	ret

000012d6 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    12d6:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    12d8:	0f b6       	in	r0, 0x3f	; 63
    12da:	f8 94       	cli
    12dc:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    12de:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    12e0:	0f 90       	pop	r0
    12e2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    12e4:	08 95       	ret

000012e6 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    12e6:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    12e8:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    12ea:	08 95       	ret

000012ec <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    12ec:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    12ee:	82 8d       	ldd	r24, Z+26	; 0x1a
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	88 23       	and	r24, r24
    12f4:	09 f4       	brne	.+2      	; 0x12f8 <xQueueIsQueueEmptyFromISR+0xc>
    12f6:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    12f8:	89 2f       	mov	r24, r25
    12fa:	08 95       	ret

000012fc <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    12fc:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    12fe:	92 8d       	ldd	r25, Z+26	; 0x1a
    1300:	20 e0       	ldi	r18, 0x00	; 0
    1302:	83 8d       	ldd	r24, Z+27	; 0x1b
    1304:	98 17       	cp	r25, r24
    1306:	11 f0       	breq	.+4      	; 0x130c <xQueueIsQueueFullFromISR+0x10>

	return xReturn;
}
    1308:	82 2f       	mov	r24, r18
    130a:	08 95       	ret
signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    130c:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    130e:	82 2f       	mov	r24, r18
    1310:	08 95       	ret

00001312 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1312:	0f 93       	push	r16
    1314:	1f 93       	push	r17
    1316:	8c 01       	movw	r16, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1318:	fc 01       	movw	r30, r24
    131a:	80 81       	ld	r24, Z
    131c:	91 81       	ldd	r25, Z+1	; 0x01
    131e:	0e 94 ff 07 	call	0xffe	; 0xffe <vPortFree>
	vPortFree( pxQueue );
    1322:	c8 01       	movw	r24, r16
    1324:	0e 94 ff 07 	call	0xffe	; 0xffe <vPortFree>
}
    1328:	1f 91       	pop	r17
    132a:	0f 91       	pop	r16
    132c:	08 95       	ret

0000132e <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    132e:	0f 93       	push	r16
    1330:	1f 93       	push	r17
    1332:	cf 93       	push	r28
    1334:	df 93       	push	r29
    1336:	ec 01       	movw	r28, r24
    1338:	fb 01       	movw	r30, r22
    133a:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    133c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    133e:	88 23       	and	r24, r24
    1340:	11 f1       	breq	.+68     	; 0x1386 <xQueueReceiveFromISR+0x58>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1342:	68 81       	ld	r22, Y
    1344:	79 81       	ldd	r23, Y+1	; 0x01
    1346:	61 15       	cp	r22, r1
    1348:	71 05       	cpc	r23, r1
    134a:	a1 f0       	breq	.+40     	; 0x1374 <xQueueReceiveFromISR+0x46>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    134c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    134e:	8e 81       	ldd	r24, Y+6	; 0x06
    1350:	9f 81       	ldd	r25, Y+7	; 0x07
    1352:	84 0f       	add	r24, r20
    1354:	91 1d       	adc	r25, r1
    1356:	9f 83       	std	Y+7, r25	; 0x07
    1358:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    135a:	2a 81       	ldd	r18, Y+2	; 0x02
    135c:	3b 81       	ldd	r19, Y+3	; 0x03
    135e:	82 17       	cp	r24, r18
    1360:	93 07       	cpc	r25, r19
    1362:	10 f0       	brcs	.+4      	; 0x1368 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1364:	7f 83       	std	Y+7, r23	; 0x07
    1366:	6e 83       	std	Y+6, r22	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1368:	6e 81       	ldd	r22, Y+6	; 0x06
    136a:	7f 81       	ldd	r23, Y+7	; 0x07
    136c:	cf 01       	movw	r24, r30
    136e:	50 e0       	ldi	r21, 0x00	; 0
    1370:	0e 94 74 19 	call	0x32e8	; 0x32e8 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    1374:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1376:	81 50       	subi	r24, 0x01	; 1
    1378:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    137a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    137c:	8f 3f       	cpi	r24, 0xFF	; 255
    137e:	41 f0       	breq	.+16     	; 0x1390 <xQueueReceiveFromISR+0x62>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1380:	8f 5f       	subi	r24, 0xFF	; 255
    1382:	8d 8f       	std	Y+29, r24	; 0x1d
    1384:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1386:	df 91       	pop	r29
    1388:	cf 91       	pop	r28
    138a:	1f 91       	pop	r17
    138c:	0f 91       	pop	r16
    138e:	08 95       	ret
			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1390:	88 85       	ldd	r24, Y+8	; 0x08
    1392:	88 23       	and	r24, r24
    1394:	31 f4       	brne	.+12     	; 0x13a2 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1396:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1398:	df 91       	pop	r29
    139a:	cf 91       	pop	r28
    139c:	1f 91       	pop	r17
    139e:	0f 91       	pop	r16
    13a0:	08 95       	ret
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13a2:	ce 01       	movw	r24, r28
    13a4:	08 96       	adiw	r24, 0x08	; 8
    13a6:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xTaskRemoveFromEventList>
    13aa:	88 23       	and	r24, r24
    13ac:	a1 f3       	breq	.-24     	; 0x1396 <xQueueReceiveFromISR+0x68>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	f8 01       	movw	r30, r16
    13b2:	80 83       	st	Z, r24
    13b4:	e8 cf       	rjmp	.-48     	; 0x1386 <xQueueReceiveFromISR+0x58>

000013b6 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    13b6:	cf 93       	push	r28
    13b8:	df 93       	push	r29
    13ba:	ec 01       	movw	r28, r24
    13bc:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    13be:	4c 8d       	ldd	r20, Y+28	; 0x1c
    13c0:	44 23       	and	r20, r20
    13c2:	b9 f0       	breq	.+46     	; 0x13f2 <prvCopyDataToQueue+0x3c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    13c4:	88 23       	and	r24, r24
    13c6:	d9 f4       	brne	.+54     	; 0x13fe <prvCopyDataToQueue+0x48>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    13c8:	8c 81       	ldd	r24, Y+4	; 0x04
    13ca:	9d 81       	ldd	r25, Y+5	; 0x05
    13cc:	50 e0       	ldi	r21, 0x00	; 0
    13ce:	0e 94 74 19 	call	0x32e8	; 0x32e8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    13d2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    13d4:	2c 81       	ldd	r18, Y+4	; 0x04
    13d6:	3d 81       	ldd	r19, Y+5	; 0x05
    13d8:	28 0f       	add	r18, r24
    13da:	31 1d       	adc	r19, r1
    13dc:	3d 83       	std	Y+5, r19	; 0x05
    13de:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    13e0:	8a 81       	ldd	r24, Y+2	; 0x02
    13e2:	9b 81       	ldd	r25, Y+3	; 0x03
    13e4:	28 17       	cp	r18, r24
    13e6:	39 07       	cpc	r19, r25
    13e8:	20 f0       	brcs	.+8      	; 0x13f2 <prvCopyDataToQueue+0x3c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    13ea:	88 81       	ld	r24, Y
    13ec:	99 81       	ldd	r25, Y+1	; 0x01
    13ee:	9d 83       	std	Y+5, r25	; 0x05
    13f0:	8c 83       	std	Y+4, r24	; 0x04
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    13f2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    13f4:	8f 5f       	subi	r24, 0xFF	; 255
    13f6:	8a 8f       	std	Y+26, r24	; 0x1a
}
    13f8:	df 91       	pop	r29
    13fa:	cf 91       	pop	r28
    13fc:	08 95       	ret
			pxQueue->pcWriteTo = pxQueue->pcHead;
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    13fe:	8e 81       	ldd	r24, Y+6	; 0x06
    1400:	9f 81       	ldd	r25, Y+7	; 0x07
    1402:	50 e0       	ldi	r21, 0x00	; 0
    1404:	0e 94 74 19 	call	0x32e8	; 0x32e8 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1408:	8c 8d       	ldd	r24, Y+28	; 0x1c
    140a:	90 e0       	ldi	r25, 0x00	; 0
    140c:	44 27       	eor	r20, r20
    140e:	55 27       	eor	r21, r21
    1410:	48 1b       	sub	r20, r24
    1412:	59 0b       	sbc	r21, r25
    1414:	8e 81       	ldd	r24, Y+6	; 0x06
    1416:	9f 81       	ldd	r25, Y+7	; 0x07
    1418:	84 0f       	add	r24, r20
    141a:	95 1f       	adc	r25, r21
    141c:	9f 83       	std	Y+7, r25	; 0x07
    141e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1420:	28 81       	ld	r18, Y
    1422:	39 81       	ldd	r19, Y+1	; 0x01
    1424:	82 17       	cp	r24, r18
    1426:	93 07       	cpc	r25, r19
    1428:	20 f7       	brcc	.-56     	; 0x13f2 <prvCopyDataToQueue+0x3c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    142a:	8a 81       	ldd	r24, Y+2	; 0x02
    142c:	9b 81       	ldd	r25, Y+3	; 0x03
    142e:	84 0f       	add	r24, r20
    1430:	95 1f       	adc	r25, r21
    1432:	9f 83       	std	Y+7, r25	; 0x07
    1434:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1436:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1438:	8f 5f       	subi	r24, 0xFF	; 255
    143a:	8a 8f       	std	Y+26, r24	; 0x1a
}
    143c:	df 91       	pop	r29
    143e:	cf 91       	pop	r28
    1440:	08 95       	ret

00001442 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1442:	0f 93       	push	r16
    1444:	1f 93       	push	r17
    1446:	cf 93       	push	r28
    1448:	df 93       	push	r29
    144a:	ec 01       	movw	r28, r24
    144c:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    144e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1450:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1452:	98 17       	cp	r25, r24
    1454:	30 f0       	brcs	.+12     	; 0x1462 <xQueueGenericSendFromISR+0x20>
    1456:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	1f 91       	pop	r17
    145e:	0f 91       	pop	r16
    1460:	08 95       	ret
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1462:	ce 01       	movw	r24, r28
    1464:	42 2f       	mov	r20, r18
    1466:	0e 94 db 09 	call	0x13b6	; 0x13b6 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    146a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    146c:	8f 3f       	cpi	r24, 0xFF	; 255
    146e:	41 f0       	breq	.+16     	; 0x1480 <xQueueGenericSendFromISR+0x3e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1470:	8f 5f       	subi	r24, 0xFF	; 255
    1472:	8e 8f       	std	Y+30, r24	; 0x1e
    1474:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1476:	df 91       	pop	r29
    1478:	cf 91       	pop	r28
    147a:	1f 91       	pop	r17
    147c:	0f 91       	pop	r16
    147e:	08 95       	ret

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1480:	89 89       	ldd	r24, Y+17	; 0x11
    1482:	88 23       	and	r24, r24
    1484:	11 f4       	brne	.+4      	; 0x148a <xQueueGenericSendFromISR+0x48>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1486:	81 e0       	ldi	r24, 0x01	; 1
    1488:	e7 cf       	rjmp	.-50     	; 0x1458 <xQueueGenericSendFromISR+0x16>
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    148a:	ce 01       	movw	r24, r28
    148c:	41 96       	adiw	r24, 0x11	; 17
    148e:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xTaskRemoveFromEventList>
    1492:	88 23       	and	r24, r24
    1494:	c1 f3       	breq	.-16     	; 0x1486 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1496:	81 e0       	ldi	r24, 0x01	; 1
    1498:	f8 01       	movw	r30, r16
    149a:	80 83       	st	Z, r24
    149c:	dd cf       	rjmp	.-70     	; 0x1458 <xQueueGenericSendFromISR+0x16>

0000149e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    149e:	0f 93       	push	r16
    14a0:	1f 93       	push	r17
    14a2:	cf 93       	push	r28
    14a4:	df 93       	push	r29
    14a6:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    14a8:	0f b6       	in	r0, 0x3f	; 63
    14aa:	f8 94       	cli
    14ac:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    14ae:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14b0:	18 16       	cp	r1, r24
    14b2:	dc f4       	brge	.+54     	; 0x14ea <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14b4:	89 89       	ldd	r24, Y+17	; 0x11
    14b6:	88 23       	and	r24, r24
    14b8:	c1 f0       	breq	.+48     	; 0x14ea <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14ba:	8e 01       	movw	r16, r28
    14bc:	0f 5e       	subi	r16, 0xEF	; 239
    14be:	1f 4f       	sbci	r17, 0xFF	; 255
    14c0:	08 c0       	rjmp	.+16     	; 0x14d2 <prvUnlockQueue+0x34>
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
    14c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14c4:	81 50       	subi	r24, 0x01	; 1
    14c6:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    14c8:	18 16       	cp	r1, r24
    14ca:	7c f4       	brge	.+30     	; 0x14ea <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14cc:	89 89       	ldd	r24, Y+17	; 0x11
    14ce:	88 23       	and	r24, r24
    14d0:	61 f0       	breq	.+24     	; 0x14ea <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14d2:	c8 01       	movw	r24, r16
    14d4:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xTaskRemoveFromEventList>
    14d8:	88 23       	and	r24, r24
    14da:	99 f3       	breq	.-26     	; 0x14c2 <prvUnlockQueue+0x24>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    14dc:	0e 94 31 0d 	call	0x1a62	; 0x1a62 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    14e0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14e2:	81 50       	subi	r24, 0x01	; 1
    14e4:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    14e6:	18 16       	cp	r1, r24
    14e8:	8c f3       	brlt	.-30     	; 0x14cc <prvUnlockQueue+0x2e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    14ea:	8f ef       	ldi	r24, 0xFF	; 255
    14ec:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    14ee:	0f 90       	pop	r0
    14f0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    14f2:	0f b6       	in	r0, 0x3f	; 63
    14f4:	f8 94       	cli
    14f6:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    14f8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    14fa:	18 16       	cp	r1, r24
    14fc:	dc f4       	brge	.+54     	; 0x1534 <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14fe:	88 85       	ldd	r24, Y+8	; 0x08
    1500:	88 23       	and	r24, r24
    1502:	c1 f0       	breq	.+48     	; 0x1534 <prvUnlockQueue+0x96>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1504:	8e 01       	movw	r16, r28
    1506:	08 5f       	subi	r16, 0xF8	; 248
    1508:	1f 4f       	sbci	r17, 0xFF	; 255
    150a:	08 c0       	rjmp	.+16     	; 0x151c <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
    150c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    150e:	81 50       	subi	r24, 0x01	; 1
    1510:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1512:	18 16       	cp	r1, r24
    1514:	7c f4       	brge	.+30     	; 0x1534 <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1516:	88 85       	ldd	r24, Y+8	; 0x08
    1518:	88 23       	and	r24, r24
    151a:	61 f0       	breq	.+24     	; 0x1534 <prvUnlockQueue+0x96>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    151c:	c8 01       	movw	r24, r16
    151e:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xTaskRemoveFromEventList>
    1522:	88 23       	and	r24, r24
    1524:	99 f3       	breq	.-26     	; 0x150c <prvUnlockQueue+0x6e>
				{
					vTaskMissedYield();
    1526:	0e 94 31 0d 	call	0x1a62	; 0x1a62 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    152a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    152c:	81 50       	subi	r24, 0x01	; 1
    152e:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1530:	18 16       	cp	r1, r24
    1532:	8c f3       	brlt	.-30     	; 0x1516 <prvUnlockQueue+0x78>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1534:	8f ef       	ldi	r24, 0xFF	; 255
    1536:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1538:	0f 90       	pop	r0
    153a:	0f be       	out	0x3f, r0	; 63
}
    153c:	df 91       	pop	r29
    153e:	cf 91       	pop	r28
    1540:	1f 91       	pop	r17
    1542:	0f 91       	pop	r16
    1544:	08 95       	ret

00001546 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1546:	7f 92       	push	r7
    1548:	8f 92       	push	r8
    154a:	9f 92       	push	r9
    154c:	af 92       	push	r10
    154e:	bf 92       	push	r11
    1550:	cf 92       	push	r12
    1552:	df 92       	push	r13
    1554:	ef 92       	push	r14
    1556:	ff 92       	push	r15
    1558:	0f 93       	push	r16
    155a:	1f 93       	push	r17
    155c:	df 93       	push	r29
    155e:	cf 93       	push	r28
    1560:	00 d0       	rcall	.+0      	; 0x1562 <xQueueGenericReceive+0x1c>
    1562:	00 d0       	rcall	.+0      	; 0x1564 <xQueueGenericReceive+0x1e>
    1564:	0f 92       	push	r0
    1566:	cd b7       	in	r28, 0x3d	; 61
    1568:	de b7       	in	r29, 0x3e	; 62
    156a:	8c 01       	movw	r16, r24
    156c:	86 2e       	mov	r8, r22
    156e:	77 2e       	mov	r7, r23
    1570:	5d 83       	std	Y+5, r21	; 0x05
    1572:	4c 83       	std	Y+4, r20	; 0x04
    1574:	92 2e       	mov	r9, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1576:	91 e1       	ldi	r25, 0x11	; 17
    1578:	a9 2e       	mov	r10, r25
    157a:	b1 2c       	mov	r11, r1
    157c:	a0 0e       	add	r10, r16
    157e:	b1 1e       	adc	r11, r17
    1580:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1582:	7e 01       	movw	r14, r28
    1584:	08 94       	sec
    1586:	e1 1c       	adc	r14, r1
    1588:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    158a:	84 e0       	ldi	r24, 0x04	; 4
    158c:	c8 2e       	mov	r12, r24
    158e:	d1 2c       	mov	r13, r1
    1590:	cc 0e       	add	r12, r28
    1592:	dd 1e       	adc	r13, r29
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1594:	0f b6       	in	r0, 0x3f	; 63
    1596:	f8 94       	cli
    1598:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    159a:	f8 01       	movw	r30, r16
    159c:	82 8d       	ldd	r24, Z+26	; 0x1a
    159e:	88 23       	and	r24, r24
    15a0:	09 f0       	breq	.+2      	; 0x15a4 <xQueueGenericReceive+0x5e>
    15a2:	4a c0       	rjmp	.+148    	; 0x1638 <xQueueGenericReceive+0xf2>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    15a4:	8c 81       	ldd	r24, Y+4	; 0x04
    15a6:	9d 81       	ldd	r25, Y+5	; 0x05
    15a8:	89 2b       	or	r24, r25
    15aa:	09 f4       	brne	.+2      	; 0x15ae <xQueueGenericReceive+0x68>
    15ac:	72 c0       	rjmp	.+228    	; 0x1692 <xQueueGenericReceive+0x14c>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    15ae:	22 23       	and	r18, r18
    15b0:	09 f4       	brne	.+2      	; 0x15b4 <xQueueGenericReceive+0x6e>
    15b2:	3e c0       	rjmp	.+124    	; 0x1630 <xQueueGenericReceive+0xea>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    15b4:	0f 90       	pop	r0
    15b6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15b8:	0e 94 85 0c 	call	0x190a	; 0x190a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15bc:	0f b6       	in	r0, 0x3f	; 63
    15be:	f8 94       	cli
    15c0:	0f 92       	push	r0
    15c2:	f8 01       	movw	r30, r16
    15c4:	85 8d       	ldd	r24, Z+29	; 0x1d
    15c6:	8f 3f       	cpi	r24, 0xFF	; 255
    15c8:	89 f1       	breq	.+98     	; 0x162c <xQueueGenericReceive+0xe6>
    15ca:	f8 01       	movw	r30, r16
    15cc:	86 8d       	ldd	r24, Z+30	; 0x1e
    15ce:	8f 3f       	cpi	r24, 0xFF	; 255
    15d0:	59 f1       	breq	.+86     	; 0x1628 <xQueueGenericReceive+0xe2>
    15d2:	0f 90       	pop	r0
    15d4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15d6:	c7 01       	movw	r24, r14
    15d8:	b6 01       	movw	r22, r12
    15da:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <xTaskCheckForTimeOut>
    15de:	88 23       	and	r24, r24
    15e0:	09 f0       	breq	.+2      	; 0x15e4 <xQueueGenericReceive+0x9e>
    15e2:	6d c0       	rjmp	.+218    	; 0x16be <xQueueGenericReceive+0x178>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    15e4:	0f b6       	in	r0, 0x3f	; 63
    15e6:	f8 94       	cli
    15e8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    15ea:	f8 01       	movw	r30, r16
    15ec:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    15ee:	0f 90       	pop	r0
    15f0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    15f2:	88 23       	and	r24, r24
    15f4:	91 f4       	brne	.+36     	; 0x161a <xQueueGenericReceive+0xd4>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15f6:	6c 81       	ldd	r22, Y+4	; 0x04
    15f8:	7d 81       	ldd	r23, Y+5	; 0x05
    15fa:	c5 01       	movw	r24, r10
    15fc:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1600:	c8 01       	movw	r24, r16
    1602:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1606:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskResumeAll>
    160a:	88 23       	and	r24, r24
    160c:	11 f0       	breq	.+4      	; 0x1612 <xQueueGenericReceive+0xcc>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    160e:	21 e0       	ldi	r18, 0x01	; 1
    1610:	c1 cf       	rjmp	.-126    	; 0x1594 <xQueueGenericReceive+0x4e>
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
    1612:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1616:	21 e0       	ldi	r18, 0x01	; 1
    1618:	bd cf       	rjmp	.-134    	; 0x1594 <xQueueGenericReceive+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    161a:	c8 01       	movw	r24, r16
    161c:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1620:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskResumeAll>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1624:	21 e0       	ldi	r18, 0x01	; 1
    1626:	b6 cf       	rjmp	.-148    	; 0x1594 <xQueueGenericReceive+0x4e>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    1628:	16 8e       	std	Z+30, r1	; 0x1e
    162a:	d3 cf       	rjmp	.-90     	; 0x15d2 <xQueueGenericReceive+0x8c>
    162c:	15 8e       	std	Z+29, r1	; 0x1d
    162e:	cd cf       	rjmp	.-102    	; 0x15ca <xQueueGenericReceive+0x84>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1630:	c7 01       	movw	r24, r14
    1632:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <vTaskSetTimeOutState>
    1636:	be cf       	rjmp	.-132    	; 0x15b4 <xQueueGenericReceive+0x6e>
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1638:	e6 80       	ldd	r14, Z+6	; 0x06
    163a:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    163c:	60 81       	ld	r22, Z
    163e:	71 81       	ldd	r23, Z+1	; 0x01
    1640:	61 15       	cp	r22, r1
    1642:	71 05       	cpc	r23, r1
    1644:	a1 f0       	breq	.+40     	; 0x166e <xQueueGenericReceive+0x128>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1646:	44 8d       	ldd	r20, Z+28	; 0x1c
    1648:	97 01       	movw	r18, r14
    164a:	24 0f       	add	r18, r20
    164c:	31 1d       	adc	r19, r1
    164e:	37 83       	std	Z+7, r19	; 0x07
    1650:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1652:	82 81       	ldd	r24, Z+2	; 0x02
    1654:	93 81       	ldd	r25, Z+3	; 0x03
    1656:	28 17       	cp	r18, r24
    1658:	39 07       	cpc	r19, r25
    165a:	08 f0       	brcs	.+2      	; 0x165e <xQueueGenericReceive+0x118>
    165c:	41 c0       	rjmp	.+130    	; 0x16e0 <xQueueGenericReceive+0x19a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    165e:	f8 01       	movw	r30, r16
    1660:	66 81       	ldd	r22, Z+6	; 0x06
    1662:	77 81       	ldd	r23, Z+7	; 0x07
    1664:	88 2d       	mov	r24, r8
    1666:	97 2d       	mov	r25, r7
    1668:	50 e0       	ldi	r21, 0x00	; 0
    166a:	0e 94 74 19 	call	0x32e8	; 0x32e8 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    166e:	99 20       	and	r9, r9
    1670:	69 f5       	brne	.+90     	; 0x16cc <xQueueGenericReceive+0x186>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1672:	f8 01       	movw	r30, r16
    1674:	82 8d       	ldd	r24, Z+26	; 0x1a
    1676:	81 50       	subi	r24, 0x01	; 1
    1678:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    167a:	80 85       	ldd	r24, Z+8	; 0x08
    167c:	88 23       	and	r24, r24
    167e:	61 f1       	breq	.+88     	; 0x16d8 <xQueueGenericReceive+0x192>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1680:	c8 01       	movw	r24, r16
    1682:	08 96       	adiw	r24, 0x08	; 8
    1684:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xTaskRemoveFromEventList>
    1688:	81 30       	cpi	r24, 0x01	; 1
    168a:	31 f5       	brne	.+76     	; 0x16d8 <xQueueGenericReceive+0x192>
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    168c:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    1690:	23 c0       	rjmp	.+70     	; 0x16d8 <xQueueGenericReceive+0x192>
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1692:	0f 90       	pop	r0
    1694:	0f be       	out	0x3f, r0	; 63
    1696:	80 e0       	ldi	r24, 0x00	; 0
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    1698:	0f 90       	pop	r0
    169a:	0f 90       	pop	r0
    169c:	0f 90       	pop	r0
    169e:	0f 90       	pop	r0
    16a0:	0f 90       	pop	r0
    16a2:	cf 91       	pop	r28
    16a4:	df 91       	pop	r29
    16a6:	1f 91       	pop	r17
    16a8:	0f 91       	pop	r16
    16aa:	ff 90       	pop	r15
    16ac:	ef 90       	pop	r14
    16ae:	df 90       	pop	r13
    16b0:	cf 90       	pop	r12
    16b2:	bf 90       	pop	r11
    16b4:	af 90       	pop	r10
    16b6:	9f 90       	pop	r9
    16b8:	8f 90       	pop	r8
    16ba:	7f 90       	pop	r7
    16bc:	08 95       	ret
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    16be:	c8 01       	movw	r24, r16
    16c0:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    16c4:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskResumeAll>
    16c8:	80 e0       	ldi	r24, 0x00	; 0
    16ca:	e6 cf       	rjmp	.-52     	; 0x1698 <xQueueGenericReceive+0x152>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    16cc:	f8 01       	movw	r30, r16
    16ce:	f7 82       	std	Z+7, r15	; 0x07
    16d0:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16d2:	81 89       	ldd	r24, Z+17	; 0x11
    16d4:	88 23       	and	r24, r24
    16d6:	39 f4       	brne	.+14     	; 0x16e6 <xQueueGenericReceive+0x1a0>
						}
					}

				}

				taskEXIT_CRITICAL();
    16d8:	0f 90       	pop	r0
    16da:	0f be       	out	0x3f, r0	; 63
    16dc:	81 e0       	ldi	r24, 0x01	; 1
    16de:	dc cf       	rjmp	.-72     	; 0x1698 <xQueueGenericReceive+0x152>
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    16e0:	77 83       	std	Z+7, r23	; 0x07
    16e2:	66 83       	std	Z+6, r22	; 0x06
    16e4:	bc cf       	rjmp	.-136    	; 0x165e <xQueueGenericReceive+0x118>
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16e6:	c5 01       	movw	r24, r10
    16e8:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xTaskRemoveFromEventList>
    16ec:	88 23       	and	r24, r24
    16ee:	a1 f3       	breq	.-24     	; 0x16d8 <xQueueGenericReceive+0x192>
    16f0:	cd cf       	rjmp	.-102    	; 0x168c <xQueueGenericReceive+0x146>

000016f2 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    16f2:	7f 92       	push	r7
    16f4:	8f 92       	push	r8
    16f6:	9f 92       	push	r9
    16f8:	af 92       	push	r10
    16fa:	bf 92       	push	r11
    16fc:	cf 92       	push	r12
    16fe:	df 92       	push	r13
    1700:	ef 92       	push	r14
    1702:	ff 92       	push	r15
    1704:	0f 93       	push	r16
    1706:	1f 93       	push	r17
    1708:	df 93       	push	r29
    170a:	cf 93       	push	r28
    170c:	00 d0       	rcall	.+0      	; 0x170e <xQueueGenericSend+0x1c>
    170e:	00 d0       	rcall	.+0      	; 0x1710 <xQueueGenericSend+0x1e>
    1710:	0f 92       	push	r0
    1712:	cd b7       	in	r28, 0x3d	; 61
    1714:	de b7       	in	r29, 0x3e	; 62
    1716:	8c 01       	movw	r16, r24
    1718:	4b 01       	movw	r8, r22
    171a:	5d 83       	std	Y+5, r21	; 0x05
    171c:	4c 83       	std	Y+4, r20	; 0x04
    171e:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1720:	48 e0       	ldi	r20, 0x08	; 8
    1722:	a4 2e       	mov	r10, r20
    1724:	b1 2c       	mov	r11, r1
    1726:	a8 0e       	add	r10, r24
    1728:	b9 1e       	adc	r11, r25
    172a:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    172c:	7e 01       	movw	r14, r28
    172e:	08 94       	sec
    1730:	e1 1c       	adc	r14, r1
    1732:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1734:	34 e0       	ldi	r19, 0x04	; 4
    1736:	c3 2e       	mov	r12, r19
    1738:	d1 2c       	mov	r13, r1
    173a:	cc 0e       	add	r12, r28
    173c:	dd 1e       	adc	r13, r29
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    173e:	0f b6       	in	r0, 0x3f	; 63
    1740:	f8 94       	cli
    1742:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1744:	f8 01       	movw	r30, r16
    1746:	92 8d       	ldd	r25, Z+26	; 0x1a
    1748:	83 8d       	ldd	r24, Z+27	; 0x1b
    174a:	98 17       	cp	r25, r24
    174c:	08 f4       	brcc	.+2      	; 0x1750 <xQueueGenericSend+0x5e>
    174e:	49 c0       	rjmp	.+146    	; 0x17e2 <xQueueGenericSend+0xf0>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1750:	8c 81       	ldd	r24, Y+4	; 0x04
    1752:	9d 81       	ldd	r25, Y+5	; 0x05
    1754:	89 2b       	or	r24, r25
    1756:	09 f4       	brne	.+2      	; 0x175a <xQueueGenericSend+0x68>
    1758:	63 c0       	rjmp	.+198    	; 0x1820 <xQueueGenericSend+0x12e>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    175a:	22 23       	and	r18, r18
    175c:	71 f1       	breq	.+92     	; 0x17ba <xQueueGenericSend+0xc8>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    175e:	0f 90       	pop	r0
    1760:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1762:	0e 94 85 0c 	call	0x190a	; 0x190a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1766:	0f b6       	in	r0, 0x3f	; 63
    1768:	f8 94       	cli
    176a:	0f 92       	push	r0
    176c:	f8 01       	movw	r30, r16
    176e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1770:	8f 3f       	cpi	r24, 0xFF	; 255
    1772:	09 f1       	breq	.+66     	; 0x17b6 <xQueueGenericSend+0xc4>
    1774:	f8 01       	movw	r30, r16
    1776:	86 8d       	ldd	r24, Z+30	; 0x1e
    1778:	8f 3f       	cpi	r24, 0xFF	; 255
    177a:	d9 f0       	breq	.+54     	; 0x17b2 <xQueueGenericSend+0xc0>
    177c:	0f 90       	pop	r0
    177e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1780:	c7 01       	movw	r24, r14
    1782:	b6 01       	movw	r22, r12
    1784:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <xTaskCheckForTimeOut>
    1788:	88 23       	and	r24, r24
    178a:	09 f0       	breq	.+2      	; 0x178e <xQueueGenericSend+0x9c>
    178c:	4d c0       	rjmp	.+154    	; 0x1828 <xQueueGenericSend+0x136>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1794:	f8 01       	movw	r30, r16
    1796:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1798:	0f 90       	pop	r0
    179a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    179c:	f8 01       	movw	r30, r16
    179e:	83 8d       	ldd	r24, Z+27	; 0x1b
    17a0:	98 17       	cp	r25, r24
    17a2:	79 f0       	breq	.+30     	; 0x17c2 <xQueueGenericSend+0xd0>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    17a4:	c8 01       	movw	r24, r16
    17a6:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    17aa:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskResumeAll>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    17ae:	21 e0       	ldi	r18, 0x01	; 1
    17b0:	c6 cf       	rjmp	.-116    	; 0x173e <xQueueGenericSend+0x4c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    17b2:	16 8e       	std	Z+30, r1	; 0x1e
    17b4:	e3 cf       	rjmp	.-58     	; 0x177c <xQueueGenericSend+0x8a>
    17b6:	15 8e       	std	Z+29, r1	; 0x1d
    17b8:	dd cf       	rjmp	.-70     	; 0x1774 <xQueueGenericSend+0x82>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    17ba:	c7 01       	movw	r24, r14
    17bc:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <vTaskSetTimeOutState>
    17c0:	ce cf       	rjmp	.-100    	; 0x175e <xQueueGenericSend+0x6c>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    17c2:	6c 81       	ldd	r22, Y+4	; 0x04
    17c4:	7d 81       	ldd	r23, Y+5	; 0x05
    17c6:	c5 01       	movw	r24, r10
    17c8:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    17cc:	c8 01       	movw	r24, r16
    17ce:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    17d2:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskResumeAll>
    17d6:	88 23       	and	r24, r24
    17d8:	51 f7       	brne	.-44     	; 0x17ae <xQueueGenericSend+0xbc>
				{
					portYIELD_WITHIN_API();
    17da:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    17de:	21 e0       	ldi	r18, 0x01	; 1
    17e0:	ae cf       	rjmp	.-164    	; 0x173e <xQueueGenericSend+0x4c>
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    17e2:	c8 01       	movw	r24, r16
    17e4:	b4 01       	movw	r22, r8
    17e6:	47 2d       	mov	r20, r7
    17e8:	0e 94 db 09 	call	0x13b6	; 0x13b6 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17ec:	f8 01       	movw	r30, r16
    17ee:	81 89       	ldd	r24, Z+17	; 0x11
    17f0:	88 23       	and	r24, r24
    17f2:	09 f5       	brne	.+66     	; 0x1836 <xQueueGenericSend+0x144>
						takes care of that. */
						portYIELD_WITHIN_API();
					}
				}

				taskEXIT_CRITICAL();
    17f4:	0f 90       	pop	r0
    17f6:	0f be       	out	0x3f, r0	; 63
    17f8:	81 e0       	ldi	r24, 0x01	; 1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    17fa:	0f 90       	pop	r0
    17fc:	0f 90       	pop	r0
    17fe:	0f 90       	pop	r0
    1800:	0f 90       	pop	r0
    1802:	0f 90       	pop	r0
    1804:	cf 91       	pop	r28
    1806:	df 91       	pop	r29
    1808:	1f 91       	pop	r17
    180a:	0f 91       	pop	r16
    180c:	ff 90       	pop	r15
    180e:	ef 90       	pop	r14
    1810:	df 90       	pop	r13
    1812:	cf 90       	pop	r12
    1814:	bf 90       	pop	r11
    1816:	af 90       	pop	r10
    1818:	9f 90       	pop	r9
    181a:	8f 90       	pop	r8
    181c:	7f 90       	pop	r7
    181e:	08 95       	ret
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1820:	0f 90       	pop	r0
    1822:	0f be       	out	0x3f, r0	; 63
    1824:	80 e0       	ldi	r24, 0x00	; 0
    1826:	e9 cf       	rjmp	.-46     	; 0x17fa <xQueueGenericSend+0x108>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1828:	c8 01       	movw	r24, r16
    182a:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    182e:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskResumeAll>
    1832:	80 e0       	ldi	r24, 0x00	; 0
    1834:	e2 cf       	rjmp	.-60     	; 0x17fa <xQueueGenericSend+0x108>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1836:	c8 01       	movw	r24, r16
    1838:	41 96       	adiw	r24, 0x11	; 17
    183a:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xTaskRemoveFromEventList>
    183e:	81 30       	cpi	r24, 0x01	; 1
    1840:	c9 f6       	brne	.-78     	; 0x17f4 <xQueueGenericSend+0x102>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1842:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    1846:	d6 cf       	rjmp	.-84     	; 0x17f4 <xQueueGenericSend+0x102>

00001848 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1848:	af 92       	push	r10
    184a:	bf 92       	push	r11
    184c:	cf 92       	push	r12
    184e:	df 92       	push	r13
    1850:	ef 92       	push	r14
    1852:	ff 92       	push	r15
    1854:	0f 93       	push	r16
    1856:	1f 93       	push	r17
    1858:	cf 93       	push	r28
    185a:	df 93       	push	r29
    185c:	18 2f       	mov	r17, r24
    185e:	06 2f       	mov	r16, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1860:	88 23       	and	r24, r24
    1862:	71 f4       	brne	.+28     	; 0x1880 <xQueueCreate+0x38>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1864:	20 e0       	ldi	r18, 0x00	; 0
    1866:	30 e0       	ldi	r19, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1868:	c9 01       	movw	r24, r18
    186a:	df 91       	pop	r29
    186c:	cf 91       	pop	r28
    186e:	1f 91       	pop	r17
    1870:	0f 91       	pop	r16
    1872:	ff 90       	pop	r15
    1874:	ef 90       	pop	r14
    1876:	df 90       	pop	r13
    1878:	cf 90       	pop	r12
    187a:	bf 90       	pop	r11
    187c:	af 90       	pop	r10
    187e:	08 95       	ret
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1880:	8f e1       	ldi	r24, 0x1F	; 31
    1882:	90 e0       	ldi	r25, 0x00	; 0
    1884:	0e 94 0f 08 	call	0x101e	; 0x101e <pvPortMalloc>
    1888:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    188a:	00 97       	sbiw	r24, 0x00	; 0
    188c:	59 f3       	breq	.-42     	; 0x1864 <xQueueCreate+0x1c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    188e:	c1 2e       	mov	r12, r17
    1890:	dd 24       	eor	r13, r13
    1892:	a0 2e       	mov	r10, r16
    1894:	bb 24       	eor	r11, r11
    1896:	ac 9c       	mul	r10, r12
    1898:	70 01       	movw	r14, r0
    189a:	ad 9c       	mul	r10, r13
    189c:	f0 0c       	add	r15, r0
    189e:	bc 9c       	mul	r11, r12
    18a0:	f0 0c       	add	r15, r0
    18a2:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    18a4:	c7 01       	movw	r24, r14
    18a6:	01 96       	adiw	r24, 0x01	; 1
    18a8:	0e 94 0f 08 	call	0x101e	; 0x101e <pvPortMalloc>
    18ac:	9c 01       	movw	r18, r24
    18ae:	99 83       	std	Y+1, r25	; 0x01
    18b0:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    18b2:	00 97       	sbiw	r24, 0x00	; 0
    18b4:	21 f1       	breq	.+72     	; 0x18fe <xQueueCreate+0xb6>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    18b6:	e8 0e       	add	r14, r24
    18b8:	f9 1e       	adc	r15, r25
    18ba:	fb 82       	std	Y+3, r15	; 0x03
    18bc:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    18be:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    18c0:	9d 83       	std	Y+5, r25	; 0x05
    18c2:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    18c4:	08 94       	sec
    18c6:	c1 08       	sbc	r12, r1
    18c8:	d1 08       	sbc	r13, r1
    18ca:	ca 9c       	mul	r12, r10
    18cc:	c0 01       	movw	r24, r0
    18ce:	cb 9c       	mul	r12, r11
    18d0:	90 0d       	add	r25, r0
    18d2:	da 9c       	mul	r13, r10
    18d4:	90 0d       	add	r25, r0
    18d6:	11 24       	eor	r1, r1
    18d8:	28 0f       	add	r18, r24
    18da:	39 1f       	adc	r19, r25
    18dc:	3f 83       	std	Y+7, r19	; 0x07
    18de:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    18e0:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    18e2:	0c 8f       	std	Y+28, r16	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    18e4:	8f ef       	ldi	r24, 0xFF	; 255
    18e6:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    18e8:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    18ea:	ce 01       	movw	r24, r28
    18ec:	08 96       	adiw	r24, 0x08	; 8
    18ee:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    18f2:	ce 01       	movw	r24, r28
    18f4:	41 96       	adiw	r24, 0x11	; 17
    18f6:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>
    18fa:	9e 01       	movw	r18, r28
    18fc:	b5 cf       	rjmp	.-150    	; 0x1868 <xQueueCreate+0x20>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    18fe:	ce 01       	movw	r24, r28
    1900:	0e 94 ff 07 	call	0xffe	; 0xffe <vPortFree>
    1904:	20 e0       	ldi	r18, 0x00	; 0
    1906:	30 e0       	ldi	r19, 0x00	; 0
    1908:	af cf       	rjmp	.-162    	; 0x1868 <xQueueCreate+0x20>

0000190a <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    190a:	80 91 72 04 	lds	r24, 0x0472
    190e:	8f 5f       	subi	r24, 0xFF	; 255
    1910:	80 93 72 04 	sts	0x0472, r24
}
    1914:	08 95       	ret

00001916 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1916:	0f b6       	in	r0, 0x3f	; 63
    1918:	f8 94       	cli
    191a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    191c:	20 91 70 04 	lds	r18, 0x0470
    1920:	30 91 71 04 	lds	r19, 0x0471
	}
	taskEXIT_CRITICAL();
    1924:	0f 90       	pop	r0
    1926:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1928:	c9 01       	movw	r24, r18
    192a:	08 95       	ret

0000192c <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    192c:	20 91 70 04 	lds	r18, 0x0470
    1930:	30 91 71 04 	lds	r19, 0x0471
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1934:	c9 01       	movw	r24, r18
    1936:	08 95       	ret

00001938 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1938:	80 91 75 04 	lds	r24, 0x0475
}
    193c:	08 95       	ret

0000193e <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    193e:	80 91 72 04 	lds	r24, 0x0472
    1942:	88 23       	and	r24, r24
    1944:	d1 f5       	brne	.+116    	; 0x19ba <vTaskSwitchContext+0x7c>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1946:	e0 91 73 04 	lds	r30, 0x0473
    194a:	89 e0       	ldi	r24, 0x09	; 9
    194c:	e8 9f       	mul	r30, r24
    194e:	f0 01       	movw	r30, r0
    1950:	11 24       	eor	r1, r1
    1952:	e6 58       	subi	r30, 0x86	; 134
    1954:	fb 4f       	sbci	r31, 0xFB	; 251
    1956:	80 81       	ld	r24, Z
    1958:	88 23       	and	r24, r24
    195a:	81 f4       	brne	.+32     	; 0x197c <vTaskSwitchContext+0x3e>
    195c:	99 e0       	ldi	r25, 0x09	; 9
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    195e:	80 91 73 04 	lds	r24, 0x0473
    1962:	81 50       	subi	r24, 0x01	; 1
    1964:	80 93 73 04 	sts	0x0473, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1968:	e0 91 73 04 	lds	r30, 0x0473
    196c:	e9 9f       	mul	r30, r25
    196e:	f0 01       	movw	r30, r0
    1970:	11 24       	eor	r1, r1
    1972:	e6 58       	subi	r30, 0x86	; 134
    1974:	fb 4f       	sbci	r31, 0xFB	; 251
    1976:	80 81       	ld	r24, Z
    1978:	88 23       	and	r24, r24
    197a:	89 f3       	breq	.-30     	; 0x195e <vTaskSwitchContext+0x20>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    197c:	90 91 73 04 	lds	r25, 0x0473
    1980:	89 e0       	ldi	r24, 0x09	; 9
    1982:	98 9f       	mul	r25, r24
    1984:	d0 01       	movw	r26, r0
    1986:	11 24       	eor	r1, r1
    1988:	a6 58       	subi	r26, 0x86	; 134
    198a:	bb 4f       	sbci	r27, 0xFB	; 251
    198c:	11 96       	adiw	r26, 0x01	; 1
    198e:	ed 91       	ld	r30, X+
    1990:	fc 91       	ld	r31, X
    1992:	12 97       	sbiw	r26, 0x02	; 2
    1994:	02 80       	ldd	r0, Z+2	; 0x02
    1996:	f3 81       	ldd	r31, Z+3	; 0x03
    1998:	e0 2d       	mov	r30, r0
    199a:	12 96       	adiw	r26, 0x02	; 2
    199c:	fc 93       	st	X, r31
    199e:	ee 93       	st	-X, r30
    19a0:	11 97       	sbiw	r26, 0x01	; 1
    19a2:	cd 01       	movw	r24, r26
    19a4:	03 96       	adiw	r24, 0x03	; 3
    19a6:	e8 17       	cp	r30, r24
    19a8:	f9 07       	cpc	r31, r25
    19aa:	59 f0       	breq	.+22     	; 0x19c2 <vTaskSwitchContext+0x84>
    19ac:	86 81       	ldd	r24, Z+6	; 0x06
    19ae:	97 81       	ldd	r25, Z+7	; 0x07
    19b0:	90 93 6d 04 	sts	0x046D, r25
    19b4:	80 93 6c 04 	sts	0x046C, r24
    19b8:	08 95       	ret
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    19ba:	81 e0       	ldi	r24, 0x01	; 1
    19bc:	80 93 6e 04 	sts	0x046E, r24
    19c0:	08 95       	ret
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    19c2:	82 81       	ldd	r24, Z+2	; 0x02
    19c4:	93 81       	ldd	r25, Z+3	; 0x03
    19c6:	12 96       	adiw	r26, 0x02	; 2
    19c8:	9c 93       	st	X, r25
    19ca:	8e 93       	st	-X, r24
    19cc:	11 97       	sbiw	r26, 0x01	; 1
    19ce:	fc 01       	movw	r30, r24
    19d0:	ed cf       	rjmp	.-38     	; 0x19ac <vTaskSwitchContext+0x6e>

000019d2 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    19d2:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    19d4:	80 91 6f 04 	lds	r24, 0x046F
    19d8:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    19da:	80 91 70 04 	lds	r24, 0x0470
    19de:	90 91 71 04 	lds	r25, 0x0471
    19e2:	92 83       	std	Z+2, r25	; 0x02
    19e4:	81 83       	std	Z+1, r24	; 0x01
}
    19e6:	08 95       	ret

000019e8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    19e8:	fc 01       	movw	r30, r24
    19ea:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    19ec:	0f b6       	in	r0, 0x3f	; 63
    19ee:	f8 94       	cli
    19f0:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    19f2:	90 91 6f 04 	lds	r25, 0x046F
    19f6:	80 81       	ld	r24, Z
    19f8:	89 17       	cp	r24, r25
    19fa:	81 f1       	breq	.+96     	; 0x1a5c <xTaskCheckForTimeOut+0x74>
    19fc:	41 81       	ldd	r20, Z+1	; 0x01
    19fe:	52 81       	ldd	r21, Z+2	; 0x02
    1a00:	80 91 70 04 	lds	r24, 0x0470
    1a04:	90 91 71 04 	lds	r25, 0x0471
    1a08:	84 17       	cp	r24, r20
    1a0a:	95 07       	cpc	r25, r21
    1a0c:	18 f5       	brcc	.+70     	; 0x1a54 <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1a0e:	80 91 70 04 	lds	r24, 0x0470
    1a12:	90 91 71 04 	lds	r25, 0x0471
    1a16:	2d 91       	ld	r18, X+
    1a18:	3c 91       	ld	r19, X
    1a1a:	11 97       	sbiw	r26, 0x01	; 1
    1a1c:	84 1b       	sub	r24, r20
    1a1e:	95 0b       	sbc	r25, r21
    1a20:	82 17       	cp	r24, r18
    1a22:	93 07       	cpc	r25, r19
    1a24:	b8 f4       	brcc	.+46     	; 0x1a54 <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1a26:	80 91 70 04 	lds	r24, 0x0470
    1a2a:	90 91 71 04 	lds	r25, 0x0471
    1a2e:	28 1b       	sub	r18, r24
    1a30:	39 0b       	sbc	r19, r25
    1a32:	24 0f       	add	r18, r20
    1a34:	35 1f       	adc	r19, r21
    1a36:	2d 93       	st	X+, r18
    1a38:	3c 93       	st	X, r19
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1a3a:	80 91 6f 04 	lds	r24, 0x046F
    1a3e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1a40:	80 91 70 04 	lds	r24, 0x0470
    1a44:	90 91 71 04 	lds	r25, 0x0471
    1a48:	92 83       	std	Z+2, r25	; 0x02
    1a4a:	81 83       	std	Z+1, r24	; 0x01
    1a4c:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1a4e:	0f 90       	pop	r0
    1a50:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1a52:	08 95       	ret

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
	pxTimeOut->xTimeOnEntering = xTickCount;
    1a54:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1a56:	0f 90       	pop	r0
    1a58:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1a5a:	08 95       	ret
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1a5c:	41 81       	ldd	r20, Z+1	; 0x01
    1a5e:	52 81       	ldd	r21, Z+2	; 0x02
    1a60:	d6 cf       	rjmp	.-84     	; 0x1a0e <xTaskCheckForTimeOut+0x26>

00001a62 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1a62:	81 e0       	ldi	r24, 0x01	; 1
    1a64:	80 93 6e 04 	sts	0x046E, r24
}
    1a68:	08 95       	ret

00001a6a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1a6a:	0f 93       	push	r16
    1a6c:	1f 93       	push	r17
    1a6e:	cf 93       	push	r28
    1a70:	df 93       	push	r29
    1a72:	fc 01       	movw	r30, r24
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1a74:	05 80       	ldd	r0, Z+5	; 0x05
    1a76:	f6 81       	ldd	r31, Z+6	; 0x06
    1a78:	e0 2d       	mov	r30, r0
    1a7a:	06 81       	ldd	r16, Z+6	; 0x06
    1a7c:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1a7e:	e8 01       	movw	r28, r16
    1a80:	2c 96       	adiw	r28, 0x0c	; 12
    1a82:	ce 01       	movw	r24, r28
    1a84:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1a88:	80 91 72 04 	lds	r24, 0x0472
    1a8c:	88 23       	and	r24, r24
    1a8e:	39 f5       	brne	.+78     	; 0x1ade <xTaskRemoveFromEventList+0x74>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1a90:	e8 01       	movw	r28, r16
    1a92:	22 96       	adiw	r28, 0x02	; 2
    1a94:	ce 01       	movw	r24, r28
    1a96:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1a9a:	d8 01       	movw	r26, r16
    1a9c:	56 96       	adiw	r26, 0x16	; 22
    1a9e:	9c 91       	ld	r25, X
    1aa0:	80 91 73 04 	lds	r24, 0x0473
    1aa4:	89 17       	cp	r24, r25
    1aa6:	08 f1       	brcs	.+66     	; 0x1aea <xTaskRemoveFromEventList+0x80>
    1aa8:	89 e0       	ldi	r24, 0x09	; 9
    1aaa:	98 9f       	mul	r25, r24
    1aac:	c0 01       	movw	r24, r0
    1aae:	11 24       	eor	r1, r1
    1ab0:	86 58       	subi	r24, 0x86	; 134
    1ab2:	9b 4f       	sbci	r25, 0xFB	; 251
    1ab4:	be 01       	movw	r22, r28
    1ab6:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vListInsertEnd>
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1aba:	e0 91 6c 04 	lds	r30, 0x046C
    1abe:	f0 91 6d 04 	lds	r31, 0x046D
    1ac2:	20 e0       	ldi	r18, 0x00	; 0
    1ac4:	d8 01       	movw	r26, r16
    1ac6:	56 96       	adiw	r26, 0x16	; 22
    1ac8:	9c 91       	ld	r25, X
    1aca:	86 89       	ldd	r24, Z+22	; 0x16
    1acc:	98 17       	cp	r25, r24
    1ace:	08 f0       	brcs	.+2      	; 0x1ad2 <xTaskRemoveFromEventList+0x68>
    1ad0:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1ad2:	82 2f       	mov	r24, r18
    1ad4:	df 91       	pop	r29
    1ad6:	cf 91       	pop	r28
    1ad8:	1f 91       	pop	r17
    1ada:	0f 91       	pop	r16
    1adc:	08 95       	ret
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1ade:	8d eb       	ldi	r24, 0xBD	; 189
    1ae0:	94 e0       	ldi	r25, 0x04	; 4
    1ae2:	be 01       	movw	r22, r28
    1ae4:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vListInsertEnd>
    1ae8:	e8 cf       	rjmp	.-48     	; 0x1aba <xTaskRemoveFromEventList+0x50>
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1aea:	90 93 73 04 	sts	0x0473, r25
    1aee:	dc cf       	rjmp	.-72     	; 0x1aa8 <xTaskRemoveFromEventList+0x3e>

00001af0 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1af0:	ff 92       	push	r15
    1af2:	0f 93       	push	r16
    1af4:	1f 93       	push	r17
    1af6:	cf 93       	push	r28
    1af8:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1afa:	80 91 72 04 	lds	r24, 0x0472
    1afe:	88 23       	and	r24, r24
    1b00:	09 f0       	breq	.+2      	; 0x1b04 <vTaskIncrementTick+0x14>
    1b02:	9f c0       	rjmp	.+318    	; 0x1c42 <vTaskIncrementTick+0x152>
	{
		++xTickCount;
    1b04:	80 91 70 04 	lds	r24, 0x0470
    1b08:	90 91 71 04 	lds	r25, 0x0471
    1b0c:	01 96       	adiw	r24, 0x01	; 1
    1b0e:	90 93 71 04 	sts	0x0471, r25
    1b12:	80 93 70 04 	sts	0x0470, r24
		if( xTickCount == ( portTickType ) 0U )
    1b16:	80 91 70 04 	lds	r24, 0x0470
    1b1a:	90 91 71 04 	lds	r25, 0x0471
    1b1e:	89 2b       	or	r24, r25
    1b20:	19 f5       	brne	.+70     	; 0x1b68 <vTaskIncrementTick+0x78>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1b22:	20 91 b9 04 	lds	r18, 0x04B9
    1b26:	30 91 ba 04 	lds	r19, 0x04BA
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1b2a:	80 91 bb 04 	lds	r24, 0x04BB
    1b2e:	90 91 bc 04 	lds	r25, 0x04BC
    1b32:	90 93 ba 04 	sts	0x04BA, r25
    1b36:	80 93 b9 04 	sts	0x04B9, r24
			pxOverflowDelayedTaskList = pxTemp;
    1b3a:	30 93 bc 04 	sts	0x04BC, r19
    1b3e:	20 93 bb 04 	sts	0x04BB, r18
			xNumOfOverflows++;
    1b42:	80 91 6f 04 	lds	r24, 0x046F
    1b46:	8f 5f       	subi	r24, 0xFF	; 255
    1b48:	80 93 6f 04 	sts	0x046F, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1b4c:	e0 91 b9 04 	lds	r30, 0x04B9
    1b50:	f0 91 ba 04 	lds	r31, 0x04BA
    1b54:	80 81       	ld	r24, Z
    1b56:	88 23       	and	r24, r24
    1b58:	09 f0       	breq	.+2      	; 0x1b5c <vTaskIncrementTick+0x6c>
    1b5a:	7e c0       	rjmp	.+252    	; 0x1c58 <vTaskIncrementTick+0x168>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1b5c:	8f ef       	ldi	r24, 0xFF	; 255
    1b5e:	9f ef       	ldi	r25, 0xFF	; 255
    1b60:	90 93 85 01 	sts	0x0185, r25
    1b64:	80 93 84 01 	sts	0x0184, r24
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1b68:	20 91 70 04 	lds	r18, 0x0470
    1b6c:	30 91 71 04 	lds	r19, 0x0471
    1b70:	80 91 84 01 	lds	r24, 0x0184
    1b74:	90 91 85 01 	lds	r25, 0x0185
    1b78:	28 17       	cp	r18, r24
    1b7a:	39 07       	cpc	r19, r25
    1b7c:	08 f4       	brcc	.+2      	; 0x1b80 <vTaskIncrementTick+0x90>
    1b7e:	5b c0       	rjmp	.+182    	; 0x1c36 <vTaskIncrementTick+0x146>
    1b80:	e0 91 b9 04 	lds	r30, 0x04B9
    1b84:	f0 91 ba 04 	lds	r31, 0x04BA
    1b88:	80 81       	ld	r24, Z
    1b8a:	88 23       	and	r24, r24
    1b8c:	09 f4       	brne	.+2      	; 0x1b90 <vTaskIncrementTick+0xa0>
    1b8e:	4d c0       	rjmp	.+154    	; 0x1c2a <vTaskIncrementTick+0x13a>
    1b90:	e0 91 b9 04 	lds	r30, 0x04B9
    1b94:	f0 91 ba 04 	lds	r31, 0x04BA
    1b98:	05 80       	ldd	r0, Z+5	; 0x05
    1b9a:	f6 81       	ldd	r31, Z+6	; 0x06
    1b9c:	e0 2d       	mov	r30, r0
    1b9e:	c6 81       	ldd	r28, Z+6	; 0x06
    1ba0:	d7 81       	ldd	r29, Z+7	; 0x07
    1ba2:	2a 81       	ldd	r18, Y+2	; 0x02
    1ba4:	3b 81       	ldd	r19, Y+3	; 0x03
    1ba6:	80 91 70 04 	lds	r24, 0x0470
    1baa:	90 91 71 04 	lds	r25, 0x0471
    1bae:	82 17       	cp	r24, r18
    1bb0:	93 07       	cpc	r25, r19
    1bb2:	08 f4       	brcc	.+2      	; 0x1bb6 <vTaskIncrementTick+0xc6>
    1bb4:	62 c0       	rjmp	.+196    	; 0x1c7a <vTaskIncrementTick+0x18a>
    1bb6:	89 e0       	ldi	r24, 0x09	; 9
    1bb8:	f8 2e       	mov	r15, r24
    1bba:	13 c0       	rjmp	.+38     	; 0x1be2 <vTaskIncrementTick+0xf2>
    1bbc:	e0 91 b9 04 	lds	r30, 0x04B9
    1bc0:	f0 91 ba 04 	lds	r31, 0x04BA
    1bc4:	05 80       	ldd	r0, Z+5	; 0x05
    1bc6:	f6 81       	ldd	r31, Z+6	; 0x06
    1bc8:	e0 2d       	mov	r30, r0
    1bca:	c6 81       	ldd	r28, Z+6	; 0x06
    1bcc:	d7 81       	ldd	r29, Z+7	; 0x07
    1bce:	2a 81       	ldd	r18, Y+2	; 0x02
    1bd0:	3b 81       	ldd	r19, Y+3	; 0x03
    1bd2:	80 91 70 04 	lds	r24, 0x0470
    1bd6:	90 91 71 04 	lds	r25, 0x0471
    1bda:	82 17       	cp	r24, r18
    1bdc:	93 07       	cpc	r25, r19
    1bde:	08 f4       	brcc	.+2      	; 0x1be2 <vTaskIncrementTick+0xf2>
    1be0:	4c c0       	rjmp	.+152    	; 0x1c7a <vTaskIncrementTick+0x18a>
    1be2:	8e 01       	movw	r16, r28
    1be4:	0e 5f       	subi	r16, 0xFE	; 254
    1be6:	1f 4f       	sbci	r17, 0xFF	; 255
    1be8:	c8 01       	movw	r24, r16
    1bea:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
    1bee:	8c 89       	ldd	r24, Y+20	; 0x14
    1bf0:	9d 89       	ldd	r25, Y+21	; 0x15
    1bf2:	89 2b       	or	r24, r25
    1bf4:	21 f0       	breq	.+8      	; 0x1bfe <vTaskIncrementTick+0x10e>
    1bf6:	ce 01       	movw	r24, r28
    1bf8:	0c 96       	adiw	r24, 0x0c	; 12
    1bfa:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
    1bfe:	9e 89       	ldd	r25, Y+22	; 0x16
    1c00:	80 91 73 04 	lds	r24, 0x0473
    1c04:	89 17       	cp	r24, r25
    1c06:	10 f4       	brcc	.+4      	; 0x1c0c <vTaskIncrementTick+0x11c>
    1c08:	90 93 73 04 	sts	0x0473, r25
    1c0c:	9f 9d       	mul	r25, r15
    1c0e:	c0 01       	movw	r24, r0
    1c10:	11 24       	eor	r1, r1
    1c12:	86 58       	subi	r24, 0x86	; 134
    1c14:	9b 4f       	sbci	r25, 0xFB	; 251
    1c16:	b8 01       	movw	r22, r16
    1c18:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vListInsertEnd>
    1c1c:	e0 91 b9 04 	lds	r30, 0x04B9
    1c20:	f0 91 ba 04 	lds	r31, 0x04BA
    1c24:	80 81       	ld	r24, Z
    1c26:	88 23       	and	r24, r24
    1c28:	49 f6       	brne	.-110    	; 0x1bbc <vTaskIncrementTick+0xcc>
    1c2a:	8f ef       	ldi	r24, 0xFF	; 255
    1c2c:	9f ef       	ldi	r25, 0xFF	; 255
    1c2e:	90 93 85 01 	sts	0x0185, r25
    1c32:	80 93 84 01 	sts	0x0184, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1c36:	df 91       	pop	r29
    1c38:	cf 91       	pop	r28
    1c3a:	1f 91       	pop	r17
    1c3c:	0f 91       	pop	r16
    1c3e:	ff 90       	pop	r15
    1c40:	08 95       	ret
		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
	}
	else
	{
		++uxMissedTicks;
    1c42:	80 91 74 04 	lds	r24, 0x0474
    1c46:	8f 5f       	subi	r24, 0xFF	; 255
    1c48:	80 93 74 04 	sts	0x0474, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1c4c:	df 91       	pop	r29
    1c4e:	cf 91       	pop	r28
    1c50:	1f 91       	pop	r17
    1c52:	0f 91       	pop	r16
    1c54:	ff 90       	pop	r15
    1c56:	08 95       	ret
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1c58:	e0 91 b9 04 	lds	r30, 0x04B9
    1c5c:	f0 91 ba 04 	lds	r31, 0x04BA
    1c60:	05 80       	ldd	r0, Z+5	; 0x05
    1c62:	f6 81       	ldd	r31, Z+6	; 0x06
    1c64:	e0 2d       	mov	r30, r0
    1c66:	06 80       	ldd	r0, Z+6	; 0x06
    1c68:	f7 81       	ldd	r31, Z+7	; 0x07
    1c6a:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1c6c:	82 81       	ldd	r24, Z+2	; 0x02
    1c6e:	93 81       	ldd	r25, Z+3	; 0x03
    1c70:	90 93 85 01 	sts	0x0185, r25
    1c74:	80 93 84 01 	sts	0x0184, r24
    1c78:	77 cf       	rjmp	.-274    	; 0x1b68 <vTaskIncrementTick+0x78>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1c7a:	30 93 85 01 	sts	0x0185, r19
    1c7e:	20 93 84 01 	sts	0x0184, r18
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1c82:	df 91       	pop	r29
    1c84:	cf 91       	pop	r28
    1c86:	1f 91       	pop	r17
    1c88:	0f 91       	pop	r16
    1c8a:	ff 90       	pop	r15
    1c8c:	08 95       	ret

00001c8e <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1c8e:	cf 93       	push	r28
    1c90:	df 93       	push	r29
    1c92:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1c94:	e0 91 6c 04 	lds	r30, 0x046C
    1c98:	f0 91 6d 04 	lds	r31, 0x046D
    1c9c:	93 83       	std	Z+3, r25	; 0x03
    1c9e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1ca0:	80 91 70 04 	lds	r24, 0x0470
    1ca4:	90 91 71 04 	lds	r25, 0x0471
    1ca8:	c8 17       	cp	r28, r24
    1caa:	d9 07       	cpc	r29, r25
    1cac:	d0 f0       	brcs	.+52     	; 0x1ce2 <prvAddCurrentTaskToDelayedList+0x54>
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1cae:	80 91 b9 04 	lds	r24, 0x04B9
    1cb2:	90 91 ba 04 	lds	r25, 0x04BA
    1cb6:	60 91 6c 04 	lds	r22, 0x046C
    1cba:	70 91 6d 04 	lds	r23, 0x046D
    1cbe:	6e 5f       	subi	r22, 0xFE	; 254
    1cc0:	7f 4f       	sbci	r23, 0xFF	; 255
    1cc2:	0e 94 a7 11 	call	0x234e	; 0x234e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1cc6:	80 91 84 01 	lds	r24, 0x0184
    1cca:	90 91 85 01 	lds	r25, 0x0185
    1cce:	c8 17       	cp	r28, r24
    1cd0:	d9 07       	cpc	r29, r25
    1cd2:	20 f4       	brcc	.+8      	; 0x1cdc <prvAddCurrentTaskToDelayedList+0x4e>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1cd4:	d0 93 85 01 	sts	0x0185, r29
    1cd8:	c0 93 84 01 	sts	0x0184, r28
		}
	}
}
    1cdc:	df 91       	pop	r29
    1cde:	cf 91       	pop	r28
    1ce0:	08 95       	ret
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ce2:	80 91 bb 04 	lds	r24, 0x04BB
    1ce6:	90 91 bc 04 	lds	r25, 0x04BC
    1cea:	60 91 6c 04 	lds	r22, 0x046C
    1cee:	70 91 6d 04 	lds	r23, 0x046D
    1cf2:	6e 5f       	subi	r22, 0xFE	; 254
    1cf4:	7f 4f       	sbci	r23, 0xFF	; 255
    1cf6:	0e 94 a7 11 	call	0x234e	; 0x234e <vListInsert>
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
    1cfa:	df 91       	pop	r29
    1cfc:	cf 91       	pop	r28
    1cfe:	08 95       	ret

00001d00 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1d00:	0f 93       	push	r16
    1d02:	1f 93       	push	r17
    1d04:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1d06:	60 91 6c 04 	lds	r22, 0x046C
    1d0a:	70 91 6d 04 	lds	r23, 0x046D
    1d0e:	64 5f       	subi	r22, 0xF4	; 244
    1d10:	7f 4f       	sbci	r23, 0xFF	; 255
    1d12:	0e 94 a7 11 	call	0x234e	; 0x234e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d16:	80 91 6c 04 	lds	r24, 0x046C
    1d1a:	90 91 6d 04 	lds	r25, 0x046D
    1d1e:	02 96       	adiw	r24, 0x02	; 2
    1d20:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1d24:	80 91 70 04 	lds	r24, 0x0470
    1d28:	90 91 71 04 	lds	r25, 0x0471
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1d2c:	80 0f       	add	r24, r16
    1d2e:	91 1f       	adc	r25, r17
    1d30:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    1d34:	1f 91       	pop	r17
    1d36:	0f 91       	pop	r16
    1d38:	08 95       	ret

00001d3a <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1d3a:	cf 92       	push	r12
    1d3c:	df 92       	push	r13
    1d3e:	ff 92       	push	r15
    1d40:	0f 93       	push	r16
    1d42:	1f 93       	push	r17
    1d44:	df 93       	push	r29
    1d46:	cf 93       	push	r28
    1d48:	0f 92       	push	r0
    1d4a:	cd b7       	in	r28, 0x3d	; 61
    1d4c:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1d4e:	0f b6       	in	r0, 0x3f	; 63
    1d50:	f8 94       	cli
    1d52:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1d54:	80 91 72 04 	lds	r24, 0x0472
    1d58:	81 50       	subi	r24, 0x01	; 1
    1d5a:	80 93 72 04 	sts	0x0472, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1d5e:	80 91 72 04 	lds	r24, 0x0472
    1d62:	88 23       	and	r24, r24
    1d64:	09 f0       	breq	.+2      	; 0x1d68 <xTaskResumeAll+0x2e>
    1d66:	4e c0       	rjmp	.+156    	; 0x1e04 <xTaskResumeAll+0xca>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1d68:	80 91 75 04 	lds	r24, 0x0475
    1d6c:	88 23       	and	r24, r24
    1d6e:	09 f4       	brne	.+2      	; 0x1d72 <xTaskResumeAll+0x38>
    1d70:	49 c0       	rjmp	.+146    	; 0x1e04 <xTaskResumeAll+0xca>
    1d72:	19 82       	std	Y+1, r1	; 0x01
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    1d74:	99 e0       	ldi	r25, 0x09	; 9
    1d76:	f9 2e       	mov	r15, r25
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1d78:	80 91 bd 04 	lds	r24, 0x04BD
    1d7c:	88 23       	and	r24, r24
    1d7e:	89 f1       	breq	.+98     	; 0x1de2 <xTaskResumeAll+0xa8>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1d80:	e0 91 c2 04 	lds	r30, 0x04C2
    1d84:	f0 91 c3 04 	lds	r31, 0x04C3
    1d88:	c6 80       	ldd	r12, Z+6	; 0x06
    1d8a:	d7 80       	ldd	r13, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    1d8c:	c6 01       	movw	r24, r12
    1d8e:	0c 96       	adiw	r24, 0x0c	; 12
    1d90:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1d94:	86 01       	movw	r16, r12
    1d96:	0e 5f       	subi	r16, 0xFE	; 254
    1d98:	1f 4f       	sbci	r17, 0xFF	; 255
    1d9a:	c8 01       	movw	r24, r16
    1d9c:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1da0:	d6 01       	movw	r26, r12
    1da2:	56 96       	adiw	r26, 0x16	; 22
    1da4:	9c 91       	ld	r25, X
    1da6:	80 91 73 04 	lds	r24, 0x0473
    1daa:	89 17       	cp	r24, r25
    1dac:	10 f4       	brcc	.+4      	; 0x1db2 <xTaskResumeAll+0x78>
    1dae:	90 93 73 04 	sts	0x0473, r25
    1db2:	9f 9d       	mul	r25, r15
    1db4:	c0 01       	movw	r24, r0
    1db6:	11 24       	eor	r1, r1
    1db8:	86 58       	subi	r24, 0x86	; 134
    1dba:	9b 4f       	sbci	r25, 0xFB	; 251
    1dbc:	b8 01       	movw	r22, r16
    1dbe:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1dc2:	e0 91 6c 04 	lds	r30, 0x046C
    1dc6:	f0 91 6d 04 	lds	r31, 0x046D
    1dca:	d6 01       	movw	r26, r12
    1dcc:	56 96       	adiw	r26, 0x16	; 22
    1dce:	9c 91       	ld	r25, X
    1dd0:	86 89       	ldd	r24, Z+22	; 0x16
    1dd2:	98 17       	cp	r25, r24
    1dd4:	88 f2       	brcs	.-94     	; 0x1d78 <xTaskResumeAll+0x3e>
    1dd6:	b1 e0       	ldi	r27, 0x01	; 1
    1dd8:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1dda:	80 91 bd 04 	lds	r24, 0x04BD
    1dde:	88 23       	and	r24, r24
    1de0:	79 f6       	brne	.-98     	; 0x1d80 <xTaskResumeAll+0x46>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1de2:	80 91 74 04 	lds	r24, 0x0474
    1de6:	88 23       	and	r24, r24
    1de8:	c9 f4       	brne	.+50     	; 0x1e1c <xTaskResumeAll+0xe2>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1dea:	e9 81       	ldd	r30, Y+1	; 0x01
    1dec:	e1 30       	cpi	r30, 0x01	; 1
    1dee:	21 f0       	breq	.+8      	; 0x1df8 <xTaskResumeAll+0xbe>
    1df0:	80 91 6e 04 	lds	r24, 0x046E
    1df4:	81 30       	cpi	r24, 0x01	; 1
    1df6:	31 f4       	brne	.+12     	; 0x1e04 <xTaskResumeAll+0xca>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1df8:	10 92 6e 04 	sts	0x046E, r1
					portYIELD_WITHIN_API();
    1dfc:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    1e00:	81 e0       	ldi	r24, 0x01	; 1
    1e02:	01 c0       	rjmp	.+2      	; 0x1e06 <xTaskResumeAll+0xcc>
    1e04:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1e06:	0f 90       	pop	r0
    1e08:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1e0a:	0f 90       	pop	r0
    1e0c:	cf 91       	pop	r28
    1e0e:	df 91       	pop	r29
    1e10:	1f 91       	pop	r17
    1e12:	0f 91       	pop	r16
    1e14:	ff 90       	pop	r15
    1e16:	df 90       	pop	r13
    1e18:	cf 90       	pop	r12
    1e1a:	08 95       	ret
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1e1c:	80 91 74 04 	lds	r24, 0x0474
    1e20:	88 23       	and	r24, r24
    1e22:	51 f3       	breq	.-44     	; 0x1df8 <xTaskResumeAll+0xbe>
					{
						vTaskIncrementTick();
    1e24:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <vTaskIncrementTick>
						--uxMissedTicks;
    1e28:	80 91 74 04 	lds	r24, 0x0474
    1e2c:	81 50       	subi	r24, 0x01	; 1
    1e2e:	80 93 74 04 	sts	0x0474, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1e32:	80 91 74 04 	lds	r24, 0x0474
    1e36:	88 23       	and	r24, r24
    1e38:	a9 f7       	brne	.-22     	; 0x1e24 <xTaskResumeAll+0xea>
    1e3a:	de cf       	rjmp	.-68     	; 0x1df8 <xTaskResumeAll+0xbe>

00001e3c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1e3c:	0f 93       	push	r16
    1e3e:	1f 93       	push	r17
    1e40:	cf 93       	push	r28
    1e42:	df 93       	push	r29
    1e44:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1e46:	00 97       	sbiw	r24, 0x00	; 0
    1e48:	39 f4       	brne	.+14     	; 0x1e58 <vTaskDelay+0x1c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    1e4a:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
		}
	}
    1e4e:	df 91       	pop	r29
    1e50:	cf 91       	pop	r28
    1e52:	1f 91       	pop	r17
    1e54:	0f 91       	pop	r16
    1e56:	08 95       	ret

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1e58:	80 91 72 04 	lds	r24, 0x0472
    1e5c:	8f 5f       	subi	r24, 0xFF	; 255
    1e5e:	80 93 72 04 	sts	0x0472, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1e62:	00 91 70 04 	lds	r16, 0x0470
    1e66:	10 91 71 04 	lds	r17, 0x0471

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e6a:	80 91 6c 04 	lds	r24, 0x046C
    1e6e:	90 91 6d 04 	lds	r25, 0x046D
    1e72:	02 96       	adiw	r24, 0x02	; 2
    1e74:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e78:	ce 01       	movw	r24, r28
    1e7a:	80 0f       	add	r24, r16
    1e7c:	91 1f       	adc	r25, r17
    1e7e:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1e82:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1e86:	88 23       	and	r24, r24
    1e88:	01 f3       	breq	.-64     	; 0x1e4a <vTaskDelay+0xe>
		{
			portYIELD_WITHIN_API();
		}
	}
    1e8a:	df 91       	pop	r29
    1e8c:	cf 91       	pop	r28
    1e8e:	1f 91       	pop	r17
    1e90:	0f 91       	pop	r16
    1e92:	08 95       	ret

00001e94 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1e94:	cf 93       	push	r28
    1e96:	df 93       	push	r29
    1e98:	fc 01       	movw	r30, r24
    1e9a:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1e9c:	80 91 72 04 	lds	r24, 0x0472
    1ea0:	8f 5f       	subi	r24, 0xFF	; 255
    1ea2:	80 93 72 04 	sts	0x0472, r24
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1ea6:	20 81       	ld	r18, Z
    1ea8:	31 81       	ldd	r19, Z+1	; 0x01
    1eaa:	c2 0f       	add	r28, r18
    1eac:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    1eae:	80 91 70 04 	lds	r24, 0x0470
    1eb2:	90 91 71 04 	lds	r25, 0x0471
    1eb6:	82 17       	cp	r24, r18
    1eb8:	93 07       	cpc	r25, r19
    1eba:	f8 f4       	brcc	.+62     	; 0x1efa <vTaskDelayUntil+0x66>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1ebc:	c2 17       	cp	r28, r18
    1ebe:	d3 07       	cpc	r29, r19
    1ec0:	30 f5       	brcc	.+76     	; 0x1f0e <vTaskDelayUntil+0x7a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1ec2:	80 91 70 04 	lds	r24, 0x0470
    1ec6:	90 91 71 04 	lds	r25, 0x0471
    1eca:	8c 17       	cp	r24, r28
    1ecc:	9d 07       	cpc	r25, r29
    1ece:	f8 f4       	brcc	.+62     	; 0x1f0e <vTaskDelayUntil+0x7a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1ed0:	d1 83       	std	Z+1, r29	; 0x01
    1ed2:	c0 83       	st	Z, r28
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ed4:	80 91 6c 04 	lds	r24, 0x046C
    1ed8:	90 91 6d 04 	lds	r25, 0x046D
    1edc:	02 96       	adiw	r24, 0x02	; 2
    1ede:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1ee2:	ce 01       	movw	r24, r28
    1ee4:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1ee8:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1eec:	88 23       	and	r24, r24
    1eee:	11 f4       	brne	.+4      	; 0x1ef4 <vTaskDelayUntil+0x60>
		{
			portYIELD_WITHIN_API();
    1ef0:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
		}
	}
    1ef4:	df 91       	pop	r29
    1ef6:	cf 91       	pop	r28
    1ef8:	08 95       	ret
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1efa:	c2 17       	cp	r28, r18
    1efc:	d3 07       	cpc	r29, r19
    1efe:	40 f3       	brcs	.-48     	; 0x1ed0 <vTaskDelayUntil+0x3c>
    1f00:	80 91 70 04 	lds	r24, 0x0470
    1f04:	90 91 71 04 	lds	r25, 0x0471
    1f08:	8c 17       	cp	r24, r28
    1f0a:	9d 07       	cpc	r25, r29
    1f0c:	08 f3       	brcs	.-62     	; 0x1ed0 <vTaskDelayUntil+0x3c>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1f0e:	d1 83       	std	Z+1, r29	; 0x01
    1f10:	c0 83       	st	Z, r28
    1f12:	ea cf       	rjmp	.-44     	; 0x1ee8 <vTaskDelayUntil+0x54>

00001f14 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1f14:	ef 92       	push	r14
    1f16:	ff 92       	push	r15
    1f18:	0f 93       	push	r16
    1f1a:	1f 93       	push	r17
    1f1c:	cf 93       	push	r28
    1f1e:	df 93       	push	r29
    1f20:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1f22:	0f b6       	in	r0, 0x3f	; 63
    1f24:	f8 94       	cli
    1f26:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1f28:	80 91 6c 04 	lds	r24, 0x046C
    1f2c:	90 91 6d 04 	lds	r25, 0x046D
    1f30:	e8 16       	cp	r14, r24
    1f32:	f9 06       	cpc	r15, r25
    1f34:	81 f1       	breq	.+96     	; 0x1f96 <vTaskDelete+0x82>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1f36:	e1 14       	cp	r14, r1
    1f38:	f1 04       	cpc	r15, r1
    1f3a:	79 f1       	breq	.+94     	; 0x1f9a <vTaskDelete+0x86>
    1f3c:	e7 01       	movw	r28, r14

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1f3e:	8e 01       	movw	r16, r28
    1f40:	0e 5f       	subi	r16, 0xFE	; 254
    1f42:	1f 4f       	sbci	r17, 0xFF	; 255
    1f44:	c8 01       	movw	r24, r16
    1f46:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1f4a:	8c 89       	ldd	r24, Y+20	; 0x14
    1f4c:	9d 89       	ldd	r25, Y+21	; 0x15
    1f4e:	89 2b       	or	r24, r25
    1f50:	21 f0       	breq	.+8      	; 0x1f5a <vTaskDelete+0x46>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1f52:	ce 01       	movw	r24, r28
    1f54:	0c 96       	adiw	r24, 0x0c	; 12
    1f56:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1f5a:	86 ec       	ldi	r24, 0xC6	; 198
    1f5c:	94 e0       	ldi	r25, 0x04	; 4
    1f5e:	b8 01       	movw	r22, r16
    1f60:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1f64:	80 91 77 04 	lds	r24, 0x0477
    1f68:	8f 5f       	subi	r24, 0xFF	; 255
    1f6a:	80 93 77 04 	sts	0x0477, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1f6e:	80 91 78 04 	lds	r24, 0x0478
    1f72:	8f 5f       	subi	r24, 0xFF	; 255
    1f74:	80 93 78 04 	sts	0x0478, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1f78:	0f 90       	pop	r0
    1f7a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1f7c:	80 91 76 04 	lds	r24, 0x0476
    1f80:	88 23       	and	r24, r24
    1f82:	11 f0       	breq	.+4      	; 0x1f88 <vTaskDelete+0x74>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1f84:	ef 28       	or	r14, r15
    1f86:	71 f0       	breq	.+28     	; 0x1fa4 <vTaskDelete+0x90>
			{
				portYIELD_WITHIN_API();
			}
		}
	}
    1f88:	df 91       	pop	r29
    1f8a:	cf 91       	pop	r28
    1f8c:	1f 91       	pop	r17
    1f8e:	0f 91       	pop	r16
    1f90:	ff 90       	pop	r15
    1f92:	ef 90       	pop	r14
    1f94:	08 95       	ret

		taskENTER_CRITICAL();
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1f96:	ee 24       	eor	r14, r14
    1f98:	ff 24       	eor	r15, r15
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1f9a:	c0 91 6c 04 	lds	r28, 0x046C
    1f9e:	d0 91 6d 04 	lds	r29, 0x046D
    1fa2:	cd cf       	rjmp	.-102    	; 0x1f3e <vTaskDelete+0x2a>
		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
		{
			if( ( void * ) pxTaskToDelete == NULL )
			{
				portYIELD_WITHIN_API();
    1fa4:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    1fa8:	ef cf       	rjmp	.-34     	; 0x1f88 <vTaskDelete+0x74>

00001faa <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1faa:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1fac:	10 92 76 04 	sts	0x0476, r1
	vPortEndScheduler();
    1fb0:	0e 94 b3 08 	call	0x1166	; 0x1166 <vPortEndScheduler>
}
    1fb4:	08 95       	ret

00001fb6 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    1fb6:	0f 93       	push	r16
    1fb8:	1f 93       	push	r17
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1fba:	80 91 77 04 	lds	r24, 0x0477
    1fbe:	88 23       	and	r24, r24
    1fc0:	e1 f3       	breq	.-8      	; 0x1fba <prvIdleTask+0x4>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1fc2:	80 91 72 04 	lds	r24, 0x0472
    1fc6:	8f 5f       	subi	r24, 0xFF	; 255
    1fc8:	80 93 72 04 	sts	0x0472, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1fcc:	10 91 c6 04 	lds	r17, 0x04C6
			xTaskResumeAll();
    1fd0:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1fd4:	11 23       	and	r17, r17
    1fd6:	89 f3       	breq	.-30     	; 0x1fba <prvIdleTask+0x4>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1fd8:	0f b6       	in	r0, 0x3f	; 63
    1fda:	f8 94       	cli
    1fdc:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1fde:	e0 91 cb 04 	lds	r30, 0x04CB
    1fe2:	f0 91 cc 04 	lds	r31, 0x04CC
    1fe6:	06 81       	ldd	r16, Z+6	; 0x06
    1fe8:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1fea:	c8 01       	movw	r24, r16
    1fec:	02 96       	adiw	r24, 0x02	; 2
    1fee:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vListRemove>
					--uxCurrentNumberOfTasks;
    1ff2:	80 91 75 04 	lds	r24, 0x0475
    1ff6:	81 50       	subi	r24, 0x01	; 1
    1ff8:	80 93 75 04 	sts	0x0475, r24
					--uxTasksDeleted;
    1ffc:	80 91 77 04 	lds	r24, 0x0477
    2000:	81 50       	subi	r24, 0x01	; 1
    2002:	80 93 77 04 	sts	0x0477, r24
				}
				taskEXIT_CRITICAL();
    2006:	0f 90       	pop	r0
    2008:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    200a:	f8 01       	movw	r30, r16
    200c:	87 89       	ldd	r24, Z+23	; 0x17
    200e:	90 8d       	ldd	r25, Z+24	; 0x18
    2010:	0e 94 ff 07 	call	0xffe	; 0xffe <vPortFree>
		vPortFree( pxTCB );
    2014:	c8 01       	movw	r24, r16
    2016:	0e 94 ff 07 	call	0xffe	; 0xffe <vPortFree>
    201a:	cf cf       	rjmp	.-98     	; 0x1fba <prvIdleTask+0x4>

0000201c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    201c:	2f 92       	push	r2
    201e:	3f 92       	push	r3
    2020:	4f 92       	push	r4
    2022:	5f 92       	push	r5
    2024:	6f 92       	push	r6
    2026:	7f 92       	push	r7
    2028:	8f 92       	push	r8
    202a:	9f 92       	push	r9
    202c:	af 92       	push	r10
    202e:	bf 92       	push	r11
    2030:	cf 92       	push	r12
    2032:	df 92       	push	r13
    2034:	ef 92       	push	r14
    2036:	ff 92       	push	r15
    2038:	0f 93       	push	r16
    203a:	1f 93       	push	r17
    203c:	df 93       	push	r29
    203e:	cf 93       	push	r28
    2040:	00 d0       	rcall	.+0      	; 0x2042 <xTaskGenericCreate+0x26>
    2042:	0f 92       	push	r0
    2044:	cd b7       	in	r28, 0x3d	; 61
    2046:	de b7       	in	r29, 0x3e	; 62
    2048:	1c 01       	movw	r2, r24
    204a:	4b 01       	movw	r8, r22
    204c:	5a 01       	movw	r10, r20
    204e:	29 01       	movw	r4, r18
    2050:	09 83       	std	Y+1, r16	; 0x01
    2052:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2054:	81 e2       	ldi	r24, 0x21	; 33
    2056:	90 e0       	ldi	r25, 0x00	; 0
    2058:	0e 94 0f 08 	call	0x101e	; 0x101e <pvPortMalloc>
    205c:	8a 83       	std	Y+2, r24	; 0x02
    205e:	9b 83       	std	Y+3, r25	; 0x03

	if( pxNewTCB != NULL )
    2060:	8a 81       	ldd	r24, Y+2	; 0x02
    2062:	9b 81       	ldd	r25, Y+3	; 0x03
    2064:	89 2b       	or	r24, r25
    2066:	09 f4       	brne	.+2      	; 0x206a <xTaskGenericCreate+0x4e>
    2068:	cd c0       	rjmp	.+410    	; 0x2204 <xTaskGenericCreate+0x1e8>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    206a:	c1 14       	cp	r12, r1
    206c:	d1 04       	cpc	r13, r1
    206e:	09 f4       	brne	.+2      	; 0x2072 <xTaskGenericCreate+0x56>
    2070:	bb c0       	rjmp	.+374    	; 0x21e8 <xTaskGenericCreate+0x1cc>
    2072:	ea 81       	ldd	r30, Y+2	; 0x02
    2074:	fb 81       	ldd	r31, Y+3	; 0x03
    2076:	d0 8e       	std	Z+24, r13	; 0x18
    2078:	c7 8a       	std	Z+23, r12	; 0x17
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    207a:	c6 01       	movw	r24, r12
    207c:	65 ea       	ldi	r22, 0xA5	; 165
    207e:	70 e0       	ldi	r23, 0x00	; 0
    2080:	a5 01       	movw	r20, r10
    2082:	0e 94 7d 19 	call	0x32fa	; 0x32fa <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    2086:	08 94       	sec
    2088:	a1 08       	sbc	r10, r1
    208a:	b1 08       	sbc	r11, r1
    208c:	ea 81       	ldd	r30, Y+2	; 0x02
    208e:	fb 81       	ldd	r31, Y+3	; 0x03
    2090:	e7 88       	ldd	r14, Z+23	; 0x17
    2092:	f0 8c       	ldd	r15, Z+24	; 0x18
    2094:	ea 0c       	add	r14, r10
    2096:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2098:	cf 01       	movw	r24, r30
    209a:	49 96       	adiw	r24, 0x19	; 25
    209c:	b4 01       	movw	r22, r8
    209e:	48 e0       	ldi	r20, 0x08	; 8
    20a0:	50 e0       	ldi	r21, 0x00	; 0
    20a2:	0e 94 84 19 	call	0x3308	; 0x3308 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    20a6:	ea 81       	ldd	r30, Y+2	; 0x02
    20a8:	fb 81       	ldd	r31, Y+3	; 0x03
    20aa:	10 a2       	std	Z+32, r1	; 0x20
    20ac:	19 81       	ldd	r17, Y+1	; 0x01
    20ae:	15 30       	cpi	r17, 0x05	; 5
    20b0:	08 f0       	brcs	.+2      	; 0x20b4 <xTaskGenericCreate+0x98>
    20b2:	98 c0       	rjmp	.+304    	; 0x21e4 <xTaskGenericCreate+0x1c8>
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    20b4:	ea 81       	ldd	r30, Y+2	; 0x02
    20b6:	fb 81       	ldd	r31, Y+3	; 0x03
    20b8:	16 8b       	std	Z+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    20ba:	32 e0       	ldi	r19, 0x02	; 2
    20bc:	c3 2e       	mov	r12, r19
    20be:	d1 2c       	mov	r13, r1
    20c0:	ce 0e       	add	r12, r30
    20c2:	df 1e       	adc	r13, r31
    20c4:	c6 01       	movw	r24, r12
    20c6:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    20ca:	8a 81       	ldd	r24, Y+2	; 0x02
    20cc:	9b 81       	ldd	r25, Y+3	; 0x03
    20ce:	0c 96       	adiw	r24, 0x0c	; 12
    20d0:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    20d4:	8a 81       	ldd	r24, Y+2	; 0x02
    20d6:	9b 81       	ldd	r25, Y+3	; 0x03
    20d8:	fc 01       	movw	r30, r24
    20da:	91 87       	std	Z+9, r25	; 0x09
    20dc:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    20de:	85 e0       	ldi	r24, 0x05	; 5
    20e0:	90 e0       	ldi	r25, 0x00	; 0
    20e2:	81 1b       	sub	r24, r17
    20e4:	91 09       	sbc	r25, r1
    20e6:	95 87       	std	Z+13, r25	; 0x0d
    20e8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    20ea:	f3 8b       	std	Z+19, r31	; 0x13
    20ec:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    20ee:	c7 01       	movw	r24, r14
    20f0:	b1 01       	movw	r22, r2
    20f2:	a2 01       	movw	r20, r4
    20f4:	0e 94 36 08 	call	0x106c	; 0x106c <pxPortInitialiseStack>
    20f8:	ea 81       	ldd	r30, Y+2	; 0x02
    20fa:	fb 81       	ldd	r31, Y+3	; 0x03
    20fc:	91 83       	std	Z+1, r25	; 0x01
    20fe:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2100:	61 14       	cp	r6, r1
    2102:	71 04       	cpc	r7, r1
    2104:	21 f0       	breq	.+8      	; 0x210e <xTaskGenericCreate+0xf2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2106:	cf 01       	movw	r24, r30
    2108:	f3 01       	movw	r30, r6
    210a:	91 83       	std	Z+1, r25	; 0x01
    210c:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    210e:	0f b6       	in	r0, 0x3f	; 63
    2110:	f8 94       	cli
    2112:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2114:	80 91 75 04 	lds	r24, 0x0475
    2118:	8f 5f       	subi	r24, 0xFF	; 255
    211a:	80 93 75 04 	sts	0x0475, r24
			if( pxCurrentTCB == NULL )
    211e:	80 91 6c 04 	lds	r24, 0x046C
    2122:	90 91 6d 04 	lds	r25, 0x046D
    2126:	89 2b       	or	r24, r25
    2128:	09 f4       	brne	.+2      	; 0x212c <xTaskGenericCreate+0x110>
    212a:	6e c0       	rjmp	.+220    	; 0x2208 <xTaskGenericCreate+0x1ec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    212c:	80 91 76 04 	lds	r24, 0x0476
    2130:	88 23       	and	r24, r24
    2132:	71 f4       	brne	.+28     	; 0x2150 <xTaskGenericCreate+0x134>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2134:	e0 91 6c 04 	lds	r30, 0x046C
    2138:	f0 91 6d 04 	lds	r31, 0x046D
    213c:	86 89       	ldd	r24, Z+22	; 0x16
    213e:	99 81       	ldd	r25, Y+1	; 0x01
    2140:	98 17       	cp	r25, r24
    2142:	30 f0       	brcs	.+12     	; 0x2150 <xTaskGenericCreate+0x134>
					{
						pxCurrentTCB = pxNewTCB;
    2144:	ea 81       	ldd	r30, Y+2	; 0x02
    2146:	fb 81       	ldd	r31, Y+3	; 0x03
    2148:	f0 93 6d 04 	sts	0x046D, r31
    214c:	e0 93 6c 04 	sts	0x046C, r30
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2150:	ea 81       	ldd	r30, Y+2	; 0x02
    2152:	fb 81       	ldd	r31, Y+3	; 0x03
    2154:	96 89       	ldd	r25, Z+22	; 0x16
    2156:	80 91 79 04 	lds	r24, 0x0479
    215a:	89 17       	cp	r24, r25
    215c:	10 f4       	brcc	.+4      	; 0x2162 <xTaskGenericCreate+0x146>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    215e:	90 93 79 04 	sts	0x0479, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2162:	80 91 78 04 	lds	r24, 0x0478
    2166:	8f 5f       	subi	r24, 0xFF	; 255
    2168:	80 93 78 04 	sts	0x0478, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    216c:	ea 81       	ldd	r30, Y+2	; 0x02
    216e:	fb 81       	ldd	r31, Y+3	; 0x03
    2170:	96 89       	ldd	r25, Z+22	; 0x16
    2172:	80 91 73 04 	lds	r24, 0x0473
    2176:	89 17       	cp	r24, r25
    2178:	18 f4       	brcc	.+6      	; 0x2180 <xTaskGenericCreate+0x164>
    217a:	90 93 73 04 	sts	0x0473, r25
    217e:	96 89       	ldd	r25, Z+22	; 0x16
    2180:	89 e0       	ldi	r24, 0x09	; 9
    2182:	98 9f       	mul	r25, r24
    2184:	c0 01       	movw	r24, r0
    2186:	11 24       	eor	r1, r1
    2188:	86 58       	subi	r24, 0x86	; 134
    218a:	9b 4f       	sbci	r25, 0xFB	; 251
    218c:	b6 01       	movw	r22, r12
    218e:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2192:	0f 90       	pop	r0
    2194:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    2196:	80 91 76 04 	lds	r24, 0x0476
    219a:	88 23       	and	r24, r24
    219c:	61 f0       	breq	.+24     	; 0x21b6 <xTaskGenericCreate+0x19a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    219e:	e0 91 6c 04 	lds	r30, 0x046C
    21a2:	f0 91 6d 04 	lds	r31, 0x046D
    21a6:	86 89       	ldd	r24, Z+22	; 0x16
    21a8:	f9 81       	ldd	r31, Y+1	; 0x01
    21aa:	8f 17       	cp	r24, r31
    21ac:	20 f4       	brcc	.+8      	; 0x21b6 <xTaskGenericCreate+0x19a>
			{
				portYIELD_WITHIN_API();
    21ae:	0e 94 12 09 	call	0x1224	; 0x1224 <vPortYield>
    21b2:	81 e0       	ldi	r24, 0x01	; 1
    21b4:	01 c0       	rjmp	.+2      	; 0x21b8 <xTaskGenericCreate+0x19c>
    21b6:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    21b8:	0f 90       	pop	r0
    21ba:	0f 90       	pop	r0
    21bc:	0f 90       	pop	r0
    21be:	cf 91       	pop	r28
    21c0:	df 91       	pop	r29
    21c2:	1f 91       	pop	r17
    21c4:	0f 91       	pop	r16
    21c6:	ff 90       	pop	r15
    21c8:	ef 90       	pop	r14
    21ca:	df 90       	pop	r13
    21cc:	cf 90       	pop	r12
    21ce:	bf 90       	pop	r11
    21d0:	af 90       	pop	r10
    21d2:	9f 90       	pop	r9
    21d4:	8f 90       	pop	r8
    21d6:	7f 90       	pop	r7
    21d8:	6f 90       	pop	r6
    21da:	5f 90       	pop	r5
    21dc:	4f 90       	pop	r4
    21de:	3f 90       	pop	r3
    21e0:	2f 90       	pop	r2
    21e2:	08 95       	ret
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    21e4:	14 e0       	ldi	r17, 0x04	; 4
    21e6:	66 cf       	rjmp	.-308    	; 0x20b4 <xTaskGenericCreate+0x98>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    21e8:	c5 01       	movw	r24, r10
    21ea:	0e 94 0f 08 	call	0x101e	; 0x101e <pvPortMalloc>
    21ee:	6c 01       	movw	r12, r24
    21f0:	ea 81       	ldd	r30, Y+2	; 0x02
    21f2:	fb 81       	ldd	r31, Y+3	; 0x03
    21f4:	90 8f       	std	Z+24, r25	; 0x18
    21f6:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    21f8:	00 97       	sbiw	r24, 0x00	; 0
    21fa:	09 f0       	breq	.+2      	; 0x21fe <xTaskGenericCreate+0x1e2>
    21fc:	3e cf       	rjmp	.-388    	; 0x207a <xTaskGenericCreate+0x5e>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    21fe:	cf 01       	movw	r24, r30
    2200:	0e 94 ff 07 	call	0xffe	; 0xffe <vPortFree>
    2204:	8f ef       	ldi	r24, 0xFF	; 255
    2206:	d8 cf       	rjmp	.-80     	; 0x21b8 <xTaskGenericCreate+0x19c>
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2208:	ea 81       	ldd	r30, Y+2	; 0x02
    220a:	fb 81       	ldd	r31, Y+3	; 0x03
    220c:	f0 93 6d 04 	sts	0x046D, r31
    2210:	e0 93 6c 04 	sts	0x046C, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2214:	80 91 75 04 	lds	r24, 0x0475
    2218:	81 30       	cpi	r24, 0x01	; 1
    221a:	09 f0       	breq	.+2      	; 0x221e <xTaskGenericCreate+0x202>
    221c:	99 cf       	rjmp	.-206    	; 0x2150 <xTaskGenericCreate+0x134>
    221e:	0a e7       	ldi	r16, 0x7A	; 122
    2220:	14 e0       	ldi	r17, 0x04	; 4
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2222:	c8 01       	movw	r24, r16
    2224:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>
    2228:	07 5f       	subi	r16, 0xF7	; 247
    222a:	1f 4f       	sbci	r17, 0xFF	; 255

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    222c:	f4 e0       	ldi	r31, 0x04	; 4
    222e:	07 3a       	cpi	r16, 0xA7	; 167
    2230:	1f 07       	cpc	r17, r31
    2232:	b9 f7       	brne	.-18     	; 0x2222 <xTaskGenericCreate+0x206>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2234:	27 ea       	ldi	r18, 0xA7	; 167
    2236:	e2 2e       	mov	r14, r18
    2238:	24 e0       	ldi	r18, 0x04	; 4
    223a:	f2 2e       	mov	r15, r18
    223c:	c7 01       	movw	r24, r14
    223e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2242:	00 eb       	ldi	r16, 0xB0	; 176
    2244:	14 e0       	ldi	r17, 0x04	; 4
    2246:	c8 01       	movw	r24, r16
    2248:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    224c:	8d eb       	ldi	r24, 0xBD	; 189
    224e:	94 e0       	ldi	r25, 0x04	; 4
    2250:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2254:	86 ec       	ldi	r24, 0xC6	; 198
    2256:	94 e0       	ldi	r25, 0x04	; 4
    2258:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    225c:	f0 92 ba 04 	sts	0x04BA, r15
    2260:	e0 92 b9 04 	sts	0x04B9, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2264:	10 93 bc 04 	sts	0x04BC, r17
    2268:	00 93 bb 04 	sts	0x04BB, r16
    226c:	71 cf       	rjmp	.-286    	; 0x2150 <xTaskGenericCreate+0x134>

0000226e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    226e:	af 92       	push	r10
    2270:	bf 92       	push	r11
    2272:	cf 92       	push	r12
    2274:	df 92       	push	r13
    2276:	ef 92       	push	r14
    2278:	ff 92       	push	r15
    227a:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    227c:	8b ed       	ldi	r24, 0xDB	; 219
    227e:	9f e0       	ldi	r25, 0x0F	; 15
    2280:	60 e6       	ldi	r22, 0x60	; 96
    2282:	70 e0       	ldi	r23, 0x00	; 0
    2284:	45 e5       	ldi	r20, 0x55	; 85
    2286:	50 e0       	ldi	r21, 0x00	; 0
    2288:	20 e0       	ldi	r18, 0x00	; 0
    228a:	30 e0       	ldi	r19, 0x00	; 0
    228c:	00 e0       	ldi	r16, 0x00	; 0
    228e:	ee 24       	eor	r14, r14
    2290:	ff 24       	eor	r15, r15
    2292:	cc 24       	eor	r12, r12
    2294:	dd 24       	eor	r13, r13
    2296:	aa 24       	eor	r10, r10
    2298:	bb 24       	eor	r11, r11
    229a:	0e 94 0e 10 	call	0x201c	; 0x201c <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    229e:	81 30       	cpi	r24, 0x01	; 1
    22a0:	41 f0       	breq	.+16     	; 0x22b2 <vTaskStartScheduler+0x44>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    22a2:	0f 91       	pop	r16
    22a4:	ff 90       	pop	r15
    22a6:	ef 90       	pop	r14
    22a8:	df 90       	pop	r13
    22aa:	cf 90       	pop	r12
    22ac:	bf 90       	pop	r11
    22ae:	af 90       	pop	r10
    22b0:	08 95       	ret
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    22b2:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    22b4:	80 93 76 04 	sts	0x0476, r24
		xTickCount = ( portTickType ) 0U;
    22b8:	10 92 71 04 	sts	0x0471, r1
    22bc:	10 92 70 04 	sts	0x0470, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    22c0:	0e 94 7e 08 	call	0x10fc	; 0x10fc <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    22c4:	0f 91       	pop	r16
    22c6:	ff 90       	pop	r15
    22c8:	ef 90       	pop	r14
    22ca:	df 90       	pop	r13
    22cc:	cf 90       	pop	r12
    22ce:	bf 90       	pop	r11
    22d0:	af 90       	pop	r10
    22d2:	08 95       	ret

000022d4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    22d4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    22d6:	9c 01       	movw	r18, r24
    22d8:	2d 5f       	subi	r18, 0xFD	; 253
    22da:	3f 4f       	sbci	r19, 0xFF	; 255
    22dc:	32 83       	std	Z+2, r19	; 0x02
    22de:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    22e0:	8f ef       	ldi	r24, 0xFF	; 255
    22e2:	9f ef       	ldi	r25, 0xFF	; 255
    22e4:	94 83       	std	Z+4, r25	; 0x04
    22e6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    22e8:	36 83       	std	Z+6, r19	; 0x06
    22ea:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    22ec:	30 87       	std	Z+8, r19	; 0x08
    22ee:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    22f0:	10 82       	st	Z, r1
}
    22f2:	08 95       	ret

000022f4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    22f4:	fc 01       	movw	r30, r24
    22f6:	11 86       	std	Z+9, r1	; 0x09
    22f8:	10 86       	std	Z+8, r1	; 0x08
}
    22fa:	08 95       	ret

000022fc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    22fc:	cf 93       	push	r28
    22fe:	df 93       	push	r29
    2300:	ac 01       	movw	r20, r24
    2302:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2304:	ec 01       	movw	r28, r24
    2306:	29 81       	ldd	r18, Y+1	; 0x01
    2308:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    230a:	f9 01       	movw	r30, r18
    230c:	82 81       	ldd	r24, Z+2	; 0x02
    230e:	93 81       	ldd	r25, Z+3	; 0x03
    2310:	13 96       	adiw	r26, 0x03	; 3
    2312:	9c 93       	st	X, r25
    2314:	8e 93       	st	-X, r24
    2316:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2318:	89 81       	ldd	r24, Y+1	; 0x01
    231a:	9a 81       	ldd	r25, Y+2	; 0x02
    231c:	15 96       	adiw	r26, 0x05	; 5
    231e:	9c 93       	st	X, r25
    2320:	8e 93       	st	-X, r24
    2322:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2324:	02 80       	ldd	r0, Z+2	; 0x02
    2326:	f3 81       	ldd	r31, Z+3	; 0x03
    2328:	e0 2d       	mov	r30, r0
    232a:	75 83       	std	Z+5, r23	; 0x05
    232c:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    232e:	e9 01       	movw	r28, r18
    2330:	7b 83       	std	Y+3, r23	; 0x03
    2332:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2334:	fa 01       	movw	r30, r20
    2336:	72 83       	std	Z+2, r23	; 0x02
    2338:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    233a:	19 96       	adiw	r26, 0x09	; 9
    233c:	5c 93       	st	X, r21
    233e:	4e 93       	st	-X, r20
    2340:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    2342:	80 81       	ld	r24, Z
    2344:	8f 5f       	subi	r24, 0xFF	; 255
    2346:	80 83       	st	Z, r24
}
    2348:	df 91       	pop	r29
    234a:	cf 91       	pop	r28
    234c:	08 95       	ret

0000234e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    234e:	cf 93       	push	r28
    2350:	df 93       	push	r29
    2352:	ac 01       	movw	r20, r24
    2354:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2356:	28 81       	ld	r18, Y
    2358:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    235a:	8f ef       	ldi	r24, 0xFF	; 255
    235c:	2f 3f       	cpi	r18, 0xFF	; 255
    235e:	38 07       	cpc	r19, r24
    2360:	79 f1       	breq	.+94     	; 0x23c0 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2362:	da 01       	movw	r26, r20
    2364:	13 96       	adiw	r26, 0x03	; 3
    2366:	12 96       	adiw	r26, 0x02	; 2
    2368:	ed 91       	ld	r30, X+
    236a:	fc 91       	ld	r31, X
    236c:	13 97       	sbiw	r26, 0x03	; 3
    236e:	80 81       	ld	r24, Z
    2370:	91 81       	ldd	r25, Z+1	; 0x01
    2372:	28 17       	cp	r18, r24
    2374:	39 07       	cpc	r19, r25
    2376:	68 f0       	brcs	.+26     	; 0x2392 <vListInsert+0x44>
    2378:	12 96       	adiw	r26, 0x02	; 2
    237a:	0d 90       	ld	r0, X+
    237c:	bc 91       	ld	r27, X
    237e:	a0 2d       	mov	r26, r0
    2380:	12 96       	adiw	r26, 0x02	; 2
    2382:	ed 91       	ld	r30, X+
    2384:	fc 91       	ld	r31, X
    2386:	13 97       	sbiw	r26, 0x03	; 3
    2388:	80 81       	ld	r24, Z
    238a:	91 81       	ldd	r25, Z+1	; 0x01
    238c:	28 17       	cp	r18, r24
    238e:	39 07       	cpc	r19, r25
    2390:	98 f7       	brcc	.-26     	; 0x2378 <vListInsert+0x2a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2392:	12 96       	adiw	r26, 0x02	; 2
    2394:	ed 91       	ld	r30, X+
    2396:	fc 91       	ld	r31, X
    2398:	13 97       	sbiw	r26, 0x03	; 3
    239a:	fb 83       	std	Y+3, r31	; 0x03
    239c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    239e:	d5 83       	std	Z+5, r29	; 0x05
    23a0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    23a2:	bd 83       	std	Y+5, r27	; 0x05
    23a4:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    23a6:	13 96       	adiw	r26, 0x03	; 3
    23a8:	dc 93       	st	X, r29
    23aa:	ce 93       	st	-X, r28
    23ac:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    23ae:	59 87       	std	Y+9, r21	; 0x09
    23b0:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    23b2:	fa 01       	movw	r30, r20
    23b4:	80 81       	ld	r24, Z
    23b6:	8f 5f       	subi	r24, 0xFF	; 255
    23b8:	80 83       	st	Z, r24
}
    23ba:	df 91       	pop	r29
    23bc:	cf 91       	pop	r28
    23be:	08 95       	ret
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    23c0:	fa 01       	movw	r30, r20
    23c2:	a7 81       	ldd	r26, Z+7	; 0x07
    23c4:	b0 85       	ldd	r27, Z+8	; 0x08
    23c6:	e5 cf       	rjmp	.-54     	; 0x2392 <vListInsert+0x44>

000023c8 <vListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    23c8:	cf 93       	push	r28
    23ca:	df 93       	push	r29
    23cc:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    23ce:	12 96       	adiw	r26, 0x02	; 2
    23d0:	ed 91       	ld	r30, X+
    23d2:	fc 91       	ld	r31, X
    23d4:	13 97       	sbiw	r26, 0x03	; 3
    23d6:	14 96       	adiw	r26, 0x04	; 4
    23d8:	8d 91       	ld	r24, X+
    23da:	9c 91       	ld	r25, X
    23dc:	15 97       	sbiw	r26, 0x05	; 5
    23de:	95 83       	std	Z+5, r25	; 0x05
    23e0:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    23e2:	14 96       	adiw	r26, 0x04	; 4
    23e4:	cd 91       	ld	r28, X+
    23e6:	dc 91       	ld	r29, X
    23e8:	15 97       	sbiw	r26, 0x05	; 5
    23ea:	fb 83       	std	Y+3, r31	; 0x03
    23ec:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    23ee:	18 96       	adiw	r26, 0x08	; 8
    23f0:	ed 91       	ld	r30, X+
    23f2:	fc 91       	ld	r31, X
    23f4:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    23f6:	81 81       	ldd	r24, Z+1	; 0x01
    23f8:	92 81       	ldd	r25, Z+2	; 0x02
    23fa:	8a 17       	cp	r24, r26
    23fc:	9b 07       	cpc	r25, r27
    23fe:	51 f0       	breq	.+20     	; 0x2414 <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	}

	pxItemToRemove->pvContainer = NULL;
    2400:	19 96       	adiw	r26, 0x09	; 9
    2402:	1c 92       	st	X, r1
    2404:	1e 92       	st	-X, r1
    2406:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    2408:	80 81       	ld	r24, Z
    240a:	81 50       	subi	r24, 0x01	; 1
    240c:	80 83       	st	Z, r24
}
    240e:	df 91       	pop	r29
    2410:	cf 91       	pop	r28
    2412:	08 95       	ret
	pxList = ( xList * ) pxItemToRemove->pvContainer;

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2414:	d2 83       	std	Z+2, r29	; 0x02
    2416:	c1 83       	std	Z+1, r28	; 0x01
    2418:	f3 cf       	rjmp	.-26     	; 0x2400 <vListRemove+0x38>

0000241a <main>:
		}

	}
}
int main ()
{
    241a:	af 92       	push	r10
    241c:	bf 92       	push	r11
    241e:	cf 92       	push	r12
    2420:	df 92       	push	r13
    2422:	ef 92       	push	r14
    2424:	ff 92       	push	r15
    2426:	0f 93       	push	r16
	UART_Init(UART_BAUDRATE_9600);
    2428:	87 e6       	ldi	r24, 0x67	; 103
    242a:	90 e0       	ldi	r25, 0x00	; 0
    242c:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <UART_Init>
	SSD_Init();
    2430:	0e 94 ef 12 	call	0x25de	; 0x25de <SSD_Init>
	LED_Init();
    2434:	0e 94 56 13 	call	0x26ac	; 0x26ac <LED_Init>
	Button_Init();
    2438:	0e 94 db 15 	call	0x2bb6	; 0x2bb6 <Button_Init>
	UART_TransmitStr((u8*)"Uart....\r\n");
    243c:	85 e6       	ldi	r24, 0x65	; 101
    243e:	90 e0       	ldi	r25, 0x00	; 0
    2440:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <UART_TransmitStr>

	 vSemaphoreCreateBinary(semaphore1);
    2444:	81 e0       	ldi	r24, 0x01	; 1
    2446:	60 e0       	ldi	r22, 0x00	; 0
    2448:	0e 94 24 0c 	call	0x1848	; 0x1848 <xQueueCreate>
    244c:	90 93 d4 04 	sts	0x04D4, r25
    2450:	80 93 d3 04 	sts	0x04D3, r24
    2454:	00 97       	sbiw	r24, 0x00	; 0
    2456:	39 f0       	breq	.+14     	; 0x2466 <main+0x4c>
    2458:	60 e0       	ldi	r22, 0x00	; 0
    245a:	70 e0       	ldi	r23, 0x00	; 0
    245c:	40 e0       	ldi	r20, 0x00	; 0
    245e:	50 e0       	ldi	r21, 0x00	; 0
    2460:	20 e0       	ldi	r18, 0x00	; 0
    2462:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xQueueGenericSend>
	 vSemaphoreCreateBinary(semaphore2);
    2466:	81 e0       	ldi	r24, 0x01	; 1
    2468:	60 e0       	ldi	r22, 0x00	; 0
    246a:	0e 94 24 0c 	call	0x1848	; 0x1848 <xQueueCreate>
    246e:	90 93 d6 04 	sts	0x04D6, r25
    2472:	80 93 d5 04 	sts	0x04D5, r24
    2476:	00 97       	sbiw	r24, 0x00	; 0
    2478:	39 f0       	breq	.+14     	; 0x2488 <main+0x6e>
    247a:	60 e0       	ldi	r22, 0x00	; 0
    247c:	70 e0       	ldi	r23, 0x00	; 0
    247e:	40 e0       	ldi	r20, 0x00	; 0
    2480:	50 e0       	ldi	r21, 0x00	; 0
    2482:	20 e0       	ldi	r18, 0x00	; 0
    2484:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xQueueGenericSend>
	(void)xTaskCreate(Task1,(u8*)"TASK1",100,NULL,1,NULL);
    2488:	8c e8       	ldi	r24, 0x8C	; 140
    248a:	92 e1       	ldi	r25, 0x12	; 18
    248c:	60 e7       	ldi	r22, 0x70	; 112
    248e:	70 e0       	ldi	r23, 0x00	; 0
    2490:	44 e6       	ldi	r20, 0x64	; 100
    2492:	50 e0       	ldi	r21, 0x00	; 0
    2494:	20 e0       	ldi	r18, 0x00	; 0
    2496:	30 e0       	ldi	r19, 0x00	; 0
    2498:	01 e0       	ldi	r16, 0x01	; 1
    249a:	ee 24       	eor	r14, r14
    249c:	ff 24       	eor	r15, r15
    249e:	cc 24       	eor	r12, r12
    24a0:	dd 24       	eor	r13, r13
    24a2:	aa 24       	eor	r10, r10
    24a4:	bb 24       	eor	r11, r11
    24a6:	0e 94 0e 10 	call	0x201c	; 0x201c <xTaskGenericCreate>
	(void)xTaskCreate(Task2,(u8*)"TASK2",100,NULL,1,NULL);
    24aa:	82 e6       	ldi	r24, 0x62	; 98
    24ac:	92 e1       	ldi	r25, 0x12	; 18
    24ae:	66 e7       	ldi	r22, 0x76	; 118
    24b0:	70 e0       	ldi	r23, 0x00	; 0
    24b2:	44 e6       	ldi	r20, 0x64	; 100
    24b4:	50 e0       	ldi	r21, 0x00	; 0
    24b6:	20 e0       	ldi	r18, 0x00	; 0
    24b8:	30 e0       	ldi	r19, 0x00	; 0
    24ba:	0e 94 0e 10 	call	0x201c	; 0x201c <xTaskGenericCreate>

		vTaskStartScheduler();
    24be:	0e 94 37 11 	call	0x226e	; 0x226e <vTaskStartScheduler>
    24c2:	ff cf       	rjmp	.-2      	; 0x24c2 <main+0xa8>

000024c4 <Task2>:
}
void Task2()
{
	while (1)
	{
		xSemaphoreTake(semaphore2,10);
    24c4:	80 91 d5 04 	lds	r24, 0x04D5
    24c8:	90 91 d6 04 	lds	r25, 0x04D6
    24cc:	60 e0       	ldi	r22, 0x00	; 0
    24ce:	70 e0       	ldi	r23, 0x00	; 0
    24d0:	4a e0       	ldi	r20, 0x0A	; 10
    24d2:	50 e0       	ldi	r21, 0x00	; 0
    24d4:	20 e0       	ldi	r18, 0x00	; 0
    24d6:	0e 94 a3 0a 	call	0x1546	; 0x1546 <xQueueGenericReceive>
		vTaskDelay(1000);
    24da:	88 ee       	ldi	r24, 0xE8	; 232
    24dc:	93 e0       	ldi	r25, 0x03	; 3
    24de:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <vTaskDelay>
		if (xSemaphoreTake(semaphore1,10) == pdPASS)
    24e2:	80 91 d3 04 	lds	r24, 0x04D3
    24e6:	90 91 d4 04 	lds	r25, 0x04D4
    24ea:	60 e0       	ldi	r22, 0x00	; 0
    24ec:	70 e0       	ldi	r23, 0x00	; 0
    24ee:	4a e0       	ldi	r20, 0x0A	; 10
    24f0:	50 e0       	ldi	r21, 0x00	; 0
    24f2:	20 e0       	ldi	r18, 0x00	; 0
    24f4:	0e 94 a3 0a 	call	0x1546	; 0x1546 <xQueueGenericReceive>
    24f8:	81 30       	cpi	r24, 0x01	; 1
    24fa:	21 f7       	brne	.-56     	; 0x24c4 <Task2>
		{
			LED_TOGGLE(LED1);
    24fc:	0e 94 0e 13 	call	0x261c	; 0x261c <LED_TOGGLE>
			xSemaphoreGive(semaphore2);
    2500:	80 91 d5 04 	lds	r24, 0x04D5
    2504:	90 91 d6 04 	lds	r25, 0x04D6
    2508:	60 e0       	ldi	r22, 0x00	; 0
    250a:	70 e0       	ldi	r23, 0x00	; 0
    250c:	40 e0       	ldi	r20, 0x00	; 0
    250e:	50 e0       	ldi	r21, 0x00	; 0
    2510:	20 e0       	ldi	r18, 0x00	; 0
    2512:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xQueueGenericSend>
    2516:	d6 cf       	rjmp	.-84     	; 0x24c4 <Task2>

00002518 <Task1>:

void Task1()
{
	while (1)
	{
		xSemaphoreTake(semaphore1,10);
    2518:	80 91 d3 04 	lds	r24, 0x04D3
    251c:	90 91 d4 04 	lds	r25, 0x04D4
    2520:	60 e0       	ldi	r22, 0x00	; 0
    2522:	70 e0       	ldi	r23, 0x00	; 0
    2524:	4a e0       	ldi	r20, 0x0A	; 10
    2526:	50 e0       	ldi	r21, 0x00	; 0
    2528:	20 e0       	ldi	r18, 0x00	; 0
    252a:	0e 94 a3 0a 	call	0x1546	; 0x1546 <xQueueGenericReceive>
		vTaskDelay(1000);
    252e:	88 ee       	ldi	r24, 0xE8	; 232
    2530:	93 e0       	ldi	r25, 0x03	; 3
    2532:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <vTaskDelay>
		if (xSemaphoreTake(semaphore2,10) == pdPASS)
    2536:	80 91 d5 04 	lds	r24, 0x04D5
    253a:	90 91 d6 04 	lds	r25, 0x04D6
    253e:	60 e0       	ldi	r22, 0x00	; 0
    2540:	70 e0       	ldi	r23, 0x00	; 0
    2542:	4a e0       	ldi	r20, 0x0A	; 10
    2544:	50 e0       	ldi	r21, 0x00	; 0
    2546:	20 e0       	ldi	r18, 0x00	; 0
    2548:	0e 94 a3 0a 	call	0x1546	; 0x1546 <xQueueGenericReceive>
    254c:	81 30       	cpi	r24, 0x01	; 1
    254e:	21 f7       	brne	.-56     	; 0x2518 <Task1>
		{
			LED_TOGGLE(LED0);
    2550:	80 e0       	ldi	r24, 0x00	; 0
    2552:	0e 94 0e 13 	call	0x261c	; 0x261c <LED_TOGGLE>
			xSemaphoreGive(semaphore1);
    2556:	80 91 d3 04 	lds	r24, 0x04D3
    255a:	90 91 d4 04 	lds	r25, 0x04D4
    255e:	60 e0       	ldi	r22, 0x00	; 0
    2560:	70 e0       	ldi	r23, 0x00	; 0
    2562:	40 e0       	ldi	r20, 0x00	; 0
    2564:	50 e0       	ldi	r21, 0x00	; 0
    2566:	20 e0       	ldi	r18, 0x00	; 0
    2568:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xQueueGenericSend>
    256c:	d5 cf       	rjmp	.-86     	; 0x2518 <Task1>

0000256e <SSD_DisplayNumber>:
}


/*	This Function Shall Be Called Periodically Every 1 ms	*/
void SSD_DisplayNumber(u8 num)
{
    256e:	1f 93       	push	r17
    2570:	18 2f       	mov	r17, r24
	static boolean loc_oneDigit = TRUE;
	u8 loc_FirstDigit = (num/10)<<4;
	u8 loc_Second_Digit = (num%10)<<4;

	if (loc_oneDigit == TRUE)
    2572:	80 91 86 01 	lds	r24, 0x0186
    2576:	81 30       	cpi	r24, 0x01	; 1
    2578:	d1 f0       	breq	.+52     	; 0x25ae <SSD_DisplayNumber+0x40>
		loc_oneDigit = FALSE;
	}
	else
	{
		/*	Disable SSD1	*/
		Dio_WriteChannel(DIO_PORTB, DIO_PIN2, STD_LOW);
    257a:	81 e0       	ldi	r24, 0x01	; 1
    257c:	62 e0       	ldi	r22, 0x02	; 2
    257e:	40 e0       	ldi	r20, 0x00	; 0
    2580:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
		/*	Enable SSD2	*/
		Dio_WriteChannel(DIO_PORTB, DIO_PIN1, STD_HIGH);
    2584:	81 e0       	ldi	r24, 0x01	; 1
    2586:	61 e0       	ldi	r22, 0x01	; 1
    2588:	41 e0       	ldi	r20, 0x01	; 1
    258a:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
		/*	Write Number To SSD	*/
		Dio_WriteGroup(DIO_PORTA,SSD_MASK,loc_Second_Digit);
    258e:	81 2f       	mov	r24, r17
    2590:	6a e0       	ldi	r22, 0x0A	; 10
    2592:	0e 94 1d 19 	call	0x323a	; 0x323a <__udivmodqi4>
    2596:	92 95       	swap	r25
    2598:	90 7f       	andi	r25, 0xF0	; 240
    259a:	80 e0       	ldi	r24, 0x00	; 0
    259c:	60 ef       	ldi	r22, 0xF0	; 240
    259e:	49 2f       	mov	r20, r25
    25a0:	0e 94 61 18 	call	0x30c2	; 0x30c2 <Dio_WriteGroup>

		loc_oneDigit = TRUE;
    25a4:	81 e0       	ldi	r24, 0x01	; 1
    25a6:	80 93 86 01 	sts	0x0186, r24
	}
}
    25aa:	1f 91       	pop	r17
    25ac:	08 95       	ret
	u8 loc_Second_Digit = (num%10)<<4;

	if (loc_oneDigit == TRUE)
	{
		/*	Enable SSD1	*/
		Dio_WriteChannel(DIO_PORTB, DIO_PIN2, STD_HIGH);
    25ae:	62 e0       	ldi	r22, 0x02	; 2
    25b0:	41 e0       	ldi	r20, 0x01	; 1
    25b2:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
		/*	Disable SSD2	*/
		Dio_WriteChannel(DIO_PORTB, DIO_PIN1, STD_LOW);
    25b6:	81 e0       	ldi	r24, 0x01	; 1
    25b8:	61 e0       	ldi	r22, 0x01	; 1
    25ba:	40 e0       	ldi	r20, 0x00	; 0
    25bc:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
		/*	Write Number To SSD	*/
		Dio_WriteGroup(DIO_PORTA,SSD_MASK,loc_FirstDigit);
    25c0:	81 2f       	mov	r24, r17
    25c2:	6a e0       	ldi	r22, 0x0A	; 10
    25c4:	0e 94 1d 19 	call	0x323a	; 0x323a <__udivmodqi4>
    25c8:	48 2f       	mov	r20, r24
    25ca:	42 95       	swap	r20
    25cc:	40 7f       	andi	r20, 0xF0	; 240
    25ce:	80 e0       	ldi	r24, 0x00	; 0
    25d0:	60 ef       	ldi	r22, 0xF0	; 240
    25d2:	0e 94 61 18 	call	0x30c2	; 0x30c2 <Dio_WriteGroup>

		loc_oneDigit = FALSE;
    25d6:	10 92 86 01 	sts	0x0186, r1
		/*	Write Number To SSD	*/
		Dio_WriteGroup(DIO_PORTA,SSD_MASK,loc_Second_Digit);

		loc_oneDigit = TRUE;
	}
}
    25da:	1f 91       	pop	r17
    25dc:	08 95       	ret

000025de <SSD_Init>:
 */
#include "SSD.h"
void SSD_Init(void)
{
	/*	Configure Data Lines As Output	*/
	Dio_ConfigChannel(DIO_PORTA,DIO_PIN4,OUTPUT);
    25de:	80 e0       	ldi	r24, 0x00	; 0
    25e0:	64 e0       	ldi	r22, 0x04	; 4
    25e2:	41 e0       	ldi	r20, 0x01	; 1
    25e4:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(DIO_PORTA,DIO_PIN5,OUTPUT);
    25e8:	80 e0       	ldi	r24, 0x00	; 0
    25ea:	65 e0       	ldi	r22, 0x05	; 5
    25ec:	41 e0       	ldi	r20, 0x01	; 1
    25ee:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(DIO_PORTA,DIO_PIN6,OUTPUT);
    25f2:	80 e0       	ldi	r24, 0x00	; 0
    25f4:	66 e0       	ldi	r22, 0x06	; 6
    25f6:	41 e0       	ldi	r20, 0x01	; 1
    25f8:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(DIO_PORTA,DIO_PIN7,OUTPUT);
    25fc:	80 e0       	ldi	r24, 0x00	; 0
    25fe:	67 e0       	ldi	r22, 0x07	; 7
    2600:	41 e0       	ldi	r20, 0x01	; 1
    2602:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>

	/*	Configure Control Lines As Output	*/
	Dio_ConfigChannel(DIO_PORTB,DIO_PIN1,OUTPUT);
    2606:	81 e0       	ldi	r24, 0x01	; 1
    2608:	61 e0       	ldi	r22, 0x01	; 1
    260a:	41 e0       	ldi	r20, 0x01	; 1
    260c:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(DIO_PORTB,DIO_PIN2,OUTPUT);
    2610:	81 e0       	ldi	r24, 0x01	; 1
    2612:	62 e0       	ldi	r22, 0x02	; 2
    2614:	41 e0       	ldi	r20, 0x01	; 1
    2616:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
}
    261a:	08 95       	ret

0000261c <LED_TOGGLE>:
		break;
	}
}
void LED_TOGGLE(led_type ledId)
{
	switch (ledId)
    261c:	81 30       	cpi	r24, 0x01	; 1
    261e:	79 f0       	breq	.+30     	; 0x263e <LED_TOGGLE+0x22>
    2620:	81 30       	cpi	r24, 0x01	; 1
    2622:	28 f4       	brcc	.+10     	; 0x262e <LED_TOGGLE+0x12>
	{
	case LED0:
		Dio_TogglChannel(LED0_PORT,LED0_PIN);
    2624:	82 e0       	ldi	r24, 0x02	; 2
    2626:	62 e0       	ldi	r22, 0x02	; 2
    2628:	0e 94 86 18 	call	0x310c	; 0x310c <Dio_TogglChannel>
    262c:	08 95       	ret
		break;
	}
}
void LED_TOGGLE(led_type ledId)
{
	switch (ledId)
    262e:	82 30       	cpi	r24, 0x02	; 2
    2630:	09 f0       	breq	.+2      	; 0x2634 <LED_TOGGLE+0x18>
    2632:	08 95       	ret
	case LED1:
		Dio_TogglChannel(LED1_PORT,LED1_PIN);
		break;

	case LED2:
		Dio_TogglChannel(LED2_PORT,LED2_PIN);
    2634:	83 e0       	ldi	r24, 0x03	; 3
    2636:	63 e0       	ldi	r22, 0x03	; 3
    2638:	0e 94 86 18 	call	0x310c	; 0x310c <Dio_TogglChannel>
    263c:	08 95       	ret
	case LED0:
		Dio_TogglChannel(LED0_PORT,LED0_PIN);
		break;

	case LED1:
		Dio_TogglChannel(LED1_PORT,LED1_PIN);
    263e:	82 e0       	ldi	r24, 0x02	; 2
    2640:	67 e0       	ldi	r22, 0x07	; 7
    2642:	0e 94 86 18 	call	0x310c	; 0x310c <Dio_TogglChannel>
    2646:	08 95       	ret

00002648 <LED_OFF>:
	}
}

void LED_OFF(led_type ledId)
{
	switch (ledId)
    2648:	81 30       	cpi	r24, 0x01	; 1
    264a:	89 f0       	breq	.+34     	; 0x266e <LED_OFF+0x26>
    264c:	81 30       	cpi	r24, 0x01	; 1
    264e:	30 f4       	brcc	.+12     	; 0x265c <LED_OFF+0x14>
	{
	case LED0:
		Dio_WriteChannel(LED0_PORT,LED0_PIN,STD_LOW);
    2650:	82 e0       	ldi	r24, 0x02	; 2
    2652:	62 e0       	ldi	r22, 0x02	; 2
    2654:	40 e0       	ldi	r20, 0x00	; 0
    2656:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
    265a:	08 95       	ret
	}
}

void LED_OFF(led_type ledId)
{
	switch (ledId)
    265c:	82 30       	cpi	r24, 0x02	; 2
    265e:	09 f0       	breq	.+2      	; 0x2662 <LED_OFF+0x1a>
    2660:	08 95       	ret
	case LED1:
		Dio_WriteChannel(LED1_PORT,LED1_PIN,STD_LOW);
		break;

	case LED2:
		Dio_WriteChannel(LED2_PORT,LED2_PIN,STD_LOW);
    2662:	83 e0       	ldi	r24, 0x03	; 3
    2664:	63 e0       	ldi	r22, 0x03	; 3
    2666:	40 e0       	ldi	r20, 0x00	; 0
    2668:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
    266c:	08 95       	ret
	case LED0:
		Dio_WriteChannel(LED0_PORT,LED0_PIN,STD_LOW);
		break;

	case LED1:
		Dio_WriteChannel(LED1_PORT,LED1_PIN,STD_LOW);
    266e:	82 e0       	ldi	r24, 0x02	; 2
    2670:	67 e0       	ldi	r22, 0x07	; 7
    2672:	40 e0       	ldi	r20, 0x00	; 0
    2674:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
    2678:	08 95       	ret

0000267a <LED_ON>:
	Dio_ConfigChannel(LED2_PORT,LED2_PIN,OUTPUT);
}

void LED_ON(led_type ledId)
{
	switch (ledId)
    267a:	81 30       	cpi	r24, 0x01	; 1
    267c:	89 f0       	breq	.+34     	; 0x26a0 <LED_ON+0x26>
    267e:	81 30       	cpi	r24, 0x01	; 1
    2680:	30 f4       	brcc	.+12     	; 0x268e <LED_ON+0x14>
	{
	case LED0:
		Dio_WriteChannel(LED0_PORT,LED0_PIN,STD_HIGH);
    2682:	82 e0       	ldi	r24, 0x02	; 2
    2684:	62 e0       	ldi	r22, 0x02	; 2
    2686:	41 e0       	ldi	r20, 0x01	; 1
    2688:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
    268c:	08 95       	ret
	Dio_ConfigChannel(LED2_PORT,LED2_PIN,OUTPUT);
}

void LED_ON(led_type ledId)
{
	switch (ledId)
    268e:	82 30       	cpi	r24, 0x02	; 2
    2690:	09 f0       	breq	.+2      	; 0x2694 <LED_ON+0x1a>
    2692:	08 95       	ret
	case LED1:
		Dio_WriteChannel(LED1_PORT,LED1_PIN,STD_HIGH);
		break;

	case LED2:
		Dio_WriteChannel(LED2_PORT,LED2_PIN,STD_HIGH);
    2694:	83 e0       	ldi	r24, 0x03	; 3
    2696:	63 e0       	ldi	r22, 0x03	; 3
    2698:	41 e0       	ldi	r20, 0x01	; 1
    269a:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
    269e:	08 95       	ret
	case LED0:
		Dio_WriteChannel(LED0_PORT,LED0_PIN,STD_HIGH);
		break;

	case LED1:
		Dio_WriteChannel(LED1_PORT,LED1_PIN,STD_HIGH);
    26a0:	82 e0       	ldi	r24, 0x02	; 2
    26a2:	67 e0       	ldi	r22, 0x07	; 7
    26a4:	41 e0       	ldi	r20, 0x01	; 1
    26a6:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
    26aa:	08 95       	ret

000026ac <LED_Init>:

#include "Led.h"

void LED_Init(void)
{
	Dio_ConfigChannel(LED0_PORT,LED0_PIN,OUTPUT);
    26ac:	82 e0       	ldi	r24, 0x02	; 2
    26ae:	62 e0       	ldi	r22, 0x02	; 2
    26b0:	41 e0       	ldi	r20, 0x01	; 1
    26b2:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(LED1_PORT,LED1_PIN,OUTPUT);
    26b6:	82 e0       	ldi	r24, 0x02	; 2
    26b8:	67 e0       	ldi	r22, 0x07	; 7
    26ba:	41 e0       	ldi	r20, 0x01	; 1
    26bc:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(LED2_PORT,LED2_PIN,OUTPUT);
    26c0:	83 e0       	ldi	r24, 0x03	; 3
    26c2:	63 e0       	ldi	r22, 0x03	; 3
    26c4:	41 e0       	ldi	r20, 0x01	; 1
    26c6:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
}
    26ca:	08 95       	ret

000026cc <Enable_Pulse>:
	Lcd_Goto_Row_Column(0,0);
	Lcd_Cmd(_LCD_CURSOR_OFF);
}
static void Enable_Pulse(void)
{
	Dio_WriteChannel(DIO_PORTB, DIO_PIN3, STD_HIGH);
    26cc:	81 e0       	ldi	r24, 0x01	; 1
    26ce:	63 e0       	ldi	r22, 0x03	; 3
    26d0:	41 e0       	ldi	r20, 0x01	; 1
    26d2:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    26d6:	85 e0       	ldi	r24, 0x05	; 5
    26d8:	8a 95       	dec	r24
    26da:	f1 f7       	brne	.-4      	; 0x26d8 <Enable_Pulse+0xc>
	_delay_us(1);
	Dio_WriteChannel(DIO_PORTB, DIO_PIN3, STD_LOW);
    26dc:	81 e0       	ldi	r24, 0x01	; 1
    26de:	63 e0       	ldi	r22, 0x03	; 3
    26e0:	40 e0       	ldi	r20, 0x00	; 0
    26e2:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    26e6:	80 e4       	ldi	r24, 0x40	; 64
    26e8:	9f e1       	ldi	r25, 0x1F	; 31
    26ea:	01 97       	sbiw	r24, 0x01	; 1
    26ec:	f1 f7       	brne	.-4      	; 0x26ea <Enable_Pulse+0x1e>
	_delay_ms(2);
}
    26ee:	08 95       	ret

000026f0 <Lcd_DisplayChr>:
	Dio_WriteGroup(DIO_PORTA,LCD_MASK,Low_Nibble);
	Enable_Pulse();
}

void Lcd_DisplayChr(u8 chr)
{
    26f0:	1f 93       	push	r17
    26f2:	18 2f       	mov	r17, r24

static void Lcd_Data(u8 data) /*	RS-> 1	*/
{
	u8 High_Nibble = data;    /*	MSB	*/
	u8 Low_Nibble = data<<4;		/*	LSB	*/
	Dio_WriteChannel(DIO_PORTB, DIO_PIN1, STD_HIGH);   /* Data Mode */
    26f4:	81 e0       	ldi	r24, 0x01	; 1
    26f6:	61 e0       	ldi	r22, 0x01	; 1
    26f8:	41 e0       	ldi	r20, 0x01	; 1
    26fa:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
	Dio_WriteGroup(DIO_PORTA,LCD_MASK,High_Nibble);
    26fe:	80 e0       	ldi	r24, 0x00	; 0
    2700:	60 ef       	ldi	r22, 0xF0	; 240
    2702:	41 2f       	mov	r20, r17
    2704:	0e 94 61 18 	call	0x30c2	; 0x30c2 <Dio_WriteGroup>
	Enable_Pulse();
    2708:	0e 94 66 13 	call	0x26cc	; 0x26cc <Enable_Pulse>

	Dio_WriteGroup(DIO_PORTA,LCD_MASK,Low_Nibble);
    270c:	12 95       	swap	r17
    270e:	10 7f       	andi	r17, 0xF0	; 240
    2710:	80 e0       	ldi	r24, 0x00	; 0
    2712:	60 ef       	ldi	r22, 0xF0	; 240
    2714:	41 2f       	mov	r20, r17
    2716:	0e 94 61 18 	call	0x30c2	; 0x30c2 <Dio_WriteGroup>
	Enable_Pulse();
    271a:	0e 94 66 13 	call	0x26cc	; 0x26cc <Enable_Pulse>
}

void Lcd_DisplayChr(u8 chr)
{
	Lcd_Data(chr);
}
    271e:	1f 91       	pop	r17
    2720:	08 95       	ret

00002722 <Lcd_DisplayNum>:
		break;
	}
}

void Lcd_DisplayNum(u16 num)
{
    2722:	0f 93       	push	r16
    2724:	1f 93       	push	r17
    2726:	8c 01       	movw	r16, r24
	Lcd_DisplayChr(num/1000 + '0');
    2728:	68 ee       	ldi	r22, 0xE8	; 232
    272a:	73 e0       	ldi	r23, 0x03	; 3
    272c:	0e 94 29 19 	call	0x3252	; 0x3252 <__udivmodhi4>
    2730:	86 2f       	mov	r24, r22
    2732:	80 5d       	subi	r24, 0xD0	; 208
    2734:	0e 94 78 13 	call	0x26f0	; 0x26f0 <Lcd_DisplayChr>
	Lcd_DisplayChr(num%1000/100 + '0');
    2738:	c8 01       	movw	r24, r16
    273a:	68 ee       	ldi	r22, 0xE8	; 232
    273c:	73 e0       	ldi	r23, 0x03	; 3
    273e:	0e 94 29 19 	call	0x3252	; 0x3252 <__udivmodhi4>
    2742:	18 2f       	mov	r17, r24
    2744:	09 2f       	mov	r16, r25
    2746:	64 e6       	ldi	r22, 0x64	; 100
    2748:	70 e0       	ldi	r23, 0x00	; 0
    274a:	0e 94 29 19 	call	0x3252	; 0x3252 <__udivmodhi4>
    274e:	86 2f       	mov	r24, r22
    2750:	80 5d       	subi	r24, 0xD0	; 208
    2752:	0e 94 78 13 	call	0x26f0	; 0x26f0 <Lcd_DisplayChr>
	Lcd_DisplayChr(num%1000%100/10 + '0');
    2756:	81 2f       	mov	r24, r17
    2758:	90 2f       	mov	r25, r16
    275a:	64 e6       	ldi	r22, 0x64	; 100
    275c:	70 e0       	ldi	r23, 0x00	; 0
    275e:	0e 94 29 19 	call	0x3252	; 0x3252 <__udivmodhi4>
    2762:	18 2f       	mov	r17, r24
    2764:	09 2f       	mov	r16, r25
    2766:	6a e0       	ldi	r22, 0x0A	; 10
    2768:	70 e0       	ldi	r23, 0x00	; 0
    276a:	0e 94 29 19 	call	0x3252	; 0x3252 <__udivmodhi4>
    276e:	86 2f       	mov	r24, r22
    2770:	80 5d       	subi	r24, 0xD0	; 208
    2772:	0e 94 78 13 	call	0x26f0	; 0x26f0 <Lcd_DisplayChr>
	Lcd_DisplayChr(num%1000%100%10 + '0');
    2776:	81 2f       	mov	r24, r17
    2778:	90 2f       	mov	r25, r16
    277a:	6a e0       	ldi	r22, 0x0A	; 10
    277c:	70 e0       	ldi	r23, 0x00	; 0
    277e:	0e 94 29 19 	call	0x3252	; 0x3252 <__udivmodhi4>
    2782:	80 5d       	subi	r24, 0xD0	; 208
    2784:	0e 94 78 13 	call	0x26f0	; 0x26f0 <Lcd_DisplayChr>
}
    2788:	1f 91       	pop	r17
    278a:	0f 91       	pop	r16
    278c:	08 95       	ret

0000278e <LcdDisplayFloat>:

void LcdDisplayFloat(f64 floatNum)
{
    278e:	af 92       	push	r10
    2790:	bf 92       	push	r11
    2792:	cf 92       	push	r12
    2794:	df 92       	push	r13
    2796:	ef 92       	push	r14
    2798:	ff 92       	push	r15
    279a:	0f 93       	push	r16
    279c:	1f 93       	push	r17
    279e:	5b 01       	movw	r10, r22
    27a0:	6c 01       	movw	r12, r24
	u16 intPart = 0;
	f64 fractionTemp = 0;
	u16 fractionPart = 0;

	intPart = (u16)floatNum;
    27a2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    27a6:	dc 01       	movw	r26, r24
    27a8:	cb 01       	movw	r24, r22
    27aa:	7c 01       	movw	r14, r24
	fractionTemp = floatNum - intPart;
	fractionPart = fractionTemp * 100;

	Lcd_DisplayNum(intPart);
    27ac:	0e 94 91 13 	call	0x2722	; 0x2722 <Lcd_DisplayNum>
	Lcd_DisplayChr('.');
    27b0:	8e e2       	ldi	r24, 0x2E	; 46
    27b2:	0e 94 78 13 	call	0x26f0	; 0x26f0 <Lcd_DisplayChr>
	Lcd_DisplayNum(fractionPart);
    27b6:	00 e0       	ldi	r16, 0x00	; 0
    27b8:	10 e0       	ldi	r17, 0x00	; 0
    27ba:	c8 01       	movw	r24, r16
    27bc:	b7 01       	movw	r22, r14
    27be:	0e 94 9d 03 	call	0x73a	; 0x73a <__floatunsisf>
    27c2:	9b 01       	movw	r18, r22
    27c4:	ac 01       	movw	r20, r24
    27c6:	c6 01       	movw	r24, r12
    27c8:	b5 01       	movw	r22, r10
    27ca:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    27ce:	20 e0       	ldi	r18, 0x00	; 0
    27d0:	30 e0       	ldi	r19, 0x00	; 0
    27d2:	48 ec       	ldi	r20, 0xC8	; 200
    27d4:	52 e4       	ldi	r21, 0x42	; 66
    27d6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27da:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    27de:	dc 01       	movw	r26, r24
    27e0:	cb 01       	movw	r24, r22
    27e2:	0e 94 91 13 	call	0x2722	; 0x2722 <Lcd_DisplayNum>
}
    27e6:	1f 91       	pop	r17
    27e8:	0f 91       	pop	r16
    27ea:	ff 90       	pop	r15
    27ec:	ef 90       	pop	r14
    27ee:	df 90       	pop	r13
    27f0:	cf 90       	pop	r12
    27f2:	bf 90       	pop	r11
    27f4:	af 90       	pop	r10
    27f6:	08 95       	ret

000027f8 <Lcd_DisplayStr>:
{
	Lcd_Data(chr);
}

void Lcd_DisplayStr(u8* str)
{
    27f8:	cf 93       	push	r28
    27fa:	df 93       	push	r29
    27fc:	ec 01       	movw	r28, r24
	while (*str != '\0')
    27fe:	88 81       	ld	r24, Y
    2800:	88 23       	and	r24, r24
    2802:	31 f0       	breq	.+12     	; 0x2810 <Lcd_DisplayStr+0x18>
	{
		Lcd_DisplayChr(*str);
    2804:	0e 94 78 13 	call	0x26f0	; 0x26f0 <Lcd_DisplayChr>
		str++;
    2808:	21 96       	adiw	r28, 0x01	; 1
	Lcd_Data(chr);
}

void Lcd_DisplayStr(u8* str)
{
	while (*str != '\0')
    280a:	88 81       	ld	r24, Y
    280c:	88 23       	and	r24, r24
    280e:	d1 f7       	brne	.-12     	; 0x2804 <Lcd_DisplayStr+0xc>
	{
		Lcd_DisplayChr(*str);
		str++;
	}
}
    2810:	df 91       	pop	r29
    2812:	cf 91       	pop	r28
    2814:	08 95       	ret

00002816 <Lcd_Cmd>:
	Dio_WriteGroup(DIO_PORTA,LCD_MASK,Low_Nibble);
	Enable_Pulse();
}

void Lcd_Cmd(lcd_Cmd_Type cmd)/*	RS-> 0	*/
{
    2816:	1f 93       	push	r17
    2818:	18 2f       	mov	r17, r24
	u8 High_Nibble = cmd;    /*	MSB	*/
	u8 Low_Nibble = cmd<<4;		/*	LSB	*/
	Dio_WriteChannel(DIO_PORTB, DIO_PIN1, STD_LOW);   /* Command Mode */
    281a:	81 e0       	ldi	r24, 0x01	; 1
    281c:	61 e0       	ldi	r22, 0x01	; 1
    281e:	40 e0       	ldi	r20, 0x00	; 0
    2820:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
	Dio_WriteGroup(DIO_PORTA,LCD_MASK,High_Nibble);
    2824:	80 e0       	ldi	r24, 0x00	; 0
    2826:	60 ef       	ldi	r22, 0xF0	; 240
    2828:	41 2f       	mov	r20, r17
    282a:	0e 94 61 18 	call	0x30c2	; 0x30c2 <Dio_WriteGroup>
	Enable_Pulse();
    282e:	0e 94 66 13 	call	0x26cc	; 0x26cc <Enable_Pulse>

	Dio_WriteGroup(DIO_PORTA,LCD_MASK,Low_Nibble);
    2832:	12 95       	swap	r17
    2834:	10 7f       	andi	r17, 0xF0	; 240
    2836:	80 e0       	ldi	r24, 0x00	; 0
    2838:	60 ef       	ldi	r22, 0xF0	; 240
    283a:	41 2f       	mov	r20, r17
    283c:	0e 94 61 18 	call	0x30c2	; 0x30c2 <Dio_WriteGroup>
	Enable_Pulse();
    2840:	0e 94 66 13 	call	0x26cc	; 0x26cc <Enable_Pulse>
}
    2844:	1f 91       	pop	r17
    2846:	08 95       	ret

00002848 <Lcd_Goto_Row_Column>:
	}
}

void Lcd_Goto_Row_Column(u8 row, u8 col)
{
	switch (row)
    2848:	88 23       	and	r24, r24
    284a:	29 f4       	brne	.+10     	; 0x2856 <Lcd_Goto_Row_Column+0xe>
	{
	case 0:
		Lcd_Cmd(0x80+col);
    284c:	86 2f       	mov	r24, r22
    284e:	80 58       	subi	r24, 0x80	; 128
    2850:	0e 94 0b 14 	call	0x2816	; 0x2816 <Lcd_Cmd>
    2854:	08 95       	ret
	}
}

void Lcd_Goto_Row_Column(u8 row, u8 col)
{
	switch (row)
    2856:	81 30       	cpi	r24, 0x01	; 1
    2858:	09 f0       	breq	.+2      	; 0x285c <Lcd_Goto_Row_Column+0x14>
    285a:	08 95       	ret
	case 0:
		Lcd_Cmd(0x80+col);
		break;

	case 1:
		Lcd_Cmd(0xC0+col);
    285c:	86 2f       	mov	r24, r22
    285e:	80 54       	subi	r24, 0x40	; 64
    2860:	0e 94 0b 14 	call	0x2816	; 0x2816 <Lcd_Cmd>
    2864:	08 95       	ret

00002866 <Lcd_Init>:
			}
	}
}

void Lcd_Init(void)
{
    2866:	cf 92       	push	r12
    2868:	df 92       	push	r13
    286a:	ef 92       	push	r14
    286c:	ff 92       	push	r15
    286e:	1f 93       	push	r17
    2870:	cf 93       	push	r28
    2872:	df 93       	push	r29
	/*	Configure Data Lines As Output	*/
	Dio_ConfigChannel(DIO_PORTA,DIO_PIN4,OUTPUT);
    2874:	80 e0       	ldi	r24, 0x00	; 0
    2876:	64 e0       	ldi	r22, 0x04	; 4
    2878:	41 e0       	ldi	r20, 0x01	; 1
    287a:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(DIO_PORTA,DIO_PIN5,OUTPUT);
    287e:	80 e0       	ldi	r24, 0x00	; 0
    2880:	65 e0       	ldi	r22, 0x05	; 5
    2882:	41 e0       	ldi	r20, 0x01	; 1
    2884:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(DIO_PORTA,DIO_PIN6,OUTPUT);
    2888:	80 e0       	ldi	r24, 0x00	; 0
    288a:	66 e0       	ldi	r22, 0x06	; 6
    288c:	41 e0       	ldi	r20, 0x01	; 1
    288e:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(DIO_PORTA,DIO_PIN7,OUTPUT);
    2892:	80 e0       	ldi	r24, 0x00	; 0
    2894:	67 e0       	ldi	r22, 0x07	; 7
    2896:	41 e0       	ldi	r20, 0x01	; 1
    2898:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>

	/*	Configure Control Lines As Output	*/
	Dio_ConfigChannel(DIO_PORTB,DIO_PIN1,OUTPUT);   /*	RS	*/
    289c:	81 e0       	ldi	r24, 0x01	; 1
    289e:	61 e0       	ldi	r22, 0x01	; 1
    28a0:	41 e0       	ldi	r20, 0x01	; 1
    28a2:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(DIO_PORTB,DIO_PIN2,OUTPUT);	/*	RW	*/
    28a6:	81 e0       	ldi	r24, 0x01	; 1
    28a8:	62 e0       	ldi	r22, 0x02	; 2
    28aa:	41 e0       	ldi	r20, 0x01	; 1
    28ac:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(DIO_PORTB,DIO_PIN3,OUTPUT);	/*	En	*/
    28b0:	81 e0       	ldi	r24, 0x01	; 1
    28b2:	63 e0       	ldi	r22, 0x03	; 3
    28b4:	41 e0       	ldi	r20, 0x01	; 1
    28b6:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>

	Dio_WriteChannel(DIO_PORTB, DIO_PIN2, STD_LOW);
    28ba:	81 e0       	ldi	r24, 0x01	; 1
    28bc:	62 e0       	ldi	r22, 0x02	; 2
    28be:	40 e0       	ldi	r20, 0x00	; 0
    28c0:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
    28c4:	80 e6       	ldi	r24, 0x60	; 96
    28c6:	9a ee       	ldi	r25, 0xEA	; 234
    28c8:	01 97       	sbiw	r24, 0x01	; 1
    28ca:	f1 f7       	brne	.-4      	; 0x28c8 <Lcd_Init+0x62>

	_delay_ms(15);

	Lcd_Cmd(3);
    28cc:	83 e0       	ldi	r24, 0x03	; 3
    28ce:	0e 94 0b 14 	call	0x2816	; 0x2816 <Lcd_Cmd>
    28d2:	80 e2       	ldi	r24, 0x20	; 32
    28d4:	9e e4       	ldi	r25, 0x4E	; 78
    28d6:	01 97       	sbiw	r24, 0x01	; 1
    28d8:	f1 f7       	brne	.-4      	; 0x28d6 <Lcd_Init+0x70>
	_delay_ms(5);
	Lcd_Cmd(3);
    28da:	83 e0       	ldi	r24, 0x03	; 3
    28dc:	0e 94 0b 14 	call	0x2816	; 0x2816 <Lcd_Cmd>
    28e0:	80 e9       	ldi	r24, 0x90	; 144
    28e2:	91 e0       	ldi	r25, 0x01	; 1
    28e4:	01 97       	sbiw	r24, 0x01	; 1
    28e6:	f1 f7       	brne	.-4      	; 0x28e4 <Lcd_Init+0x7e>
	_delay_us(100);
	Lcd_Cmd(3);
    28e8:	83 e0       	ldi	r24, 0x03	; 3
    28ea:	0e 94 0b 14 	call	0x2816	; 0x2816 <Lcd_Cmd>
	Lcd_Cmd(2);
    28ee:	82 e0       	ldi	r24, 0x02	; 2
    28f0:	0e 94 0b 14 	call	0x2816	; 0x2816 <Lcd_Cmd>
	Lcd_Cmd(_LCD_4BIT_MODE);
    28f4:	88 e2       	ldi	r24, 0x28	; 40
    28f6:	0e 94 0b 14 	call	0x2816	; 0x2816 <Lcd_Cmd>
    28fa:	ee 24       	eor	r14, r14
    28fc:	ff 24       	eor	r15, r15
    28fe:	90 e4       	ldi	r25, 0x40	; 64
    2900:	c9 2e       	mov	r12, r25
    2902:	d1 2c       	mov	r13, r1
{
	u8 loc_ByteIndex=0;
	u8 loc_CharIndx=0;
	for (loc_CharIndx=0;loc_CharIndx<NO_CSTOM_CHAR;loc_CharIndx++)
	{
		Lcd_Cmd(_LCD_CGRAM_START_ADDRESS +(loc_CharIndx*8));
    2904:	8c 2d       	mov	r24, r12
    2906:	0e 94 0b 14 	call	0x2816	; 0x2816 <Lcd_Cmd>
    290a:	e7 01       	movw	r28, r14
    290c:	cc 0f       	add	r28, r28
    290e:	dd 1f       	adc	r29, r29
    2910:	cc 0f       	add	r28, r28
    2912:	dd 1f       	adc	r29, r29
    2914:	cc 0f       	add	r28, r28
    2916:	dd 1f       	adc	r29, r29
    2918:	c9 57       	subi	r28, 0x79	; 121
    291a:	de 4f       	sbci	r29, 0xFE	; 254
    291c:	10 e0       	ldi	r17, 0x00	; 0
			for (loc_ByteIndex =0; loc_ByteIndex<NO_CSTOM_CHAR_BYTES;loc_ByteIndex++)
			{
				Lcd_DisplayChr(customChar[loc_CharIndx][loc_ByteIndex]);
    291e:	89 91       	ld	r24, Y+
    2920:	0e 94 78 13 	call	0x26f0	; 0x26f0 <Lcd_DisplayChr>
	u8 loc_ByteIndex=0;
	u8 loc_CharIndx=0;
	for (loc_CharIndx=0;loc_CharIndx<NO_CSTOM_CHAR;loc_CharIndx++)
	{
		Lcd_Cmd(_LCD_CGRAM_START_ADDRESS +(loc_CharIndx*8));
			for (loc_ByteIndex =0; loc_ByteIndex<NO_CSTOM_CHAR_BYTES;loc_ByteIndex++)
    2924:	1f 5f       	subi	r17, 0xFF	; 255
    2926:	18 30       	cpi	r17, 0x08	; 8
    2928:	d1 f7       	brne	.-12     	; 0x291e <Lcd_Init+0xb8>
    292a:	08 94       	sec
    292c:	e1 1c       	adc	r14, r1
    292e:	f1 1c       	adc	r15, r1
    2930:	88 e0       	ldi	r24, 0x08	; 8
    2932:	90 e0       	ldi	r25, 0x00	; 0
    2934:	c8 0e       	add	r12, r24
    2936:	d9 1e       	adc	r13, r25
extern u8 customChar[8][8];
static void Lcd_WriteCustom(void)
{
	u8 loc_ByteIndex=0;
	u8 loc_CharIndx=0;
	for (loc_CharIndx=0;loc_CharIndx<NO_CSTOM_CHAR;loc_CharIndx++)
    2938:	98 e0       	ldi	r25, 0x08	; 8
    293a:	e9 16       	cp	r14, r25
    293c:	f1 04       	cpc	r15, r1
    293e:	11 f7       	brne	.-60     	; 0x2904 <Lcd_Init+0x9e>
	_delay_us(100);
	Lcd_Cmd(3);
	Lcd_Cmd(2);
	Lcd_Cmd(_LCD_4BIT_MODE);
	Lcd_WriteCustom();
	Lcd_Goto_Row_Column(0,0);
    2940:	80 e0       	ldi	r24, 0x00	; 0
    2942:	60 e0       	ldi	r22, 0x00	; 0
    2944:	0e 94 24 14 	call	0x2848	; 0x2848 <Lcd_Goto_Row_Column>
	Lcd_Cmd(_LCD_CURSOR_OFF);
    2948:	8c e0       	ldi	r24, 0x0C	; 12
    294a:	0e 94 0b 14 	call	0x2816	; 0x2816 <Lcd_Cmd>
}
    294e:	df 91       	pop	r29
    2950:	cf 91       	pop	r28
    2952:	1f 91       	pop	r17
    2954:	ff 90       	pop	r15
    2956:	ef 90       	pop	r14
    2958:	df 90       	pop	r13
    295a:	cf 90       	pop	r12
    295c:	08 95       	ret

0000295e <KeyPad_Scan>:
* \Reentrancy      : Non Reentrant
* \Parameters (in) : None
* \Return value:   : None
*******************************************************************************/
u8 KeyPad_Scan(void)
{
    295e:	af 92       	push	r10
    2960:	bf 92       	push	r11
    2962:	df 92       	push	r13
    2964:	ef 92       	push	r14
    2966:	ff 92       	push	r15
    2968:	0f 93       	push	r16
    296a:	1f 93       	push	r17
    296c:	cf 93       	push	r28
    296e:	df 93       	push	r29
    2970:	dd 24       	eor	r13, r13
    2972:	ee 24       	eor	r14, r14
    2974:	ff 24       	eor	r15, r15
    2976:	80 e4       	ldi	r24, 0x40	; 64
    2978:	a8 2e       	mov	r10, r24
    297a:	8c e9       	ldi	r24, 0x9C	; 156
    297c:	b8 2e       	mov	r11, r24
    297e:	0e 2d       	mov	r16, r14
		u8 Temp = 0;

		for(LOC_Coloum = COL0 ; LOC_Coloum <= COL3 ; LOC_Coloum++)
		{

			Dio_WriteChannel(KEYPAD_DATA_PORT, LOC_Coloum, STD_LOW);
    2980:	83 e0       	ldi	r24, 0x03	; 3
    2982:	6e 2d       	mov	r22, r14
    2984:	40 e0       	ldi	r20, 0x00	; 0
    2986:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
    298a:	e7 01       	movw	r28, r14
    298c:	c9 53       	subi	r28, 0x39	; 57
    298e:	de 4f       	sbci	r29, 0xFE	; 254
    2990:	14 e0       	ldi	r17, 0x04	; 4

			for(LOC_ROW = ROW0 ; LOC_ROW <= ROW3 ; LOC_ROW++)
			{

				Temp=Dio_ReadChannel(KEYPAD_DATA_PORT, LOC_ROW);
    2992:	83 e0       	ldi	r24, 0x03	; 3
    2994:	61 2f       	mov	r22, r17
    2996:	0e 94 bb 18 	call	0x3176	; 0x3176 <Dio_ReadChannel>

				if(!Temp)
    299a:	88 23       	and	r24, r24
    299c:	51 f4       	brne	.+20     	; 0x29b2 <KeyPad_Scan+0x54>
				{
					Value = KeyPad_Vlues[LOC_ROW - ROW0][LOC_Coloum - COL0];
    299e:	d8 80       	ld	r13, Y

					while(!Temp)
					{
						Temp=Dio_ReadChannel(KEYPAD_DATA_PORT, LOC_ROW);
    29a0:	83 e0       	ldi	r24, 0x03	; 3
    29a2:	61 2f       	mov	r22, r17
    29a4:	0e 94 bb 18 	call	0x3176	; 0x3176 <Dio_ReadChannel>

				if(!Temp)
				{
					Value = KeyPad_Vlues[LOC_ROW - ROW0][LOC_Coloum - COL0];

					while(!Temp)
    29a8:	88 23       	and	r24, r24
    29aa:	d1 f3       	breq	.-12     	; 0x29a0 <KeyPad_Scan+0x42>
    29ac:	c5 01       	movw	r24, r10
    29ae:	01 97       	sbiw	r24, 0x01	; 1
    29b0:	f1 f7       	brne	.-4      	; 0x29ae <KeyPad_Scan+0x50>
		for(LOC_Coloum = COL0 ; LOC_Coloum <= COL3 ; LOC_Coloum++)
		{

			Dio_WriteChannel(KEYPAD_DATA_PORT, LOC_Coloum, STD_LOW);

			for(LOC_ROW = ROW0 ; LOC_ROW <= ROW3 ; LOC_ROW++)
    29b2:	1f 5f       	subi	r17, 0xFF	; 255
    29b4:	24 96       	adiw	r28, 0x04	; 4
    29b6:	18 30       	cpi	r17, 0x08	; 8
    29b8:	61 f7       	brne	.-40     	; 0x2992 <KeyPad_Scan+0x34>

					_delay_ms(10);
				}

			}
			Dio_WriteChannel(KEYPAD_DATA_PORT, LOC_Coloum, STD_HIGH);
    29ba:	83 e0       	ldi	r24, 0x03	; 3
    29bc:	60 2f       	mov	r22, r16
    29be:	41 e0       	ldi	r20, 0x01	; 1
    29c0:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
    29c4:	08 94       	sec
    29c6:	e1 1c       	adc	r14, r1
    29c8:	f1 1c       	adc	r15, r1

		u8 Value = 0;

		u8 Temp = 0;

		for(LOC_Coloum = COL0 ; LOC_Coloum <= COL3 ; LOC_Coloum++)
    29ca:	84 e0       	ldi	r24, 0x04	; 4
    29cc:	e8 16       	cp	r14, r24
    29ce:	f1 04       	cpc	r15, r1
    29d0:	b1 f6       	brne	.-84     	; 0x297e <KeyPad_Scan+0x20>
			}
			Dio_WriteChannel(KEYPAD_DATA_PORT, LOC_Coloum, STD_HIGH);
		}

		return Value ;
}
    29d2:	8d 2d       	mov	r24, r13
    29d4:	df 91       	pop	r29
    29d6:	cf 91       	pop	r28
    29d8:	1f 91       	pop	r17
    29da:	0f 91       	pop	r16
    29dc:	ff 90       	pop	r15
    29de:	ef 90       	pop	r14
    29e0:	df 90       	pop	r13
    29e2:	bf 90       	pop	r11
    29e4:	af 90       	pop	r10
    29e6:	08 95       	ret

000029e8 <KeyPad_Init>:
* \Parameters (in) : None
* \Return value:   : None
*******************************************************************************/
void KeyPad_Init(void)
{
	Dio_ConfigChannel(KEYPAD_DATA_PORT ,COL0, OUTPUT);
    29e8:	83 e0       	ldi	r24, 0x03	; 3
    29ea:	60 e0       	ldi	r22, 0x00	; 0
    29ec:	41 e0       	ldi	r20, 0x01	; 1
    29ee:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(KEYPAD_DATA_PORT ,COL1, OUTPUT);
    29f2:	83 e0       	ldi	r24, 0x03	; 3
    29f4:	61 e0       	ldi	r22, 0x01	; 1
    29f6:	41 e0       	ldi	r20, 0x01	; 1
    29f8:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(KEYPAD_DATA_PORT ,COL2, OUTPUT);
    29fc:	83 e0       	ldi	r24, 0x03	; 3
    29fe:	62 e0       	ldi	r22, 0x02	; 2
    2a00:	41 e0       	ldi	r20, 0x01	; 1
    2a02:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(KEYPAD_DATA_PORT ,COL3, OUTPUT);
    2a06:	83 e0       	ldi	r24, 0x03	; 3
    2a08:	63 e0       	ldi	r22, 0x03	; 3
    2a0a:	41 e0       	ldi	r20, 0x01	; 1
    2a0c:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>

	Dio_ConfigChannel(KEYPAD_DATA_PORT ,ROW0, INPUT);
    2a10:	83 e0       	ldi	r24, 0x03	; 3
    2a12:	64 e0       	ldi	r22, 0x04	; 4
    2a14:	40 e0       	ldi	r20, 0x00	; 0
    2a16:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(KEYPAD_DATA_PORT ,ROW1, INPUT);
    2a1a:	83 e0       	ldi	r24, 0x03	; 3
    2a1c:	65 e0       	ldi	r22, 0x05	; 5
    2a1e:	40 e0       	ldi	r20, 0x00	; 0
    2a20:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(KEYPAD_DATA_PORT ,ROW2, INPUT);
    2a24:	83 e0       	ldi	r24, 0x03	; 3
    2a26:	66 e0       	ldi	r22, 0x06	; 6
    2a28:	40 e0       	ldi	r20, 0x00	; 0
    2a2a:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(KEYPAD_DATA_PORT ,ROW3, INPUT);
    2a2e:	83 e0       	ldi	r24, 0x03	; 3
    2a30:	67 e0       	ldi	r22, 0x07	; 7
    2a32:	40 e0       	ldi	r20, 0x00	; 0
    2a34:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>

	Dio_ConfigChannelPullUp(KEYPAD_DATA_PORT ,ROW0);
    2a38:	83 e0       	ldi	r24, 0x03	; 3
    2a3a:	64 e0       	ldi	r22, 0x04	; 4
    2a3c:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <Dio_ConfigChannelPullUp>
	Dio_ConfigChannelPullUp(KEYPAD_DATA_PORT ,ROW1);
    2a40:	83 e0       	ldi	r24, 0x03	; 3
    2a42:	65 e0       	ldi	r22, 0x05	; 5
    2a44:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <Dio_ConfigChannelPullUp>
	Dio_ConfigChannelPullUp(KEYPAD_DATA_PORT ,ROW2);
    2a48:	83 e0       	ldi	r24, 0x03	; 3
    2a4a:	66 e0       	ldi	r22, 0x06	; 6
    2a4c:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <Dio_ConfigChannelPullUp>
	Dio_ConfigChannelPullUp(KEYPAD_DATA_PORT ,ROW3);
    2a50:	83 e0       	ldi	r24, 0x03	; 3
    2a52:	67 e0       	ldi	r22, 0x07	; 7
    2a54:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <Dio_ConfigChannelPullUp>

	Dio_WriteChannel(KEYPAD_DATA_PORT, COL0, STD_HIGH);
    2a58:	83 e0       	ldi	r24, 0x03	; 3
    2a5a:	60 e0       	ldi	r22, 0x00	; 0
    2a5c:	41 e0       	ldi	r20, 0x01	; 1
    2a5e:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
	Dio_WriteChannel(KEYPAD_DATA_PORT, COL1, STD_HIGH);
    2a62:	83 e0       	ldi	r24, 0x03	; 3
    2a64:	61 e0       	ldi	r22, 0x01	; 1
    2a66:	41 e0       	ldi	r20, 0x01	; 1
    2a68:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
	Dio_WriteChannel(KEYPAD_DATA_PORT, COL2, STD_HIGH);
    2a6c:	83 e0       	ldi	r24, 0x03	; 3
    2a6e:	62 e0       	ldi	r22, 0x02	; 2
    2a70:	41 e0       	ldi	r20, 0x01	; 1
    2a72:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
	Dio_WriteChannel(KEYPAD_DATA_PORT, COL3, STD_HIGH);
    2a76:	83 e0       	ldi	r24, 0x03	; 3
    2a78:	63 e0       	ldi	r22, 0x03	; 3
    2a7a:	41 e0       	ldi	r20, 0x01	; 1
    2a7c:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
}
    2a80:	08 95       	ret

00002a82 <Eeprom24C16_ReadByte>:
	I2C_StopCondition();
}

/*	addr = 0 to 2047	*/
u8 Eeprom24C16_ReadByte(u16 addr)
{
    2a82:	ff 92       	push	r15
    2a84:	0f 93       	push	r16
    2a86:	1f 93       	push	r17
    2a88:	8c 01       	movw	r16, r24
	u8 loc_pageNo = (addr/256);
	u8 loc_byteNo = (addr%256);
	u8 loc_dataRead=0;
	I2C_StartCondition();
    2a8a:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <I2C_StartCondition>
	I2C_Send_SlaveAddressWriteOperation(0x50 | ( ( addr & 0x0700 ) >> 8 ) );
    2a8e:	c8 01       	movw	r24, r16
    2a90:	80 70       	andi	r24, 0x00	; 0
    2a92:	97 70       	andi	r25, 0x07	; 7
    2a94:	80 e5       	ldi	r24, 0x50	; 80
    2a96:	f8 2e       	mov	r15, r24
    2a98:	f9 2a       	or	r15, r25
    2a9a:	8f 2d       	mov	r24, r15
    2a9c:	0e 94 fa 16 	call	0x2df4	; 0x2df4 <I2C_Send_SlaveAddressWriteOperation>
	I2C_WriteByte(loc_byteNo);
    2aa0:	80 2f       	mov	r24, r16
    2aa2:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <I2C_WriteByte>
	I2C_RepeatedStartCondition();
    2aa6:	0e 94 db 16 	call	0x2db6	; 0x2db6 <I2C_RepeatedStartCondition>
	I2C_Send_SlaveAddressReadOperation(0x50 | ( ( addr & 0x0700 ) >> 8 ));
    2aaa:	8f 2d       	mov	r24, r15
    2aac:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <I2C_Send_SlaveAddressReadOperation>
	loc_dataRead = I2C_ReadByte();
    2ab0:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <I2C_ReadByte>
    2ab4:	18 2f       	mov	r17, r24
	I2C_StopCondition();
    2ab6:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <I2C_StopCondition>
	return loc_dataRead;
}
    2aba:	81 2f       	mov	r24, r17
    2abc:	1f 91       	pop	r17
    2abe:	0f 91       	pop	r16
    2ac0:	ff 90       	pop	r15
    2ac2:	08 95       	ret

00002ac4 <Eeprom24C16_WriteByte>:
	I2C_MasterInit();
}

/*	addr = 0 to 2047	*/
void Eeprom24C16_WriteByte(u16 addr, u8 data)
{
    2ac4:	ff 92       	push	r15
    2ac6:	0f 93       	push	r16
    2ac8:	1f 93       	push	r17
    2aca:	8c 01       	movw	r16, r24
    2acc:	f6 2e       	mov	r15, r22
	u8 loc_pageNo = (addr/256);
	u8 loc_byteNo = (addr%256);
	Lcd_Goto_Row_Column(0, 0);
    2ace:	80 e0       	ldi	r24, 0x00	; 0
    2ad0:	60 e0       	ldi	r22, 0x00	; 0
    2ad2:	0e 94 24 14 	call	0x2848	; 0x2848 <Lcd_Goto_Row_Column>
	Lcd_DisplayNum(loc_pageNo);
    2ad6:	81 2f       	mov	r24, r17
    2ad8:	90 e0       	ldi	r25, 0x00	; 0
    2ada:	0e 94 91 13 	call	0x2722	; 0x2722 <Lcd_DisplayNum>
	Lcd_Goto_Row_Column(0, 8);
    2ade:	80 e0       	ldi	r24, 0x00	; 0
    2ae0:	68 e0       	ldi	r22, 0x08	; 8
    2ae2:	0e 94 24 14 	call	0x2848	; 0x2848 <Lcd_Goto_Row_Column>
	Lcd_DisplayNum(loc_byteNo);
    2ae6:	80 2f       	mov	r24, r16
    2ae8:	90 e0       	ldi	r25, 0x00	; 0
    2aea:	0e 94 91 13 	call	0x2722	; 0x2722 <Lcd_DisplayNum>
	I2C_StartCondition();
    2aee:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <I2C_StartCondition>
	Lcd_Goto_Row_Column(1, 0);
    2af2:	81 e0       	ldi	r24, 0x01	; 1
    2af4:	60 e0       	ldi	r22, 0x00	; 0
    2af6:	0e 94 24 14 	call	0x2848	; 0x2848 <Lcd_Goto_Row_Column>
	I2C_Send_SlaveAddressWriteOperation(0x50 | ( ( addr & 0x0700 ) >> 8 ));
    2afa:	c8 01       	movw	r24, r16
    2afc:	80 70       	andi	r24, 0x00	; 0
    2afe:	97 70       	andi	r25, 0x07	; 7
    2b00:	89 2f       	mov	r24, r25
    2b02:	80 65       	ori	r24, 0x50	; 80
    2b04:	0e 94 fa 16 	call	0x2df4	; 0x2df4 <I2C_Send_SlaveAddressWriteOperation>
	Lcd_Goto_Row_Column(1, 0);
    2b08:	81 e0       	ldi	r24, 0x01	; 1
    2b0a:	60 e0       	ldi	r22, 0x00	; 0
    2b0c:	0e 94 24 14 	call	0x2848	; 0x2848 <Lcd_Goto_Row_Column>
	I2C_WriteByte(loc_byteNo);
    2b10:	80 2f       	mov	r24, r16
    2b12:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <I2C_WriteByte>
	Lcd_Goto_Row_Column(1, 0);
    2b16:	81 e0       	ldi	r24, 0x01	; 1
    2b18:	60 e0       	ldi	r22, 0x00	; 0
    2b1a:	0e 94 24 14 	call	0x2848	; 0x2848 <Lcd_Goto_Row_Column>
	I2C_WriteByte(data);
    2b1e:	8f 2d       	mov	r24, r15
    2b20:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <I2C_WriteByte>
	Lcd_Goto_Row_Column(1, 0);
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	60 e0       	ldi	r22, 0x00	; 0
    2b28:	0e 94 24 14 	call	0x2848	; 0x2848 <Lcd_Goto_Row_Column>
	I2C_StopCondition();
    2b2c:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <I2C_StopCondition>
}
    2b30:	1f 91       	pop	r17
    2b32:	0f 91       	pop	r16
    2b34:	ff 90       	pop	r15
    2b36:	08 95       	ret

00002b38 <Eeprom24C16_Init>:

#include "Eeprom24C16.h"
#include "Lcd.h"
void Eeprom24C16_Init(void)
{
	I2C_MasterInit();
    2b38:	0e 94 bd 16 	call	0x2d7a	; 0x2d7a <I2C_MasterInit>
}
    2b3c:	08 95       	ret

00002b3e <Buzzer_Toggle>:
	Dio_WriteChannel(BUZZER_PORT,BUZZER_PIN,STD_LOW);
}

void Buzzer_Toggle()
{
	Dio_TogglChannel(BUZZER_PORT,BUZZER_PIN);
    2b3e:	80 e0       	ldi	r24, 0x00	; 0
    2b40:	63 e0       	ldi	r22, 0x03	; 3
    2b42:	0e 94 86 18 	call	0x310c	; 0x310c <Dio_TogglChannel>
}
    2b46:	08 95       	ret

00002b48 <Buzzer_OFF>:
	Dio_WriteChannel(BUZZER_PORT,BUZZER_PIN,STD_HIGH);
}

void Buzzer_OFF()
{
	Dio_WriteChannel(BUZZER_PORT,BUZZER_PIN,STD_LOW);
    2b48:	80 e0       	ldi	r24, 0x00	; 0
    2b4a:	63 e0       	ldi	r22, 0x03	; 3
    2b4c:	40 e0       	ldi	r20, 0x00	; 0
    2b4e:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
}
    2b52:	08 95       	ret

00002b54 <Buzzer_ON>:
	Dio_ConfigChannel(BUZZER_PORT,BUZZER_PIN,OUTPUT);
}

void Buzzer_ON()
{
	Dio_WriteChannel(BUZZER_PORT,BUZZER_PIN,STD_HIGH);
    2b54:	80 e0       	ldi	r24, 0x00	; 0
    2b56:	63 e0       	ldi	r22, 0x03	; 3
    2b58:	41 e0       	ldi	r20, 0x01	; 1
    2b5a:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
}
    2b5e:	08 95       	ret

00002b60 <Buzzer_Init>:
 */
#include "Buzzer.h"

void Buzzer_Init()
{
	Dio_ConfigChannel(BUZZER_PORT,BUZZER_PIN,OUTPUT);
    2b60:	80 e0       	ldi	r24, 0x00	; 0
    2b62:	63 e0       	ldi	r22, 0x03	; 3
    2b64:	41 e0       	ldi	r20, 0x01	; 1
    2b66:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
}
    2b6a:	08 95       	ret

00002b6c <Button_GetStatus>:
	Dio_ConfigChannel(BUTTON2_PORT,BUTTON2_PIN,INPUT);
}
button_type Button_GetStatus(buttonID_type button)
{
	button_type status = RELEASED;
	switch (button)
    2b6c:	81 30       	cpi	r24, 0x01	; 1
    2b6e:	89 f0       	breq	.+34     	; 0x2b92 <Button_GetStatus+0x26>
    2b70:	81 30       	cpi	r24, 0x01	; 1
    2b72:	28 f0       	brcs	.+10     	; 0x2b7e <Button_GetStatus+0x12>
    2b74:	82 30       	cpi	r24, 0x02	; 2
    2b76:	b1 f0       	breq	.+44     	; 0x2ba4 <Button_GetStatus+0x38>
    2b78:	90 e0       	ldi	r25, 0x00	; 0
			status = RELEASED;
		}
		break;
	}
	return status;
}
    2b7a:	89 2f       	mov	r24, r25
    2b7c:	08 95       	ret
{
	button_type status = RELEASED;
	switch (button)
	{
	case BUTTON0:
		if (Dio_ReadChannel(BUTTON0_PORT,BUTTON0_PIN) == STD_HIGH)
    2b7e:	81 e0       	ldi	r24, 0x01	; 1
    2b80:	60 e0       	ldi	r22, 0x00	; 0
    2b82:	0e 94 bb 18 	call	0x3176	; 0x3176 <Dio_ReadChannel>
    2b86:	90 e0       	ldi	r25, 0x00	; 0
    2b88:	81 30       	cpi	r24, 0x01	; 1
    2b8a:	b9 f7       	brne	.-18     	; 0x2b7a <Button_GetStatus+0xe>
			status = RELEASED;
		}
		break;

	case BUTTON2:
		if (Dio_ReadChannel(BUTTON2_PORT,BUTTON2_PIN) == STD_HIGH)
    2b8c:	91 e0       	ldi	r25, 0x01	; 1
			status = RELEASED;
		}
		break;
	}
	return status;
}
    2b8e:	89 2f       	mov	r24, r25
    2b90:	08 95       	ret
			status = RELEASED;
		}
		break;

	case BUTTON1:
		if (Dio_ReadChannel(BUTTON1_PORT,BUTTON1_PIN) == STD_HIGH)
    2b92:	81 e0       	ldi	r24, 0x01	; 1
    2b94:	64 e0       	ldi	r22, 0x04	; 4
    2b96:	0e 94 bb 18 	call	0x3176	; 0x3176 <Dio_ReadChannel>
    2b9a:	90 e0       	ldi	r25, 0x00	; 0
    2b9c:	81 30       	cpi	r24, 0x01	; 1
    2b9e:	b1 f3       	breq	.-20     	; 0x2b8c <Button_GetStatus+0x20>
			status = RELEASED;
		}
		break;
	}
	return status;
}
    2ba0:	89 2f       	mov	r24, r25
    2ba2:	08 95       	ret
			status = RELEASED;
		}
		break;

	case BUTTON2:
		if (Dio_ReadChannel(BUTTON2_PORT,BUTTON2_PIN) == STD_HIGH)
    2ba4:	83 e0       	ldi	r24, 0x03	; 3
    2ba6:	62 e0       	ldi	r22, 0x02	; 2
    2ba8:	0e 94 bb 18 	call	0x3176	; 0x3176 <Dio_ReadChannel>
    2bac:	90 e0       	ldi	r25, 0x00	; 0
    2bae:	81 30       	cpi	r24, 0x01	; 1
    2bb0:	69 f3       	breq	.-38     	; 0x2b8c <Button_GetStatus+0x20>
			status = RELEASED;
		}
		break;
	}
	return status;
}
    2bb2:	89 2f       	mov	r24, r25
    2bb4:	08 95       	ret

00002bb6 <Button_Init>:
 */
#include "Button.h"

void Button_Init(void)
{
	Dio_ConfigChannel(BUTTON0_PORT,BUTTON0_PIN,INPUT);
    2bb6:	81 e0       	ldi	r24, 0x01	; 1
    2bb8:	60 e0       	ldi	r22, 0x00	; 0
    2bba:	40 e0       	ldi	r20, 0x00	; 0
    2bbc:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(BUTTON1_PORT,BUTTON1_PIN,INPUT);
    2bc0:	81 e0       	ldi	r24, 0x01	; 1
    2bc2:	64 e0       	ldi	r22, 0x04	; 4
    2bc4:	40 e0       	ldi	r20, 0x00	; 0
    2bc6:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	Dio_ConfigChannel(BUTTON2_PORT,BUTTON2_PIN,INPUT);
    2bca:	83 e0       	ldi	r24, 0x03	; 3
    2bcc:	62 e0       	ldi	r22, 0x02	; 2
    2bce:	40 e0       	ldi	r20, 0x00	; 0
    2bd0:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
}
    2bd4:	08 95       	ret

00002bd6 <WDG_ON>:
 *****************************************/
#include <Wdg.h>
void WDG_ON(void)
{
	/*	Set Watchdog Timer Window to 2.1 Sec	*/
	WDG_WDTCR_REG |= WDG_WINDOW_5V_2POINT1_SEC;
    2bd6:	81 b5       	in	r24, 0x21	; 33
    2bd8:	87 60       	ori	r24, 0x07	; 7
    2bda:	81 bd       	out	0x21, r24	; 33
	/*	Enable Watchdog Timer	*/
	SET_BIT(WDG_WDTCR_REG,WDG_ENABLE_BIT);
    2bdc:	81 b5       	in	r24, 0x21	; 33
    2bde:	88 60       	ori	r24, 0x08	; 8
    2be0:	81 bd       	out	0x21, r24	; 33
}
    2be2:	08 95       	ret

00002be4 <WDG_OFF>:
void WDG_OFF(void)
{
	WDG_WDTCR_REG =(WDG_ENABLE)|(WDG_TURN_OFF_ENABLE);
    2be4:	88 e1       	ldi	r24, 0x18	; 24
    2be6:	81 bd       	out	0x21, r24	; 33
	CLR_BIT(WDG_WDTCR_REG,WDG_ENABLE_BIT);
    2be8:	81 b5       	in	r24, 0x21	; 33
    2bea:	87 7f       	andi	r24, 0xF7	; 247
    2bec:	81 bd       	out	0x21, r24	; 33
}
    2bee:	08 95       	ret

00002bf0 <WDG_Refresh>:
void WDG_Refresh(void)
{
	asm("WDR");
    2bf0:	a8 95       	wdr
}
    2bf2:	08 95       	ret

00002bf4 <UART_Init>:
volatile u8 UART_RxBuffer_Index = 0;
volatile boolean Rx_Buffer_Ready = FALSE;
void UART_Init(u16 baudRate)
{
	/* Set baud rate */
	UART_UBRRH_REG = (u8)(baudRate>>8);
    2bf4:	90 bd       	out	0x20, r25	; 32
	UART_UBRRL_REG = (u8)baudRate;
    2bf6:	89 b9       	out	0x09, r24	; 9
	/* Enable receiver and transmitter */
	SET_BIT(UART_UCSRB_REG,RXEN_BIT_NO);  /* Enable Receiver*/
    2bf8:	54 9a       	sbi	0x0a, 4	; 10
	SET_BIT(UART_UCSRB_REG,TXEN_BIT_NO);  /* Enable Transmitter */
    2bfa:	53 9a       	sbi	0x0a, 3	; 10
	/* Set frame format: 8data, 1stop bit, Even Parity */
	UART_UCSRC_REG |= (1 << URSEL_BIT_NO)|UART_8_BIT_DATA | UART_EVEN_PARITY;
    2bfc:	80 b5       	in	r24, 0x20	; 32
    2bfe:	86 6a       	ori	r24, 0xA6	; 166
    2c00:	80 bd       	out	0x20, r24	; 32
	SET_BIT(UART_UCSRB_REG,7); /*	Enable Rx Complete Interrupt	*/
    2c02:	57 9a       	sbi	0x0a, 7	; 10
}
    2c04:	08 95       	ret

00002c06 <UART_TransmitChr>:

void UART_TransmitChr(u8 data)
{
	/* Wait for empty transmit buffer */
	while (!(CHK_BIT(UART_UCSRA_REG,UDRE_BIT_NO)))
    2c06:	5d 9b       	sbis	0x0b, 5	; 11
    2c08:	fe cf       	rjmp	.-4      	; 0x2c06 <UART_TransmitChr>
			;
	/* Put data into buffer, sends the data */
	UART_UDR_REG = data;
    2c0a:	8c b9       	out	0x0c, r24	; 12
}
    2c0c:	08 95       	ret

00002c0e <UART_TransmitStr>:

void UART_TransmitStr(u8 *str)
{
    2c0e:	fc 01       	movw	r30, r24
	/* Wait for empty transmit buffer */
	while (*str != '\0')
    2c10:	80 81       	ld	r24, Z
    2c12:	88 23       	and	r24, r24
    2c14:	39 f0       	breq	.+14     	; 0x2c24 <UART_TransmitStr+0x16>
}

void UART_TransmitChr(u8 data)
{
	/* Wait for empty transmit buffer */
	while (!(CHK_BIT(UART_UCSRA_REG,UDRE_BIT_NO)))
    2c16:	5d 9b       	sbis	0x0b, 5	; 11
    2c18:	fe cf       	rjmp	.-4      	; 0x2c16 <UART_TransmitStr+0x8>
			;
	/* Put data into buffer, sends the data */
	UART_UDR_REG = data;
    2c1a:	8c b9       	out	0x0c, r24	; 12
{
	/* Wait for empty transmit buffer */
	while (*str != '\0')
	{
		UART_TransmitChr(*str);
		str++;
    2c1c:	31 96       	adiw	r30, 0x01	; 1
}

void UART_TransmitStr(u8 *str)
{
	/* Wait for empty transmit buffer */
	while (*str != '\0')
    2c1e:	80 81       	ld	r24, Z
    2c20:	88 23       	and	r24, r24
    2c22:	c9 f7       	brne	.-14     	; 0x2c16 <UART_TransmitStr+0x8>
    2c24:	08 95       	ret

00002c26 <UART_ReceiveChr>:
//}

u8 UART_ReceiveChr(void)
{
	/* Wait for data to be received */
	if ((CHK_BIT(UART_UCSRA_REG,RXC_BIT_NO)))
    2c26:	5f 99       	sbic	0x0b, 7	; 11
    2c28:	02 c0       	rjmp	.+4      	; 0x2c2e <UART_ReceiveChr+0x8>
    2c2a:	80 e0       	ldi	r24, 0x00	; 0
    2c2c:	08 95       	ret
	{
		return UART_UDR_REG;
    2c2e:	8c b1       	in	r24, 0x0c	; 12
	{
		return 0;
	}
	/* Get and return received data from buffer */

}
    2c30:	08 95       	ret

00002c32 <__vector_13>:
ISR(USART_RXC_vect)
{
    2c32:	1f 92       	push	r1
    2c34:	0f 92       	push	r0
    2c36:	0f b6       	in	r0, 0x3f	; 63
    2c38:	0f 92       	push	r0
    2c3a:	11 24       	eor	r1, r1
    2c3c:	2f 93       	push	r18
    2c3e:	3f 93       	push	r19
    2c40:	4f 93       	push	r20
    2c42:	5f 93       	push	r21
    2c44:	6f 93       	push	r22
    2c46:	7f 93       	push	r23
    2c48:	8f 93       	push	r24
    2c4a:	9f 93       	push	r25
    2c4c:	af 93       	push	r26
    2c4e:	bf 93       	push	r27
    2c50:	ef 93       	push	r30
    2c52:	ff 93       	push	r31
	UART_RxBuffer[UART_RxBuffer_Index] = UART_UDR_REG;
    2c54:	e0 91 d8 04 	lds	r30, 0x04D8
    2c58:	f0 e0       	ldi	r31, 0x00	; 0
    2c5a:	8c b1       	in	r24, 0x0c	; 12
    2c5c:	e6 52       	subi	r30, 0x26	; 38
    2c5e:	fb 4f       	sbci	r31, 0xFB	; 251
    2c60:	80 83       	st	Z, r24
	if (UART_RxBuffer[UART_RxBuffer_Index] == '\r')
    2c62:	e0 91 d8 04 	lds	r30, 0x04D8
    2c66:	f0 e0       	ldi	r31, 0x00	; 0
    2c68:	e6 52       	subi	r30, 0x26	; 38
    2c6a:	fb 4f       	sbci	r31, 0xFB	; 251
    2c6c:	80 81       	ld	r24, Z
    2c6e:	8d 30       	cpi	r24, 0x0D	; 13
    2c70:	c9 f0       	breq	.+50     	; 0x2ca4 <__vector_13+0x72>
		Rx_Buffer_Ready = TRUE;
		LED_TOGGLE(LED1);
	}
	else
	{
		UART_RxBuffer_Index++;
    2c72:	80 91 d8 04 	lds	r24, 0x04D8
    2c76:	8f 5f       	subi	r24, 0xFF	; 255
    2c78:	80 93 d8 04 	sts	0x04D8, r24
		LED_TOGGLE(LED0);
    2c7c:	80 e0       	ldi	r24, 0x00	; 0
    2c7e:	0e 94 0e 13 	call	0x261c	; 0x261c <LED_TOGGLE>
	}
}
    2c82:	ff 91       	pop	r31
    2c84:	ef 91       	pop	r30
    2c86:	bf 91       	pop	r27
    2c88:	af 91       	pop	r26
    2c8a:	9f 91       	pop	r25
    2c8c:	8f 91       	pop	r24
    2c8e:	7f 91       	pop	r23
    2c90:	6f 91       	pop	r22
    2c92:	5f 91       	pop	r21
    2c94:	4f 91       	pop	r20
    2c96:	3f 91       	pop	r19
    2c98:	2f 91       	pop	r18
    2c9a:	0f 90       	pop	r0
    2c9c:	0f be       	out	0x3f, r0	; 63
    2c9e:	0f 90       	pop	r0
    2ca0:	1f 90       	pop	r1
    2ca2:	18 95       	reti
ISR(USART_RXC_vect)
{
	UART_RxBuffer[UART_RxBuffer_Index] = UART_UDR_REG;
	if (UART_RxBuffer[UART_RxBuffer_Index] == '\r')
	{
		UART_RxBuffer_Index = 0;
    2ca4:	10 92 d8 04 	sts	0x04D8, r1
		Rx_Buffer_Ready = TRUE;
    2ca8:	81 e0       	ldi	r24, 0x01	; 1
    2caa:	80 93 d9 04 	sts	0x04D9, r24
		LED_TOGGLE(LED1);
    2cae:	0e 94 0e 13 	call	0x261c	; 0x261c <LED_TOGGLE>
    2cb2:	e7 cf       	rjmp	.-50     	; 0x2c82 <__vector_13+0x50>

00002cb4 <TIMER0_Init>:
 ********************************/
#include "Timer0.h"
void TIMER0_Init(void)
{
	#if (TIMER_OPERATION_MODE == TIMER0_MODE_INTERVAL)
		TIMER0_TCCR0_REG|= TIMER0_INTERVAL_MODE;
    2cb4:	83 b7       	in	r24, 0x33	; 51
    2cb6:	83 bf       	out	0x33, r24	; 51
	#elif (TIMER_OPERATION_MODE == TIMER0_MODE_PWM_PHASE_CORRECT)
		TIMER0_TCCR0_REG|= TIMER0_PWM_PHASE_CORRECT;
	#else
	#error "You Shall Define Timer Operation Mode In Timer0_Cfg.h"
	#endif
}
    2cb8:	08 95       	ret

00002cba <TIMER0_Start>:
#if ((TIMER_OPERATION_MODE == TIMER0_MODE_INTERVAL) || (TIMER_OPERATION_MODE == TIMER0_MODE_CTC))
void TIMER0_Start(u8 prescaler)
{
	TIMER0_TCCR0_REG |=prescaler;
    2cba:	93 b7       	in	r25, 0x33	; 51
    2cbc:	98 2b       	or	r25, r24
    2cbe:	93 bf       	out	0x33, r25	; 51
}
    2cc0:	08 95       	ret

00002cc2 <TIMER0_Stop>:

void TIMER0_Stop(void)
{
	TIMER0_TCCR0_REG &=0xFC;
    2cc2:	83 b7       	in	r24, 0x33	; 51
    2cc4:	8c 7f       	andi	r24, 0xFC	; 252
    2cc6:	83 bf       	out	0x33, r24	; 51
}
    2cc8:	08 95       	ret

00002cca <TIMER0_SetPreload>:

void TIMER0_SetPreload(u8 preLoadValue)
{
	TIMER0_TCNT0_REG = preLoadValue;
    2cca:	82 bf       	out	0x32, r24	; 50
}
    2ccc:	08 95       	ret

00002cce <TIMER0_GetPreload>:
u8 TIMER0_GetPreload()
{
	return TIMER0_TCNT0_REG;
    2cce:	82 b7       	in	r24, 0x32	; 50
}
    2cd0:	08 95       	ret

00002cd2 <TIMER0_EnableInterrupt>:
void TIMER0_EnableInterrupt(void)
{
#if (TIMER_OPERATION_MODE == TIMER0_MODE_INTERVAL)
	SET_BIT(TIMER0_TIMSK_REG,TIMER0_INTERVAL_INT_ENABLE_BIT_NO);
    2cd2:	89 b7       	in	r24, 0x39	; 57
    2cd4:	81 60       	ori	r24, 0x01	; 1
    2cd6:	89 bf       	out	0x39, r24	; 57
#elif (TIMER_OPERATION_MODE == TIMER0_MODE_CTC)
	SET_BIT(TIMER0_TIMSK_REG,TIMER0_CTC_INT_ENABLE_BIT_NO);
#endif
}
    2cd8:	08 95       	ret

00002cda <TIMER0_DisableInterrupt>:
void TIMER0_DisableInterrupt(void)
{
#if (TIMER_OPERATION_MODE == TIMER0_MODE_INTERVAL)
	CLR_BIT(TIMER0_TIMSK_REG,TIMER0_INTERVAL_INT_ENABLE_BIT_NO);
    2cda:	89 b7       	in	r24, 0x39	; 57
    2cdc:	8e 7f       	andi	r24, 0xFE	; 254
    2cde:	89 bf       	out	0x39, r24	; 57
#elif (TIMER_OPERATION_MODE == TIMER0_MODE_CTC)
	CLR_BIT(TIMER0_TIMSK_REG,TIMER0_CTC_INT_ENABLE_BIT_NO);
#endif
}
    2ce0:	08 95       	ret

00002ce2 <TIMER0_SetCompareValue>:
void TIMER0_SetCompareValue(u8 compareValue)
{
	TIMER0_OCR0_REG = compareValue;
    2ce2:	8c bf       	out	0x3c, r24	; 60
}
    2ce4:	08 95       	ret

00002ce6 <Spi_MasterWrite>:

void Spi_MasterWrite(u8 data)
{
	u8 loc_flush_byte;
	/*	load SPI data register with a byte to send	*/
	SPI_SPDR_REG = data;
    2ce6:	8f b9       	out	0x0f, r24	; 15
	/*	wait until byte sent	*/
	while(!(CHK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT_NO)))
    2ce8:	77 9b       	sbis	0x0e, 7	; 14
    2cea:	fe cf       	rjmp	.-4      	; 0x2ce8 <Spi_MasterWrite+0x2>
	{
		;
	}
		/*	flush the data register	*/
	loc_flush_byte = SPI_SPDR_REG;
    2cec:	8f b1       	in	r24, 0x0f	; 15
}
    2cee:	08 95       	ret

00002cf0 <Spi_MasterRead>:

u8 Spi_MasterRead(void)
{
	u8 loc_dummy_byte=0xFF;
	/*	load SPI data register with a byte to send	*/
	SPI_SPDR_REG = loc_dummy_byte;
    2cf0:	8f ef       	ldi	r24, 0xFF	; 255
    2cf2:	8f b9       	out	0x0f, r24	; 15
	/*	wait until byte received	*/
	while(!(CHK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT_NO)))
    2cf4:	77 9b       	sbis	0x0e, 7	; 14
    2cf6:	fe cf       	rjmp	.-4      	; 0x2cf4 <Spi_MasterRead+0x4>
	{
		;
	}
		/*	read the data register	*/
	return SPI_SPDR_REG;
    2cf8:	8f b1       	in	r24, 0x0f	; 15
}
    2cfa:	08 95       	ret

00002cfc <Spi_MasterTranseve>:

u8 Spi_MasterTranseve(u8 data)
{
	/*	load SPI data register with a byte to send	*/
	SPI_SPDR_REG = data;
    2cfc:	8f b9       	out	0x0f, r24	; 15
	/*	wait until byte sent	*/
	while(!(CHK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT_NO)))
    2cfe:	77 9b       	sbis	0x0e, 7	; 14
    2d00:	fe cf       	rjmp	.-4      	; 0x2cfe <Spi_MasterTranseve+0x2>
	{
		;
	}
	/*	flush the data register	*/
	return SPI_SPDR_REG;
    2d02:	8f b1       	in	r24, 0x0f	; 15
}
    2d04:	08 95       	ret

00002d06 <Spi_SlaveRead>:

u8 Spi_SlaveRead(void)
{
	/*	wait until byte received	*/
	while(!(CHK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT_NO)))
    2d06:	77 9b       	sbis	0x0e, 7	; 14
    2d08:	fe cf       	rjmp	.-4      	; 0x2d06 <Spi_SlaveRead>
	{
		;
	}
		/*	read the data register	*/
	return SPI_SPDR_REG;
    2d0a:	8f b1       	in	r24, 0x0f	; 15
}
    2d0c:	08 95       	ret

00002d0e <Spi_SlaveWrite>:

void Spi_SlaveWrite(u8 data)
{
	SPI_SPDR_REG = data;
    2d0e:	8f b9       	out	0x0f, r24	; 15
}
    2d10:	08 95       	ret

00002d12 <Spi_SlaveInit>:
}

void Spi_SlaveInit(void)
{
	/*	configure SPI MOSI Pin as input	*/
	Dio_ConfigChannel(SPI_MOSI_PORT, SPI_MOSI_CHANNEL, INPUT);
    2d12:	81 e0       	ldi	r24, 0x01	; 1
    2d14:	65 e0       	ldi	r22, 0x05	; 5
    2d16:	40 e0       	ldi	r20, 0x00	; 0
    2d18:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	/*	configure SPI SS Pin as input	*/
	Dio_ConfigChannel(SPI_SS_PORT, SPI_SS_CHANNEL, INPUT);
    2d1c:	81 e0       	ldi	r24, 0x01	; 1
    2d1e:	64 e0       	ldi	r22, 0x04	; 4
    2d20:	40 e0       	ldi	r20, 0x00	; 0
    2d22:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	/*	configure SPI SCK Pin as input	*/
	Dio_ConfigChannel(SPI_SCK_PORT, SPI_SCK_CHANNEL, INPUT);
    2d26:	81 e0       	ldi	r24, 0x01	; 1
    2d28:	67 e0       	ldi	r22, 0x07	; 7
    2d2a:	40 e0       	ldi	r20, 0x00	; 0
    2d2c:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	/*	configure SPI MISO Pin as output	*/
	Dio_ConfigChannel(SPI_MISO_PORT, SPI_MISO_CHANNEL, OUTPUT);
    2d30:	81 e0       	ldi	r24, 0x01	; 1
    2d32:	66 e0       	ldi	r22, 0x06	; 6
    2d34:	41 e0       	ldi	r20, 0x01	; 1
    2d36:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	/*	enable SPI Module	*/
	SET_BIT(SPI_SPCR_REG,SPI_SPE_BIT_NO);
    2d3a:	6e 9a       	sbi	0x0d, 6	; 13
	/*	enable SPI Module in Slave mode	*/
	CLR_BIT(SPI_SPCR_REG,SPI_MSTR_BIT_NO);
    2d3c:	6c 98       	cbi	0x0d, 4	; 13
}
    2d3e:	08 95       	ret

00002d40 <Spi_MasterInit>:
 *************************************************/
#include "Spi.h"
void Spi_MasterInit(void)
{
	/*	configure SPI MOSI Pin as output	*/
	Dio_ConfigChannel(SPI_MOSI_PORT, SPI_MOSI_CHANNEL, OUTPUT);
    2d40:	81 e0       	ldi	r24, 0x01	; 1
    2d42:	65 e0       	ldi	r22, 0x05	; 5
    2d44:	41 e0       	ldi	r20, 0x01	; 1
    2d46:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	/*	configure SPI SS Pin as output	*/
	Dio_ConfigChannel(SPI_SS_PORT, SPI_SS_CHANNEL, OUTPUT);
    2d4a:	81 e0       	ldi	r24, 0x01	; 1
    2d4c:	64 e0       	ldi	r22, 0x04	; 4
    2d4e:	41 e0       	ldi	r20, 0x01	; 1
    2d50:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	/*	configure SPI SCK Pin as output	*/
	Dio_ConfigChannel(SPI_SCK_PORT, SPI_SCK_CHANNEL, OUTPUT);
    2d54:	81 e0       	ldi	r24, 0x01	; 1
    2d56:	67 e0       	ldi	r22, 0x07	; 7
    2d58:	41 e0       	ldi	r20, 0x01	; 1
    2d5a:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	/*	configure SPI MISO Pin as input	*/
	Dio_ConfigChannel(SPI_MISO_PORT, SPI_MISO_CHANNEL, INPUT);
    2d5e:	81 e0       	ldi	r24, 0x01	; 1
    2d60:	66 e0       	ldi	r22, 0x06	; 6
    2d62:	40 e0       	ldi	r20, 0x00	; 0
    2d64:	0e 94 84 17 	call	0x2f08	; 0x2f08 <Dio_ConfigChannel>
	/*	initialize SPI SS pin with HIGH (No slave selected) */
	Dio_WriteChannel(SPI_SS_PORT, SPI_SS_CHANNEL, STD_HIGH);
    2d68:	81 e0       	ldi	r24, 0x01	; 1
    2d6a:	64 e0       	ldi	r22, 0x04	; 4
    2d6c:	41 e0       	ldi	r20, 0x01	; 1
    2d6e:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <Dio_WriteChannel>
	/*	enable SPI Module	*/
	SET_BIT(SPI_SPCR_REG,SPI_SPE_BIT_NO);
    2d72:	6e 9a       	sbi	0x0d, 6	; 13
	/*	enable SPI Module in Master mode	*/
	SET_BIT(SPI_SPCR_REG,SPI_MSTR_BIT_NO);
    2d74:	6c 9a       	sbi	0x0d, 4	; 13
	/*	set SCK frequency by F_CPU/16	*/
	/*	Set SPI Speed	*/
	SPI_SPCR_REG|=SPI_SCK_FREQ_FCPU_DIV_16;
    2d76:	68 9a       	sbi	0x0d, 0	; 13
}
    2d78:	08 95       	ret

00002d7a <I2C_MasterInit>:
#include "I2c.h"

void I2C_MasterInit(void)
{
    /* Bit Rate: 400 KHZ */
	I2C_TWBR_REG=0x0C;
    2d7a:	8c e0       	ldi	r24, 0x0C	; 12
    2d7c:	80 b9       	out	0x00, r24	; 0
    /* enable I2C Module	*/
	/* enable ACK check	*/
	I2C_TWCR_REG |=I2C_ENABLE|I2C_ENABLE_ACK;
    2d7e:	86 b7       	in	r24, 0x36	; 54
    2d80:	84 64       	ori	r24, 0x44	; 68
    2d82:	86 bf       	out	0x36, r24	; 54

}
    2d84:	08 95       	ret

00002d86 <I2C_SlaveInit>:
void I2C_SlaveInit(u8 addr)
{
	/*	enable general call response in slave mode	*/
	SET_BIT(I2C_TWAR_REG,I2C_SLAVE_RESPONSE_BIT_NO);
    2d86:	10 9a       	sbi	0x02, 0	; 2
    /* I2C Bus Slave Address	*/
	I2C_TWAR_REG |= (addr<<1);
    2d88:	92 b1       	in	r25, 0x02	; 2
    2d8a:	88 0f       	add	r24, r24
    2d8c:	98 2b       	or	r25, r24
    2d8e:	92 b9       	out	0x02, r25	; 2
    /* enable I2C Module	*/
	/*	enable ACK check	*/
	I2C_TWCR_REG |=I2C_ENABLE|I2C_ENABLE_ACK;
    2d90:	86 b7       	in	r24, 0x36	; 54
    2d92:	84 64       	ori	r24, 0x44	; 68
    2d94:	86 bf       	out	0x36, r24	; 54
}
    2d96:	08 95       	ret

00002d98 <I2C_StartCondition>:
boolean I2C_StartCondition(void)
{
	/*	send start condition	*/
	I2C_TWCR_REG = I2C_INTERRUPT_FLAG|I2C_START_COND;
    2d98:	80 ea       	ldi	r24, 0xA0	; 160
    2d9a:	86 bf       	out	0x36, r24	; 54
    /*	Wait until start condition sent successfully	*/
    while (!(CHK_BIT(I2C_TWCR_REG,I2C_INTERRUPT_FLAG_BIT_NO)))
    2d9c:	06 b6       	in	r0, 0x36	; 54
    2d9e:	07 fe       	sbrs	r0, 7
    2da0:	fd cf       	rjmp	.-6      	; 0x2d9c <I2C_StartCondition+0x4>
    return I2C_TWDR_REG;
}
u8 I2C_ReadStatus(void)
{
    u8 status;
    status = I2C_TWSR_REG & 0xF8;
    2da2:	81 b1       	in	r24, 0x01	; 1
    2da4:	90 e0       	ldi	r25, 0x00	; 0
    2da6:	88 7f       	andi	r24, 0xF8	; 248
    2da8:	88 30       	cpi	r24, 0x08	; 8
    2daa:	11 f0       	breq	.+4      	; 0x2db0 <I2C_StartCondition+0x18>
    else
    {
    	/*	Do Nothing	*/
    }
    return TRUE;
}
    2dac:	89 2f       	mov	r24, r25
    2dae:	08 95       	ret
    return I2C_TWDR_REG;
}
u8 I2C_ReadStatus(void)
{
    u8 status;
    status = I2C_TWSR_REG & 0xF8;
    2db0:	91 e0       	ldi	r25, 0x01	; 1
    else
    {
    	/*	Do Nothing	*/
    }
    return TRUE;
}
    2db2:	89 2f       	mov	r24, r25
    2db4:	08 95       	ret

00002db6 <I2C_RepeatedStartCondition>:
boolean I2C_RepeatedStartCondition(void)
{
	/*	send start condition	*/
	I2C_TWCR_REG |= I2C_INTERRUPT_FLAG|I2C_START_COND;
    2db6:	86 b7       	in	r24, 0x36	; 54
    2db8:	80 6a       	ori	r24, 0xA0	; 160
    2dba:	86 bf       	out	0x36, r24	; 54
    /*	Wait until start condition sent successfully	*/
    while (!(CHK_BIT(I2C_TWCR_REG,I2C_INTERRUPT_FLAG_BIT_NO)))
    2dbc:	06 b6       	in	r0, 0x36	; 54
    2dbe:	07 fe       	sbrs	r0, 7
    2dc0:	fd cf       	rjmp	.-6      	; 0x2dbc <I2C_RepeatedStartCondition+0x6>
    return I2C_TWDR_REG;
}
u8 I2C_ReadStatus(void)
{
    u8 status;
    status = I2C_TWSR_REG & 0xF8;
    2dc2:	81 b1       	in	r24, 0x01	; 1
    2dc4:	90 e0       	ldi	r25, 0x00	; 0
    2dc6:	88 7f       	andi	r24, 0xF8	; 248
    2dc8:	80 31       	cpi	r24, 0x10	; 16
    2dca:	11 f0       	breq	.+4      	; 0x2dd0 <I2C_RepeatedStartCondition+0x1a>
    else
    {
    	/*	Do Nothing	*/
    }
    return TRUE;
}
    2dcc:	89 2f       	mov	r24, r25
    2dce:	08 95       	ret
    return I2C_TWDR_REG;
}
u8 I2C_ReadStatus(void)
{
    u8 status;
    status = I2C_TWSR_REG & 0xF8;
    2dd0:	91 e0       	ldi	r25, 0x01	; 1
    else
    {
    	/*	Do Nothing	*/
    }
    return TRUE;
}
    2dd2:	89 2f       	mov	r24, r25
    2dd4:	08 95       	ret

00002dd6 <I2C_StopCondition>:
void I2C_StopCondition(void)
{
	/*	send stop condition	*/
	I2C_TWCR_REG |= I2C_INTERRUPT_FLAG|I2C_STOP_COND;
    2dd6:	86 b7       	in	r24, 0x36	; 54
    2dd8:	80 69       	ori	r24, 0x90	; 144
    2dda:	86 bf       	out	0x36, r24	; 54
	/*	Wait until start condition sent successfully	*/
    while (!(CHK_BIT(I2C_TWCR_REG,I2C_INTERRUPT_FLAG_BIT_NO)))
    2ddc:	06 b6       	in	r0, 0x36	; 54
    2dde:	07 fe       	sbrs	r0, 7
    2de0:	fd cf       	rjmp	.-6      	; 0x2ddc <I2C_StopCondition+0x6>
    {
    	/*Do Nothing */
    	   ;
    }

}
    2de2:	08 95       	ret

00002de4 <I2C_WriteByte>:
void I2C_WriteByte(u8 data)
{
    /*	Put data On I2C data Register	*/
	I2C_TWDR_REG = data;
    2de4:	83 b9       	out	0x03, r24	; 3
    /*	Send Data	*/
	I2C_TWCR_REG |= I2C_INTERRUPT_FLAG;
    2de6:	86 b7       	in	r24, 0x36	; 54
    2de8:	80 68       	ori	r24, 0x80	; 128
    2dea:	86 bf       	out	0x36, r24	; 54
	/*	Wait until data sent successfully	*/
    while (!(CHK_BIT(I2C_TWCR_REG,I2C_INTERRUPT_FLAG_BIT_NO)))
    2dec:	06 b6       	in	r0, 0x36	; 54
    2dee:	07 fe       	sbrs	r0, 7
    2df0:	fd cf       	rjmp	.-6      	; 0x2dec <I2C_WriteByte+0x8>
    {
    	/*Do Nothing */
    	   ;
    }
}
    2df2:	08 95       	ret

00002df4 <I2C_Send_SlaveAddressWriteOperation>:
boolean I2C_Send_SlaveAddressWriteOperation(u8 addr)
{
	u8 loc_addrWrite=0;
	loc_addrWrite=(addr<<1);
    2df4:	88 0f       	add	r24, r24

}
void I2C_WriteByte(u8 data)
{
    /*	Put data On I2C data Register	*/
	I2C_TWDR_REG = data;
    2df6:	83 b9       	out	0x03, r24	; 3
    /*	Send Data	*/
	I2C_TWCR_REG |= I2C_INTERRUPT_FLAG;
    2df8:	86 b7       	in	r24, 0x36	; 54
    2dfa:	80 68       	ori	r24, 0x80	; 128
    2dfc:	86 bf       	out	0x36, r24	; 54
	/*	Wait until data sent successfully	*/
    while (!(CHK_BIT(I2C_TWCR_REG,I2C_INTERRUPT_FLAG_BIT_NO)))
    2dfe:	06 b6       	in	r0, 0x36	; 54
    2e00:	07 fe       	sbrs	r0, 7
    2e02:	fd cf       	rjmp	.-6      	; 0x2dfe <I2C_Send_SlaveAddressWriteOperation+0xa>
    return I2C_TWDR_REG;
}
u8 I2C_ReadStatus(void)
{
    u8 status;
    status = I2C_TWSR_REG & 0xF8;
    2e04:	81 b1       	in	r24, 0x01	; 1
    2e06:	90 e0       	ldi	r25, 0x00	; 0
    2e08:	88 7f       	andi	r24, 0xF8	; 248
    2e0a:	88 31       	cpi	r24, 0x18	; 24
    2e0c:	11 f0       	breq	.+4      	; 0x2e12 <I2C_Send_SlaveAddressWriteOperation+0x1e>
    {
    	/*	Do Nothing	*/
    }
    return TRUE;

}
    2e0e:	89 2f       	mov	r24, r25
    2e10:	08 95       	ret
    return I2C_TWDR_REG;
}
u8 I2C_ReadStatus(void)
{
    u8 status;
    status = I2C_TWSR_REG & 0xF8;
    2e12:	91 e0       	ldi	r25, 0x01	; 1
    {
    	/*	Do Nothing	*/
    }
    return TRUE;

}
    2e14:	89 2f       	mov	r24, r25
    2e16:	08 95       	ret

00002e18 <I2C_Send_SlaveAddressReadOperation>:
boolean I2C_Send_SlaveAddressReadOperation(u8 addr)
{
	u8 loc_addrWrite=0;
	loc_addrWrite=(addr<<1)|(0x01);
    2e18:	88 0f       	add	r24, r24
    2e1a:	81 60       	ori	r24, 0x01	; 1

}
void I2C_WriteByte(u8 data)
{
    /*	Put data On I2C data Register	*/
	I2C_TWDR_REG = data;
    2e1c:	83 b9       	out	0x03, r24	; 3
    /*	Send Data	*/
	I2C_TWCR_REG |= I2C_INTERRUPT_FLAG;
    2e1e:	86 b7       	in	r24, 0x36	; 54
    2e20:	80 68       	ori	r24, 0x80	; 128
    2e22:	86 bf       	out	0x36, r24	; 54
	/*	Wait until data sent successfully	*/
    while (!(CHK_BIT(I2C_TWCR_REG,I2C_INTERRUPT_FLAG_BIT_NO)))
    2e24:	06 b6       	in	r0, 0x36	; 54
    2e26:	07 fe       	sbrs	r0, 7
    2e28:	fd cf       	rjmp	.-6      	; 0x2e24 <I2C_Send_SlaveAddressReadOperation+0xc>
    return I2C_TWDR_REG;
}
u8 I2C_ReadStatus(void)
{
    u8 status;
    status = I2C_TWSR_REG & 0xF8;
    2e2a:	81 b1       	in	r24, 0x01	; 1
    2e2c:	90 e0       	ldi	r25, 0x00	; 0
    2e2e:	88 7f       	andi	r24, 0xF8	; 248
    2e30:	80 34       	cpi	r24, 0x40	; 64
    2e32:	11 f0       	breq	.+4      	; 0x2e38 <I2C_Send_SlaveAddressReadOperation+0x20>
    else
    {
    	/*	Do Nothing	*/
    }
    return TRUE;
}
    2e34:	89 2f       	mov	r24, r25
    2e36:	08 95       	ret
    return I2C_TWDR_REG;
}
u8 I2C_ReadStatus(void)
{
    u8 status;
    status = I2C_TWSR_REG & 0xF8;
    2e38:	91 e0       	ldi	r25, 0x01	; 1
    else
    {
    	/*	Do Nothing	*/
    }
    return TRUE;
}
    2e3a:	89 2f       	mov	r24, r25
    2e3c:	08 95       	ret

00002e3e <I2C_ReadByte>:
u8 I2C_ReadByte(void)
{
	I2C_TWCR_REG |= I2C_INTERRUPT_FLAG;
    2e3e:	86 b7       	in	r24, 0x36	; 54
    2e40:	80 68       	ori	r24, 0x80	; 128
    2e42:	86 bf       	out	0x36, r24	; 54
	/*	Wait until data sent successfully	*/
    while (!(CHK_BIT(I2C_TWCR_REG,I2C_INTERRUPT_FLAG_BIT_NO)))
    2e44:	06 b6       	in	r0, 0x36	; 54
    2e46:	07 fe       	sbrs	r0, 7
    2e48:	fd cf       	rjmp	.-6      	; 0x2e44 <I2C_ReadByte+0x6>
    {
    	/*Do Nothing */
    	   ;
    }
    return I2C_TWDR_REG;
    2e4a:	83 b1       	in	r24, 0x03	; 3
}
    2e4c:	08 95       	ret

00002e4e <I2C_ReadStatus>:
u8 I2C_ReadStatus(void)
{
    u8 status;
    status = I2C_TWSR_REG & 0xF8;
    2e4e:	81 b1       	in	r24, 0x01	; 1
    return status;
}
    2e50:	88 7f       	andi	r24, 0xF8	; 248
    2e52:	08 95       	ret

00002e54 <Glbl_Interrupt_Enable>:

#include "Glbl_INT.h"

void Glbl_Interrupt_Enable()
{
	SET_BIT(GLBL_SREG_REG,7);
    2e54:	8f b7       	in	r24, 0x3f	; 63
    2e56:	80 68       	ori	r24, 0x80	; 128
    2e58:	8f bf       	out	0x3f, r24	; 63
}
    2e5a:	08 95       	ret

00002e5c <Glbl_Interrupt_Disable>:
void Glbl_Interrupt_Disable()
{
	CLR_BIT(GLBL_SREG_REG,7);
    2e5c:	8f b7       	in	r24, 0x3f	; 63
    2e5e:	8f 77       	andi	r24, 0x7F	; 127
    2e60:	8f bf       	out	0x3f, r24	; 63
}
    2e62:	08 95       	ret

00002e64 <Ext_Interrupt_Enable>:
#include "Ext_INT.h"


void Ext_Interrupt_Enable(ext_Int_t intID)
{
	switch (intID)
    2e64:	81 30       	cpi	r24, 0x01	; 1
    2e66:	69 f0       	breq	.+26     	; 0x2e82 <Ext_Interrupt_Enable+0x1e>
    2e68:	81 30       	cpi	r24, 0x01	; 1
    2e6a:	20 f4       	brcc	.+8      	; 0x2e74 <Ext_Interrupt_Enable+0x10>
	{
	case EXT_INT0:
			SET_BIT(EXT_INT_GICR_REG,6);
    2e6c:	8b b7       	in	r24, 0x3b	; 59
    2e6e:	80 64       	ori	r24, 0x40	; 64
    2e70:	8b bf       	out	0x3b, r24	; 59
    2e72:	08 95       	ret
#include "Ext_INT.h"


void Ext_Interrupt_Enable(ext_Int_t intID)
{
	switch (intID)
    2e74:	82 30       	cpi	r24, 0x02	; 2
    2e76:	09 f0       	breq	.+2      	; 0x2e7a <Ext_Interrupt_Enable+0x16>
    2e78:	08 95       	ret
	case EXT_INT1:
			SET_BIT(EXT_INT_GICR_REG,7);
			break;

	case EXT_INT2:
			SET_BIT(EXT_INT_GICR_REG,5);
    2e7a:	8b b7       	in	r24, 0x3b	; 59
    2e7c:	80 62       	ori	r24, 0x20	; 32
    2e7e:	8b bf       	out	0x3b, r24	; 59
    2e80:	08 95       	ret
	case EXT_INT0:
			SET_BIT(EXT_INT_GICR_REG,6);
			break;

	case EXT_INT1:
			SET_BIT(EXT_INT_GICR_REG,7);
    2e82:	8b b7       	in	r24, 0x3b	; 59
    2e84:	80 68       	ori	r24, 0x80	; 128
    2e86:	8b bf       	out	0x3b, r24	; 59
    2e88:	08 95       	ret

00002e8a <Ext_Interrupt_Disable>:
			break;
	}
}
void Ext_Interrupt_Disable(ext_Int_t intID)
{
	switch (intID)
    2e8a:	81 30       	cpi	r24, 0x01	; 1
    2e8c:	69 f0       	breq	.+26     	; 0x2ea8 <Ext_Interrupt_Disable+0x1e>
    2e8e:	81 30       	cpi	r24, 0x01	; 1
    2e90:	20 f4       	brcc	.+8      	; 0x2e9a <Ext_Interrupt_Disable+0x10>
	{
	case EXT_INT0:
			CLR_BIT(EXT_INT_GICR_REG,6);
    2e92:	8b b7       	in	r24, 0x3b	; 59
    2e94:	8f 7b       	andi	r24, 0xBF	; 191
    2e96:	8b bf       	out	0x3b, r24	; 59
    2e98:	08 95       	ret
			break;
	}
}
void Ext_Interrupt_Disable(ext_Int_t intID)
{
	switch (intID)
    2e9a:	82 30       	cpi	r24, 0x02	; 2
    2e9c:	09 f0       	breq	.+2      	; 0x2ea0 <Ext_Interrupt_Disable+0x16>
    2e9e:	08 95       	ret
	case EXT_INT1:
			CLR_BIT(EXT_INT_GICR_REG,7);
			break;

	case EXT_INT2:
			CLR_BIT(EXT_INT_GICR_REG,5);
    2ea0:	8b b7       	in	r24, 0x3b	; 59
    2ea2:	8f 7d       	andi	r24, 0xDF	; 223
    2ea4:	8b bf       	out	0x3b, r24	; 59
    2ea6:	08 95       	ret
	case EXT_INT0:
			CLR_BIT(EXT_INT_GICR_REG,6);
			break;

	case EXT_INT1:
			CLR_BIT(EXT_INT_GICR_REG,7);
    2ea8:	8b b7       	in	r24, 0x3b	; 59
    2eaa:	8f 77       	andi	r24, 0x7F	; 127
    2eac:	8b bf       	out	0x3b, r24	; 59
    2eae:	08 95       	ret

00002eb0 <Ext_Interrupt_SncControl>:

}

void Ext_Interrupt_SncControl(ext_Int_t intID, snc_mode_t mode)
{
	switch (intID)
    2eb0:	81 30       	cpi	r24, 0x01	; 1
    2eb2:	89 f0       	breq	.+34     	; 0x2ed6 <Ext_Interrupt_SncControl+0x26>
    2eb4:	81 30       	cpi	r24, 0x01	; 1
    2eb6:	20 f4       	brcc	.+8      	; 0x2ec0 <Ext_Interrupt_SncControl+0x10>
	{
		case EXT_INT0:
			EXT_INT_MCUCR_REG |=(mode<<0);
    2eb8:	85 b7       	in	r24, 0x35	; 53
    2eba:	86 2b       	or	r24, r22
    2ebc:	85 bf       	out	0x35, r24	; 53
    2ebe:	08 95       	ret

}

void Ext_Interrupt_SncControl(ext_Int_t intID, snc_mode_t mode)
{
	switch (intID)
    2ec0:	82 30       	cpi	r24, 0x02	; 2
    2ec2:	09 f0       	breq	.+2      	; 0x2ec6 <Ext_Interrupt_SncControl+0x16>
    2ec4:	08 95       	ret
		case EXT_INT1:
			EXT_INT_MCUCR_REG |=(mode<<2);
			break;

		case EXT_INT2:
			if (mode == FAILING_EDGE)
    2ec6:	62 30       	cpi	r22, 0x02	; 2
    2ec8:	61 f0       	breq	.+24     	; 0x2ee2 <Ext_Interrupt_SncControl+0x32>
			{
				CLR_BIT(EXT_INT_MCUCSR_REG,6);
			}
			else if (mode == RISING_EDGE)
    2eca:	63 30       	cpi	r22, 0x03	; 3
    2ecc:	d9 f7       	brne	.-10     	; 0x2ec4 <Ext_Interrupt_SncControl+0x14>
			{
				SET_BIT(EXT_INT_MCUCSR_REG,6);
    2ece:	84 b7       	in	r24, 0x34	; 52
    2ed0:	80 64       	ori	r24, 0x40	; 64
    2ed2:	84 bf       	out	0x34, r24	; 52
    2ed4:	08 95       	ret
		case EXT_INT0:
			EXT_INT_MCUCR_REG |=(mode<<0);
			break;

		case EXT_INT1:
			EXT_INT_MCUCR_REG |=(mode<<2);
    2ed6:	85 b7       	in	r24, 0x35	; 53
    2ed8:	66 0f       	add	r22, r22
    2eda:	66 0f       	add	r22, r22
    2edc:	86 2b       	or	r24, r22
    2ede:	85 bf       	out	0x35, r24	; 53
    2ee0:	08 95       	ret
			break;

		case EXT_INT2:
			if (mode == FAILING_EDGE)
			{
				CLR_BIT(EXT_INT_MCUCSR_REG,6);
    2ee2:	84 b7       	in	r24, 0x34	; 52
    2ee4:	8f 7b       	andi	r24, 0xBF	; 191
    2ee6:	84 bf       	out	0x34, r24	; 52
    2ee8:	08 95       	ret

00002eea <EEPROM_Write>:
#include <Eeprom.h>

void EEPROM_Write(u16 address,u8 data)
{
	/* Wait for completion of previous write */
	while(EEPROM_CR_REG & (1<<EEWE))
    2eea:	e1 99       	sbic	0x1c, 1	; 28
    2eec:	fe cf       	rjmp	.-4      	; 0x2eea <EEPROM_Write>
		/*	Do Nothing	*/		;
	/* Set up address and data registers */
	EEPROM_ARL_REG=address;
    2eee:	8e bb       	out	0x1e, r24	; 30
	EEPROM_ARH_REG = address>>8;
    2ef0:	9f bb       	out	0x1f, r25	; 31
	EEPROM_DR_REG = data;
    2ef2:	6d bb       	out	0x1d, r22	; 29
	/* Write logical one to EEMWE */
	EEPROM_CR_REG |= (1<<EEMWE);
    2ef4:	e2 9a       	sbi	0x1c, 2	; 28
	/* Start eeprom write by setting EEWE */
	EEPROM_CR_REG |= (1<<EEWE);
    2ef6:	e1 9a       	sbi	0x1c, 1	; 28
}
    2ef8:	08 95       	ret

00002efa <EEPROM_Read>:

u8 EEPROM_Read(u16 address)
{
	/* Wait for completion of previous write */
	while(EEPROM_CR_REG & (1<<EEWE))
    2efa:	e1 99       	sbic	0x1c, 1	; 28
    2efc:	fe cf       	rjmp	.-4      	; 0x2efa <EEPROM_Read>
			;
	/* Set up address register */
	EEPROM_ARL_REG	=address;
    2efe:	8e bb       	out	0x1e, r24	; 30
	EEPROM_ARH_REG = address>>8;
    2f00:	9f bb       	out	0x1f, r25	; 31
	/* Start eeprom read by writing EERE */
	EEPROM_CR_REG |= (1<<EERE);
    2f02:	e0 9a       	sbi	0x1c, 0	; 28
	/* Return data from data register */
	return EEPROM_DR_REG;
    2f04:	8d b3       	in	r24, 0x1d	; 29
}
    2f06:	08 95       	ret

00002f08 <Dio_ConfigChannel>:
#include "Dio.h"

/*DDRx      DDRA, DDRB, DDRC, DDRD*/
void Dio_ConfigChannel(port_type port,pin_type pin,direction_type direction)
{
	switch (port)
    2f08:	81 30       	cpi	r24, 0x01	; 1
    2f0a:	19 f1       	breq	.+70     	; 0x2f52 <Dio_ConfigChannel+0x4a>
    2f0c:	81 30       	cpi	r24, 0x01	; 1
    2f0e:	28 f0       	brcs	.+10     	; 0x2f1a <Dio_ConfigChannel+0x12>
    2f10:	82 30       	cpi	r24, 0x02	; 2
    2f12:	69 f1       	breq	.+90     	; 0x2f6e <Dio_ConfigChannel+0x66>
    2f14:	83 30       	cpi	r24, 0x03	; 3
    2f16:	79 f0       	breq	.+30     	; 0x2f36 <Dio_ConfigChannel+0x2e>
    2f18:	08 95       	ret
	{
	case DIO_PORTA:
		if (direction == INPUT)
    2f1a:	44 23       	and	r20, r20
    2f1c:	b1 f5       	brne	.+108    	; 0x2f8a <Dio_ConfigChannel+0x82>
		{
			CLR_BIT(DIO_DDRA_REG,pin);
    2f1e:	2a b3       	in	r18, 0x1a	; 26
    2f20:	81 e0       	ldi	r24, 0x01	; 1
    2f22:	90 e0       	ldi	r25, 0x00	; 0
    2f24:	02 c0       	rjmp	.+4      	; 0x2f2a <Dio_ConfigChannel+0x22>
    2f26:	88 0f       	add	r24, r24
    2f28:	99 1f       	adc	r25, r25
    2f2a:	6a 95       	dec	r22
    2f2c:	e2 f7       	brpl	.-8      	; 0x2f26 <Dio_ConfigChannel+0x1e>
    2f2e:	80 95       	com	r24
    2f30:	82 23       	and	r24, r18
    2f32:	8a bb       	out	0x1a, r24	; 26
    2f34:	08 95       	ret
			SET_BIT(DIO_DDRC_REG,pin);
		}
		break;

	case DIO_PORTD:
		if (direction == INPUT)
    2f36:	44 23       	and	r20, r20
    2f38:	09 f4       	brne	.+2      	; 0x2f3c <Dio_ConfigChannel+0x34>
    2f3a:	48 c0       	rjmp	.+144    	; 0x2fcc <Dio_ConfigChannel+0xc4>
		{
			CLR_BIT(DIO_DDRD_REG,pin);
		}
		else
		{
			SET_BIT(DIO_DDRD_REG,pin);
    2f3c:	21 b3       	in	r18, 0x11	; 17
    2f3e:	81 e0       	ldi	r24, 0x01	; 1
    2f40:	90 e0       	ldi	r25, 0x00	; 0
    2f42:	02 c0       	rjmp	.+4      	; 0x2f48 <Dio_ConfigChannel+0x40>
    2f44:	88 0f       	add	r24, r24
    2f46:	99 1f       	adc	r25, r25
    2f48:	6a 95       	dec	r22
    2f4a:	e2 f7       	brpl	.-8      	; 0x2f44 <Dio_ConfigChannel+0x3c>
    2f4c:	28 2b       	or	r18, r24
    2f4e:	21 bb       	out	0x11, r18	; 17
    2f50:	08 95       	ret
			SET_BIT(DIO_DDRA_REG,pin);
		}
		break;

	case DIO_PORTB:
		if (direction == INPUT)
    2f52:	44 23       	and	r20, r20
    2f54:	81 f5       	brne	.+96     	; 0x2fb6 <Dio_ConfigChannel+0xae>
		{
			CLR_BIT(DIO_DDRB_REG,pin);
    2f56:	27 b3       	in	r18, 0x17	; 23
    2f58:	81 e0       	ldi	r24, 0x01	; 1
    2f5a:	90 e0       	ldi	r25, 0x00	; 0
    2f5c:	02 c0       	rjmp	.+4      	; 0x2f62 <Dio_ConfigChannel+0x5a>
    2f5e:	88 0f       	add	r24, r24
    2f60:	99 1f       	adc	r25, r25
    2f62:	6a 95       	dec	r22
    2f64:	e2 f7       	brpl	.-8      	; 0x2f5e <Dio_ConfigChannel+0x56>
    2f66:	80 95       	com	r24
    2f68:	82 23       	and	r24, r18
    2f6a:	87 bb       	out	0x17, r24	; 23
    2f6c:	08 95       	ret
			SET_BIT(DIO_DDRB_REG,pin);
		}
		break;

	case DIO_PORTC:
		if (direction == INPUT)
    2f6e:	44 23       	and	r20, r20
    2f70:	b9 f4       	brne	.+46     	; 0x2fa0 <Dio_ConfigChannel+0x98>
		{
			CLR_BIT(DIO_DDRC_REG,pin);
    2f72:	24 b3       	in	r18, 0x14	; 20
    2f74:	81 e0       	ldi	r24, 0x01	; 1
    2f76:	90 e0       	ldi	r25, 0x00	; 0
    2f78:	02 c0       	rjmp	.+4      	; 0x2f7e <Dio_ConfigChannel+0x76>
    2f7a:	88 0f       	add	r24, r24
    2f7c:	99 1f       	adc	r25, r25
    2f7e:	6a 95       	dec	r22
    2f80:	e2 f7       	brpl	.-8      	; 0x2f7a <Dio_ConfigChannel+0x72>
    2f82:	80 95       	com	r24
    2f84:	82 23       	and	r24, r18
    2f86:	84 bb       	out	0x14, r24	; 20
    2f88:	08 95       	ret
		{
			CLR_BIT(DIO_DDRA_REG,pin);
		}
		else
		{
			SET_BIT(DIO_DDRA_REG,pin);
    2f8a:	2a b3       	in	r18, 0x1a	; 26
    2f8c:	81 e0       	ldi	r24, 0x01	; 1
    2f8e:	90 e0       	ldi	r25, 0x00	; 0
    2f90:	02 c0       	rjmp	.+4      	; 0x2f96 <Dio_ConfigChannel+0x8e>
    2f92:	88 0f       	add	r24, r24
    2f94:	99 1f       	adc	r25, r25
    2f96:	6a 95       	dec	r22
    2f98:	e2 f7       	brpl	.-8      	; 0x2f92 <Dio_ConfigChannel+0x8a>
    2f9a:	28 2b       	or	r18, r24
    2f9c:	2a bb       	out	0x1a, r18	; 26
    2f9e:	08 95       	ret
		{
			CLR_BIT(DIO_DDRC_REG,pin);
		}
		else
		{
			SET_BIT(DIO_DDRC_REG,pin);
    2fa0:	24 b3       	in	r18, 0x14	; 20
    2fa2:	81 e0       	ldi	r24, 0x01	; 1
    2fa4:	90 e0       	ldi	r25, 0x00	; 0
    2fa6:	02 c0       	rjmp	.+4      	; 0x2fac <Dio_ConfigChannel+0xa4>
    2fa8:	88 0f       	add	r24, r24
    2faa:	99 1f       	adc	r25, r25
    2fac:	6a 95       	dec	r22
    2fae:	e2 f7       	brpl	.-8      	; 0x2fa8 <Dio_ConfigChannel+0xa0>
    2fb0:	28 2b       	or	r18, r24
    2fb2:	24 bb       	out	0x14, r18	; 20
    2fb4:	08 95       	ret
		{
			CLR_BIT(DIO_DDRB_REG,pin);
		}
		else
		{
			SET_BIT(DIO_DDRB_REG,pin);
    2fb6:	27 b3       	in	r18, 0x17	; 23
    2fb8:	81 e0       	ldi	r24, 0x01	; 1
    2fba:	90 e0       	ldi	r25, 0x00	; 0
    2fbc:	02 c0       	rjmp	.+4      	; 0x2fc2 <Dio_ConfigChannel+0xba>
    2fbe:	88 0f       	add	r24, r24
    2fc0:	99 1f       	adc	r25, r25
    2fc2:	6a 95       	dec	r22
    2fc4:	e2 f7       	brpl	.-8      	; 0x2fbe <Dio_ConfigChannel+0xb6>
    2fc6:	28 2b       	or	r18, r24
    2fc8:	27 bb       	out	0x17, r18	; 23
    2fca:	08 95       	ret
		break;

	case DIO_PORTD:
		if (direction == INPUT)
		{
			CLR_BIT(DIO_DDRD_REG,pin);
    2fcc:	21 b3       	in	r18, 0x11	; 17
    2fce:	81 e0       	ldi	r24, 0x01	; 1
    2fd0:	90 e0       	ldi	r25, 0x00	; 0
    2fd2:	02 c0       	rjmp	.+4      	; 0x2fd8 <Dio_ConfigChannel+0xd0>
    2fd4:	88 0f       	add	r24, r24
    2fd6:	99 1f       	adc	r25, r25
    2fd8:	6a 95       	dec	r22
    2fda:	e2 f7       	brpl	.-8      	; 0x2fd4 <Dio_ConfigChannel+0xcc>
    2fdc:	80 95       	com	r24
    2fde:	82 23       	and	r24, r18
    2fe0:	81 bb       	out	0x11, r24	; 17
    2fe2:	08 95       	ret

00002fe4 <Dio_WriteChannel>:
		break;
	}
}
void Dio_WriteChannel(port_type port,pin_type pin,level_type level)
{
	switch (port)
    2fe4:	81 30       	cpi	r24, 0x01	; 1
    2fe6:	29 f1       	breq	.+74     	; 0x3032 <Dio_WriteChannel+0x4e>
    2fe8:	81 30       	cpi	r24, 0x01	; 1
    2fea:	28 f0       	brcs	.+10     	; 0x2ff6 <Dio_WriteChannel+0x12>
    2fec:	82 30       	cpi	r24, 0x02	; 2
    2fee:	79 f1       	breq	.+94     	; 0x304e <Dio_WriteChannel+0x6a>
    2ff0:	83 30       	cpi	r24, 0x03	; 3
    2ff2:	81 f0       	breq	.+32     	; 0x3014 <Dio_WriteChannel+0x30>
    2ff4:	08 95       	ret
	{
	case DIO_PORTA:
		if (level == STD_HIGH)
    2ff6:	41 30       	cpi	r20, 0x01	; 1
    2ff8:	09 f4       	brne	.+2      	; 0x2ffc <Dio_WriteChannel+0x18>
    2ffa:	4d c0       	rjmp	.+154    	; 0x3096 <Dio_WriteChannel+0xb2>
		{
			SET_BIT(DIO_PORTA_REG,pin);
		}
		else
		{
			CLR_BIT(DIO_PORTA_REG,pin);
    2ffc:	2b b3       	in	r18, 0x1b	; 27
    2ffe:	81 e0       	ldi	r24, 0x01	; 1
    3000:	90 e0       	ldi	r25, 0x00	; 0
    3002:	02 c0       	rjmp	.+4      	; 0x3008 <Dio_WriteChannel+0x24>
    3004:	88 0f       	add	r24, r24
    3006:	99 1f       	adc	r25, r25
    3008:	6a 95       	dec	r22
    300a:	e2 f7       	brpl	.-8      	; 0x3004 <Dio_WriteChannel+0x20>
    300c:	80 95       	com	r24
    300e:	82 23       	and	r24, r18
    3010:	8b bb       	out	0x1b, r24	; 27
    3012:	08 95       	ret
			CLR_BIT(DIO_PORTC_REG,pin);
		}
		break;

	case DIO_PORTD:
		if (level == STD_HIGH)
    3014:	41 30       	cpi	r20, 0x01	; 1
    3016:	09 f4       	brne	.+2      	; 0x301a <Dio_WriteChannel+0x36>
    3018:	49 c0       	rjmp	.+146    	; 0x30ac <Dio_WriteChannel+0xc8>
		{
			SET_BIT(DIO_PORTD_REG,pin);
		}
		else
		{
			CLR_BIT(DIO_PORTD_REG,pin);
    301a:	22 b3       	in	r18, 0x12	; 18
    301c:	81 e0       	ldi	r24, 0x01	; 1
    301e:	90 e0       	ldi	r25, 0x00	; 0
    3020:	02 c0       	rjmp	.+4      	; 0x3026 <Dio_WriteChannel+0x42>
    3022:	88 0f       	add	r24, r24
    3024:	99 1f       	adc	r25, r25
    3026:	6a 95       	dec	r22
    3028:	e2 f7       	brpl	.-8      	; 0x3022 <Dio_WriteChannel+0x3e>
    302a:	80 95       	com	r24
    302c:	82 23       	and	r24, r18
    302e:	82 bb       	out	0x12, r24	; 18
    3030:	08 95       	ret
			CLR_BIT(DIO_PORTA_REG,pin);
		}
		break;

	case DIO_PORTB:
		if (level == STD_HIGH)
    3032:	41 30       	cpi	r20, 0x01	; 1
    3034:	29 f1       	breq	.+74     	; 0x3080 <Dio_WriteChannel+0x9c>
		{
			SET_BIT(DIO_PORTB_REG,pin);
		}
		else
		{
			CLR_BIT(DIO_PORTB_REG,pin);
    3036:	28 b3       	in	r18, 0x18	; 24
    3038:	81 e0       	ldi	r24, 0x01	; 1
    303a:	90 e0       	ldi	r25, 0x00	; 0
    303c:	02 c0       	rjmp	.+4      	; 0x3042 <Dio_WriteChannel+0x5e>
    303e:	88 0f       	add	r24, r24
    3040:	99 1f       	adc	r25, r25
    3042:	6a 95       	dec	r22
    3044:	e2 f7       	brpl	.-8      	; 0x303e <Dio_WriteChannel+0x5a>
    3046:	80 95       	com	r24
    3048:	82 23       	and	r24, r18
    304a:	88 bb       	out	0x18, r24	; 24
    304c:	08 95       	ret
		}
		break;

	case DIO_PORTC:
		if (level == STD_HIGH)
    304e:	41 30       	cpi	r20, 0x01	; 1
    3050:	61 f0       	breq	.+24     	; 0x306a <Dio_WriteChannel+0x86>
		{
			SET_BIT(DIO_PORTC_REG,pin);
		}
		else
		{
			CLR_BIT(DIO_PORTC_REG,pin);
    3052:	25 b3       	in	r18, 0x15	; 21
    3054:	81 e0       	ldi	r24, 0x01	; 1
    3056:	90 e0       	ldi	r25, 0x00	; 0
    3058:	02 c0       	rjmp	.+4      	; 0x305e <Dio_WriteChannel+0x7a>
    305a:	88 0f       	add	r24, r24
    305c:	99 1f       	adc	r25, r25
    305e:	6a 95       	dec	r22
    3060:	e2 f7       	brpl	.-8      	; 0x305a <Dio_WriteChannel+0x76>
    3062:	80 95       	com	r24
    3064:	82 23       	and	r24, r18
    3066:	85 bb       	out	0x15, r24	; 21
    3068:	08 95       	ret
		break;

	case DIO_PORTC:
		if (level == STD_HIGH)
		{
			SET_BIT(DIO_PORTC_REG,pin);
    306a:	25 b3       	in	r18, 0x15	; 21
    306c:	81 e0       	ldi	r24, 0x01	; 1
    306e:	90 e0       	ldi	r25, 0x00	; 0
    3070:	02 c0       	rjmp	.+4      	; 0x3076 <Dio_WriteChannel+0x92>
    3072:	88 0f       	add	r24, r24
    3074:	99 1f       	adc	r25, r25
    3076:	6a 95       	dec	r22
    3078:	e2 f7       	brpl	.-8      	; 0x3072 <Dio_WriteChannel+0x8e>
    307a:	28 2b       	or	r18, r24
    307c:	25 bb       	out	0x15, r18	; 21
    307e:	08 95       	ret
		break;

	case DIO_PORTB:
		if (level == STD_HIGH)
		{
			SET_BIT(DIO_PORTB_REG,pin);
    3080:	28 b3       	in	r18, 0x18	; 24
    3082:	81 e0       	ldi	r24, 0x01	; 1
    3084:	90 e0       	ldi	r25, 0x00	; 0
    3086:	02 c0       	rjmp	.+4      	; 0x308c <Dio_WriteChannel+0xa8>
    3088:	88 0f       	add	r24, r24
    308a:	99 1f       	adc	r25, r25
    308c:	6a 95       	dec	r22
    308e:	e2 f7       	brpl	.-8      	; 0x3088 <Dio_WriteChannel+0xa4>
    3090:	28 2b       	or	r18, r24
    3092:	28 bb       	out	0x18, r18	; 24
    3094:	08 95       	ret
	switch (port)
	{
	case DIO_PORTA:
		if (level == STD_HIGH)
		{
			SET_BIT(DIO_PORTA_REG,pin);
    3096:	2b b3       	in	r18, 0x1b	; 27
    3098:	81 e0       	ldi	r24, 0x01	; 1
    309a:	90 e0       	ldi	r25, 0x00	; 0
    309c:	02 c0       	rjmp	.+4      	; 0x30a2 <Dio_WriteChannel+0xbe>
    309e:	88 0f       	add	r24, r24
    30a0:	99 1f       	adc	r25, r25
    30a2:	6a 95       	dec	r22
    30a4:	e2 f7       	brpl	.-8      	; 0x309e <Dio_WriteChannel+0xba>
    30a6:	28 2b       	or	r18, r24
    30a8:	2b bb       	out	0x1b, r18	; 27
    30aa:	08 95       	ret
		break;

	case DIO_PORTD:
		if (level == STD_HIGH)
		{
			SET_BIT(DIO_PORTD_REG,pin);
    30ac:	22 b3       	in	r18, 0x12	; 18
    30ae:	81 e0       	ldi	r24, 0x01	; 1
    30b0:	90 e0       	ldi	r25, 0x00	; 0
    30b2:	02 c0       	rjmp	.+4      	; 0x30b8 <Dio_WriteChannel+0xd4>
    30b4:	88 0f       	add	r24, r24
    30b6:	99 1f       	adc	r25, r25
    30b8:	6a 95       	dec	r22
    30ba:	e2 f7       	brpl	.-8      	; 0x30b4 <Dio_WriteChannel+0xd0>
    30bc:	28 2b       	or	r18, r24
    30be:	22 bb       	out	0x12, r18	; 18
    30c0:	08 95       	ret

000030c2 <Dio_WriteGroup>:
		break;
	}
}
void Dio_WriteGroup(port_type port,u8 mask,u8 data)
{
	switch(port)
    30c2:	81 30       	cpi	r24, 0x01	; 1
    30c4:	a9 f0       	breq	.+42     	; 0x30f0 <Dio_WriteGroup+0x2e>
    30c6:	81 30       	cpi	r24, 0x01	; 1
    30c8:	28 f0       	brcs	.+10     	; 0x30d4 <Dio_WriteGroup+0x12>
    30ca:	82 30       	cpi	r24, 0x02	; 2
    30cc:	c1 f0       	breq	.+48     	; 0x30fe <Dio_WriteGroup+0x3c>
    30ce:	83 30       	cpi	r24, 0x03	; 3
    30d0:	41 f0       	breq	.+16     	; 0x30e2 <Dio_WriteGroup+0x20>
    30d2:	08 95       	ret
	{
	case DIO_PORTA:
		DIO_PORTA_REG = (DIO_PORTA_REG&~mask)|(data & mask);
    30d4:	8b b3       	in	r24, 0x1b	; 27
    30d6:	46 23       	and	r20, r22
    30d8:	60 95       	com	r22
    30da:	86 23       	and	r24, r22
    30dc:	84 2b       	or	r24, r20
    30de:	8b bb       	out	0x1b, r24	; 27
    30e0:	08 95       	ret
	case DIO_PORTC:
		DIO_PORTC_REG = (DIO_PORTA_REG&~mask)|(data & mask);
		break;

	case DIO_PORTD:
		DIO_PORTD_REG = (DIO_PORTA_REG&~mask)|(data & mask);
    30e2:	8b b3       	in	r24, 0x1b	; 27
    30e4:	46 23       	and	r20, r22
    30e6:	60 95       	com	r22
    30e8:	86 23       	and	r24, r22
    30ea:	84 2b       	or	r24, r20
    30ec:	82 bb       	out	0x12, r24	; 18
    30ee:	08 95       	ret
	case DIO_PORTA:
		DIO_PORTA_REG = (DIO_PORTA_REG&~mask)|(data & mask);
		break;

	case DIO_PORTB:
		DIO_PORTB_REG = (DIO_PORTA_REG&~mask)|(data & mask);
    30f0:	8b b3       	in	r24, 0x1b	; 27
    30f2:	46 23       	and	r20, r22
    30f4:	60 95       	com	r22
    30f6:	86 23       	and	r24, r22
    30f8:	84 2b       	or	r24, r20
    30fa:	88 bb       	out	0x18, r24	; 24
    30fc:	08 95       	ret
		break;

	case DIO_PORTC:
		DIO_PORTC_REG = (DIO_PORTA_REG&~mask)|(data & mask);
    30fe:	8b b3       	in	r24, 0x1b	; 27
    3100:	46 23       	and	r20, r22
    3102:	60 95       	com	r22
    3104:	86 23       	and	r24, r22
    3106:	84 2b       	or	r24, r20
    3108:	85 bb       	out	0x15, r24	; 21
    310a:	08 95       	ret

0000310c <Dio_TogglChannel>:
		break;
	}
}
void Dio_TogglChannel(port_type port,pin_type pin)
{
	switch (port)
    310c:	81 30       	cpi	r24, 0x01	; 1
    310e:	e9 f0       	breq	.+58     	; 0x314a <Dio_TogglChannel+0x3e>
    3110:	81 30       	cpi	r24, 0x01	; 1
    3112:	28 f0       	brcs	.+10     	; 0x311e <Dio_TogglChannel+0x12>
    3114:	82 30       	cpi	r24, 0x02	; 2
    3116:	21 f1       	breq	.+72     	; 0x3160 <Dio_TogglChannel+0x54>
    3118:	83 30       	cpi	r24, 0x03	; 3
    311a:	61 f0       	breq	.+24     	; 0x3134 <Dio_TogglChannel+0x28>
    311c:	08 95       	ret
	{
	case DIO_PORTA:
		TOGGLE_BIT(DIO_PORTA_REG,pin);
    311e:	2b b3       	in	r18, 0x1b	; 27
    3120:	81 e0       	ldi	r24, 0x01	; 1
    3122:	90 e0       	ldi	r25, 0x00	; 0
    3124:	02 c0       	rjmp	.+4      	; 0x312a <Dio_TogglChannel+0x1e>
    3126:	88 0f       	add	r24, r24
    3128:	99 1f       	adc	r25, r25
    312a:	6a 95       	dec	r22
    312c:	e2 f7       	brpl	.-8      	; 0x3126 <Dio_TogglChannel+0x1a>
    312e:	28 27       	eor	r18, r24
    3130:	2b bb       	out	0x1b, r18	; 27
    3132:	08 95       	ret
	case DIO_PORTC:
		TOGGLE_BIT(DIO_PORTC_REG,pin);
		break;

	case DIO_PORTD:
		TOGGLE_BIT(DIO_PORTD_REG,pin);
    3134:	22 b3       	in	r18, 0x12	; 18
    3136:	81 e0       	ldi	r24, 0x01	; 1
    3138:	90 e0       	ldi	r25, 0x00	; 0
    313a:	02 c0       	rjmp	.+4      	; 0x3140 <Dio_TogglChannel+0x34>
    313c:	88 0f       	add	r24, r24
    313e:	99 1f       	adc	r25, r25
    3140:	6a 95       	dec	r22
    3142:	e2 f7       	brpl	.-8      	; 0x313c <Dio_TogglChannel+0x30>
    3144:	28 27       	eor	r18, r24
    3146:	22 bb       	out	0x12, r18	; 18
    3148:	08 95       	ret
	case DIO_PORTA:
		TOGGLE_BIT(DIO_PORTA_REG,pin);
		break;

	case DIO_PORTB:
		TOGGLE_BIT(DIO_PORTB_REG,pin);
    314a:	28 b3       	in	r18, 0x18	; 24
    314c:	81 e0       	ldi	r24, 0x01	; 1
    314e:	90 e0       	ldi	r25, 0x00	; 0
    3150:	02 c0       	rjmp	.+4      	; 0x3156 <Dio_TogglChannel+0x4a>
    3152:	88 0f       	add	r24, r24
    3154:	99 1f       	adc	r25, r25
    3156:	6a 95       	dec	r22
    3158:	e2 f7       	brpl	.-8      	; 0x3152 <Dio_TogglChannel+0x46>
    315a:	28 27       	eor	r18, r24
    315c:	28 bb       	out	0x18, r18	; 24
    315e:	08 95       	ret
		break;

	case DIO_PORTC:
		TOGGLE_BIT(DIO_PORTC_REG,pin);
    3160:	25 b3       	in	r18, 0x15	; 21
    3162:	81 e0       	ldi	r24, 0x01	; 1
    3164:	90 e0       	ldi	r25, 0x00	; 0
    3166:	02 c0       	rjmp	.+4      	; 0x316c <Dio_TogglChannel+0x60>
    3168:	88 0f       	add	r24, r24
    316a:	99 1f       	adc	r25, r25
    316c:	6a 95       	dec	r22
    316e:	e2 f7       	brpl	.-8      	; 0x3168 <Dio_TogglChannel+0x5c>
    3170:	28 27       	eor	r18, r24
    3172:	25 bb       	out	0x15, r18	; 21
    3174:	08 95       	ret

00003176 <Dio_ReadChannel>:
	}
}
level_type Dio_ReadChannel(port_type port,pin_type pin)
{
	level_type result = STD_LOW;
	switch (port)
    3176:	81 30       	cpi	r24, 0x01	; 1
    3178:	d1 f0       	breq	.+52     	; 0x31ae <Dio_ReadChannel+0x38>
    317a:	81 30       	cpi	r24, 0x01	; 1
    317c:	30 f0       	brcs	.+12     	; 0x318a <Dio_ReadChannel+0x14>
    317e:	82 30       	cpi	r24, 0x02	; 2
    3180:	f9 f0       	breq	.+62     	; 0x31c0 <Dio_ReadChannel+0x4a>
    3182:	83 30       	cpi	r24, 0x03	; 3
    3184:	59 f0       	breq	.+22     	; 0x319c <Dio_ReadChannel+0x26>
    3186:	80 e0       	ldi	r24, 0x00	; 0
    3188:	08 95       	ret
	{
	case DIO_PORTA:
		if CHK_BIT(DIO_PINA_REG,pin)
    318a:	89 b3       	in	r24, 0x19	; 25
    318c:	90 e0       	ldi	r25, 0x00	; 0
    318e:	02 c0       	rjmp	.+4      	; 0x3194 <Dio_ReadChannel+0x1e>
    3190:	95 95       	asr	r25
    3192:	87 95       	ror	r24
    3194:	6a 95       	dec	r22
    3196:	e2 f7       	brpl	.-8      	; 0x3190 <Dio_ReadChannel+0x1a>
    3198:	81 70       	andi	r24, 0x01	; 1
    319a:	08 95       	ret
		{
			result = STD_LOW;
		}
		break;
	case DIO_PORTD:
		if CHK_BIT(DIO_PIND_REG,pin)
    319c:	80 b3       	in	r24, 0x10	; 16
    319e:	90 e0       	ldi	r25, 0x00	; 0
    31a0:	02 c0       	rjmp	.+4      	; 0x31a6 <Dio_ReadChannel+0x30>
    31a2:	95 95       	asr	r25
    31a4:	87 95       	ror	r24
    31a6:	6a 95       	dec	r22
    31a8:	e2 f7       	brpl	.-8      	; 0x31a2 <Dio_ReadChannel+0x2c>
    31aa:	81 70       	andi	r24, 0x01	; 1
			result = STD_LOW;
		}
		break;
	}
	return result;
}
    31ac:	08 95       	ret
		{
			result = STD_LOW;
		}
		break;
	case DIO_PORTB:
		if CHK_BIT(DIO_PINB_REG,pin)
    31ae:	86 b3       	in	r24, 0x16	; 22
    31b0:	90 e0       	ldi	r25, 0x00	; 0
    31b2:	02 c0       	rjmp	.+4      	; 0x31b8 <Dio_ReadChannel+0x42>
    31b4:	95 95       	asr	r25
    31b6:	87 95       	ror	r24
    31b8:	6a 95       	dec	r22
    31ba:	e2 f7       	brpl	.-8      	; 0x31b4 <Dio_ReadChannel+0x3e>
    31bc:	81 70       	andi	r24, 0x01	; 1
    31be:	08 95       	ret
		{
			result = STD_LOW;
		}
		break;
	case DIO_PORTC:
		if CHK_BIT(DIO_PINC_REG,pin)
    31c0:	83 b3       	in	r24, 0x13	; 19
    31c2:	90 e0       	ldi	r25, 0x00	; 0
    31c4:	02 c0       	rjmp	.+4      	; 0x31ca <Dio_ReadChannel+0x54>
    31c6:	95 95       	asr	r25
    31c8:	87 95       	ror	r24
    31ca:	6a 95       	dec	r22
    31cc:	e2 f7       	brpl	.-8      	; 0x31c6 <Dio_ReadChannel+0x50>
    31ce:	81 70       	andi	r24, 0x01	; 1
    31d0:	08 95       	ret

000031d2 <Dio_ConfigChannelPullUp>:
	}
	return result;
}
void Dio_ConfigChannelPullUp(port_type port,pin_type pin)
{
	switch (port)
    31d2:	81 30       	cpi	r24, 0x01	; 1
    31d4:	39 f0       	breq	.+14     	; 0x31e4 <Dio_ConfigChannelPullUp+0x12>
    31d6:	81 30       	cpi	r24, 0x01	; 1
    31d8:	28 f0       	brcs	.+10     	; 0x31e4 <Dio_ConfigChannelPullUp+0x12>
    31da:	82 30       	cpi	r24, 0x02	; 2
    31dc:	19 f0       	breq	.+6      	; 0x31e4 <Dio_ConfigChannelPullUp+0x12>
    31de:	83 30       	cpi	r24, 0x03	; 3
    31e0:	61 f0       	breq	.+24     	; 0x31fa <Dio_ConfigChannelPullUp+0x28>
    31e2:	08 95       	ret
		break;
		case DIO_PORTB:
			SET_BIT(DIO_PORTA_REG,pin);
		break;
		case DIO_PORTC:
			SET_BIT(DIO_PORTA_REG,pin);
    31e4:	2b b3       	in	r18, 0x1b	; 27
    31e6:	81 e0       	ldi	r24, 0x01	; 1
    31e8:	90 e0       	ldi	r25, 0x00	; 0
    31ea:	02 c0       	rjmp	.+4      	; 0x31f0 <Dio_ConfigChannelPullUp+0x1e>
    31ec:	88 0f       	add	r24, r24
    31ee:	99 1f       	adc	r25, r25
    31f0:	6a 95       	dec	r22
    31f2:	e2 f7       	brpl	.-8      	; 0x31ec <Dio_ConfigChannelPullUp+0x1a>
    31f4:	28 2b       	or	r18, r24
    31f6:	2b bb       	out	0x1b, r18	; 27
    31f8:	08 95       	ret
		break;
		case DIO_PORTD:
			SET_BIT(DIO_PORTA_REG,pin);
    31fa:	2b b3       	in	r18, 0x1b	; 27
    31fc:	81 e0       	ldi	r24, 0x01	; 1
    31fe:	90 e0       	ldi	r25, 0x00	; 0
    3200:	02 c0       	rjmp	.+4      	; 0x3206 <Dio_ConfigChannelPullUp+0x34>
    3202:	88 0f       	add	r24, r24
    3204:	99 1f       	adc	r25, r25
    3206:	6a 95       	dec	r22
    3208:	e2 f7       	brpl	.-8      	; 0x3202 <Dio_ConfigChannelPullUp+0x30>
    320a:	28 2b       	or	r18, r24
    320c:	2b bb       	out	0x1b, r18	; 27
    320e:	08 95       	ret

00003210 <adcInit>:
 ********************************/
#include "Adc.h"

void adcInit(void)
{
	ADC_ADMUX_REG|=(AVCC5V_REF<<6);  /*	AVCC aas Vref	*/
    3210:	3e 9a       	sbi	0x07, 6	; 7
	ADC_ADCSRA_REG=(ADC_ENABLE)|(ADCPS_128);
    3212:	87 e8       	ldi	r24, 0x87	; 135
    3214:	86 b9       	out	0x06, r24	; 6
}
    3216:	08 95       	ret

00003218 <adcRead>:
u16 adcRead(u8 chnlNo)
{
    u16 result;
    ADC_ADMUX_REG = (ADC_ADMUX_REG & 0xF8)|(chnlNo);
    3218:	97 b1       	in	r25, 0x07	; 7
    321a:	98 7f       	andi	r25, 0xF8	; 248
    321c:	98 2b       	or	r25, r24
    321e:	97 b9       	out	0x07, r25	; 7
    ADC_ADCSRA_REG|=(ADC_START_CONVERSION);
    3220:	36 9a       	sbi	0x06, 6	; 6
 	while(!(CHK_BIT(ADC_ADCSRA_REG,ADIF_BIT_NO)))
    3222:	34 9b       	sbis	0x06, 4	; 6
    3224:	fe cf       	rjmp	.-4      	; 0x3222 <adcRead+0xa>
 		  {
 		  	  /*	Do Nothing	*/
 		  	  	  ;
 		  }
 	/*	Clear Interrupt Flag To Be Ready For Another Conversion	*/
 	 ADC_ADCSRA_REG|=(1<<ADIF_BIT_NO);
    3226:	34 9a       	sbi	0x06, 4	; 6
    result=(ADC_ADCL_REG|(ADC_ADCH_REG<<8));
    3228:	24 b1       	in	r18, 0x04	; 4
    322a:	45 b1       	in	r20, 0x05	; 5
    322c:	94 2f       	mov	r25, r20
    322e:	80 e0       	ldi	r24, 0x00	; 0
    3230:	30 e0       	ldi	r19, 0x00	; 0
    3232:	28 2b       	or	r18, r24
    3234:	39 2b       	or	r19, r25
 	return result;
}
    3236:	c9 01       	movw	r24, r18
    3238:	08 95       	ret

0000323a <__udivmodqi4>:
    323a:	99 1b       	sub	r25, r25
    323c:	79 e0       	ldi	r23, 0x09	; 9
    323e:	04 c0       	rjmp	.+8      	; 0x3248 <__udivmodqi4_ep>

00003240 <__udivmodqi4_loop>:
    3240:	99 1f       	adc	r25, r25
    3242:	96 17       	cp	r25, r22
    3244:	08 f0       	brcs	.+2      	; 0x3248 <__udivmodqi4_ep>
    3246:	96 1b       	sub	r25, r22

00003248 <__udivmodqi4_ep>:
    3248:	88 1f       	adc	r24, r24
    324a:	7a 95       	dec	r23
    324c:	c9 f7       	brne	.-14     	; 0x3240 <__udivmodqi4_loop>
    324e:	80 95       	com	r24
    3250:	08 95       	ret

00003252 <__udivmodhi4>:
    3252:	aa 1b       	sub	r26, r26
    3254:	bb 1b       	sub	r27, r27
    3256:	51 e1       	ldi	r21, 0x11	; 17
    3258:	07 c0       	rjmp	.+14     	; 0x3268 <__udivmodhi4_ep>

0000325a <__udivmodhi4_loop>:
    325a:	aa 1f       	adc	r26, r26
    325c:	bb 1f       	adc	r27, r27
    325e:	a6 17       	cp	r26, r22
    3260:	b7 07       	cpc	r27, r23
    3262:	10 f0       	brcs	.+4      	; 0x3268 <__udivmodhi4_ep>
    3264:	a6 1b       	sub	r26, r22
    3266:	b7 0b       	sbc	r27, r23

00003268 <__udivmodhi4_ep>:
    3268:	88 1f       	adc	r24, r24
    326a:	99 1f       	adc	r25, r25
    326c:	5a 95       	dec	r21
    326e:	a9 f7       	brne	.-22     	; 0x325a <__udivmodhi4_loop>
    3270:	80 95       	com	r24
    3272:	90 95       	com	r25
    3274:	bc 01       	movw	r22, r24
    3276:	cd 01       	movw	r24, r26
    3278:	08 95       	ret

0000327a <__prologue_saves__>:
    327a:	2f 92       	push	r2
    327c:	3f 92       	push	r3
    327e:	4f 92       	push	r4
    3280:	5f 92       	push	r5
    3282:	6f 92       	push	r6
    3284:	7f 92       	push	r7
    3286:	8f 92       	push	r8
    3288:	9f 92       	push	r9
    328a:	af 92       	push	r10
    328c:	bf 92       	push	r11
    328e:	cf 92       	push	r12
    3290:	df 92       	push	r13
    3292:	ef 92       	push	r14
    3294:	ff 92       	push	r15
    3296:	0f 93       	push	r16
    3298:	1f 93       	push	r17
    329a:	cf 93       	push	r28
    329c:	df 93       	push	r29
    329e:	cd b7       	in	r28, 0x3d	; 61
    32a0:	de b7       	in	r29, 0x3e	; 62
    32a2:	ca 1b       	sub	r28, r26
    32a4:	db 0b       	sbc	r29, r27
    32a6:	0f b6       	in	r0, 0x3f	; 63
    32a8:	f8 94       	cli
    32aa:	de bf       	out	0x3e, r29	; 62
    32ac:	0f be       	out	0x3f, r0	; 63
    32ae:	cd bf       	out	0x3d, r28	; 61
    32b0:	09 94       	ijmp

000032b2 <__epilogue_restores__>:
    32b2:	2a 88       	ldd	r2, Y+18	; 0x12
    32b4:	39 88       	ldd	r3, Y+17	; 0x11
    32b6:	48 88       	ldd	r4, Y+16	; 0x10
    32b8:	5f 84       	ldd	r5, Y+15	; 0x0f
    32ba:	6e 84       	ldd	r6, Y+14	; 0x0e
    32bc:	7d 84       	ldd	r7, Y+13	; 0x0d
    32be:	8c 84       	ldd	r8, Y+12	; 0x0c
    32c0:	9b 84       	ldd	r9, Y+11	; 0x0b
    32c2:	aa 84       	ldd	r10, Y+10	; 0x0a
    32c4:	b9 84       	ldd	r11, Y+9	; 0x09
    32c6:	c8 84       	ldd	r12, Y+8	; 0x08
    32c8:	df 80       	ldd	r13, Y+7	; 0x07
    32ca:	ee 80       	ldd	r14, Y+6	; 0x06
    32cc:	fd 80       	ldd	r15, Y+5	; 0x05
    32ce:	0c 81       	ldd	r16, Y+4	; 0x04
    32d0:	1b 81       	ldd	r17, Y+3	; 0x03
    32d2:	aa 81       	ldd	r26, Y+2	; 0x02
    32d4:	b9 81       	ldd	r27, Y+1	; 0x01
    32d6:	ce 0f       	add	r28, r30
    32d8:	d1 1d       	adc	r29, r1
    32da:	0f b6       	in	r0, 0x3f	; 63
    32dc:	f8 94       	cli
    32de:	de bf       	out	0x3e, r29	; 62
    32e0:	0f be       	out	0x3f, r0	; 63
    32e2:	cd bf       	out	0x3d, r28	; 61
    32e4:	ed 01       	movw	r28, r26
    32e6:	08 95       	ret

000032e8 <memcpy>:
    32e8:	fb 01       	movw	r30, r22
    32ea:	dc 01       	movw	r26, r24
    32ec:	02 c0       	rjmp	.+4      	; 0x32f2 <memcpy+0xa>
    32ee:	01 90       	ld	r0, Z+
    32f0:	0d 92       	st	X+, r0
    32f2:	41 50       	subi	r20, 0x01	; 1
    32f4:	50 40       	sbci	r21, 0x00	; 0
    32f6:	d8 f7       	brcc	.-10     	; 0x32ee <memcpy+0x6>
    32f8:	08 95       	ret

000032fa <memset>:
    32fa:	dc 01       	movw	r26, r24
    32fc:	01 c0       	rjmp	.+2      	; 0x3300 <memset+0x6>
    32fe:	6d 93       	st	X+, r22
    3300:	41 50       	subi	r20, 0x01	; 1
    3302:	50 40       	sbci	r21, 0x00	; 0
    3304:	e0 f7       	brcc	.-8      	; 0x32fe <memset+0x4>
    3306:	08 95       	ret

00003308 <strncpy>:
    3308:	fb 01       	movw	r30, r22
    330a:	dc 01       	movw	r26, r24
    330c:	41 50       	subi	r20, 0x01	; 1
    330e:	50 40       	sbci	r21, 0x00	; 0
    3310:	48 f0       	brcs	.+18     	; 0x3324 <strncpy+0x1c>
    3312:	01 90       	ld	r0, Z+
    3314:	0d 92       	st	X+, r0
    3316:	00 20       	and	r0, r0
    3318:	c9 f7       	brne	.-14     	; 0x330c <strncpy+0x4>
    331a:	01 c0       	rjmp	.+2      	; 0x331e <strncpy+0x16>
    331c:	1d 92       	st	X+, r1
    331e:	41 50       	subi	r20, 0x01	; 1
    3320:	50 40       	sbci	r21, 0x00	; 0
    3322:	e0 f7       	brcc	.-8      	; 0x331c <strncpy+0x14>
    3324:	08 95       	ret

00003326 <_exit>:
    3326:	f8 94       	cli

00003328 <__stop_program>:
    3328:	ff cf       	rjmp	.-2      	; 0x3328 <__stop_program>
